<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FFmpeg.AutoGen</name>
    </assembly>
    <members>
        <member name="P:FFmpeg.AutoGen.ffmpeg.RootPath">
            <summary>
                Gets or sets the root path for loading libraries.
            </summary>
            <value>The root path.</value>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_alloc(FFmpeg.AutoGen.AVBitStreamFilter*,FFmpeg.AutoGen.AVBSFContext**)">
            <summary>Allocate a context for a given bitstream filter. The caller must fill in the context parameters as described in the documentation and then call av_bsf_init() before sending any data to the filter.</summary>
            <param name="filter">the filter for which to allocate an instance.</param>
            <param name="ctx">a pointer into which the pointer to the newly-allocated context will be written. It must be freed with av_bsf_free() after the filtering is done.</param>
            <returns>0 on success, a negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_flush(FFmpeg.AutoGen.AVBSFContext*)">
            <summary>Reset the internal bitstream filter state / flush internal buffers.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_free(FFmpeg.AutoGen.AVBSFContext**)">
            <summary>Free a bitstream filter context and everything associated with it; write NULL into the supplied pointer.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_get_by_name(System.String)">
            <summary>Returns a bitstream filter with the specified name or NULL if no such bitstream filter exists.</summary>
            <returns>a bitstream filter with the specified name or NULL if no such bitstream filter exists.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_get_class">
            <summary>Get the AVClass for AVBSFContext. It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_get_null_filter(FFmpeg.AutoGen.AVBSFContext**)">
            <summary>Get null/pass-through bitstream filter.</summary>
            <param name="bsf">Pointer to be set to new instance of pass-through bitstream filter</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_init(FFmpeg.AutoGen.AVBSFContext*)">
            <summary>Prepare the filter for use, after all the parameters and options have been set.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_iterate(System.Void**)">
            <summary>Iterate over all registered bitstream filters.</summary>
            <param name="opaque">a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration.</param>
            <returns>the next registered bitstream filter or NULL when the iteration is finished</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_list_alloc">
            <summary>Allocate empty list of bitstream filters. The list must be later freed by av_bsf_list_free() or finalized by av_bsf_list_finalize().</summary>
            <returns>Pointer to</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_list_append(FFmpeg.AutoGen.AVBSFList*,FFmpeg.AutoGen.AVBSFContext*)">
            <summary>Append bitstream filter to the list of bitstream filters.</summary>
            <param name="lst">List to append to</param>
            <param name="bsf">Filter context to be appended</param>
            <returns>&gt;=0 on success, negative AVERROR in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_list_append2(FFmpeg.AutoGen.AVBSFList*,System.String,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Construct new bitstream filter context given it&apos;s name and options and append it to the list of bitstream filters.</summary>
            <param name="lst">List to append to</param>
            <param name="bsf_name">Name of the bitstream filter</param>
            <param name="options">Options for the bitstream filter, can be set to NULL</param>
            <returns>&gt;=0 on success, negative AVERROR in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_list_finalize(FFmpeg.AutoGen.AVBSFList**,FFmpeg.AutoGen.AVBSFContext**)">
            <summary>Finalize list of bitstream filters.</summary>
            <param name="lst">Filter list structure to be transformed</param>
            <param name="bsf">Pointer to be set to newly created</param>
            <returns>&gt;=0 on success, negative AVERROR in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_list_free(FFmpeg.AutoGen.AVBSFList**)">
            <summary>Free list of bitstream filters.</summary>
            <param name="lst">Pointer to pointer returned by av_bsf_list_alloc()</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_list_parse_str(System.String,FFmpeg.AutoGen.AVBSFContext**)">
            <summary>Parse string describing list of bitstream filters and create single Resulting allocated by av_bsf_alloc().</summary>
            <param name="str">String describing chain of bitstream filters in format `bsf1[=opt1=val1:opt2=val2][,bsf2]`</param>
            <param name="bsf">Pointer to be set to newly created</param>
            <returns>&gt;=0 on success, negative AVERROR in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_receive_packet(FFmpeg.AutoGen.AVBSFContext*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Retrieve a filtered packet.</summary>
            <param name="pkt">this struct will be filled with the contents of the filtered packet. It is owned by the caller and must be freed using av_packet_unref() when it is no longer needed. This parameter should be &quot;clean&quot; (i.e. freshly allocated with av_packet_alloc() or unreffed with av_packet_unref()) when this function is called. If this function returns successfully, the contents of pkt will be completely overwritten by the returned data. On failure, pkt is not touched.</param>
            <returns>0 on success. AVERROR(EAGAIN) if more packets need to be sent to the filter (using av_bsf_send_packet()) to get more output. AVERROR_EOF if there will be no further output from the filter. Another negative AVERROR value if an error occurs.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bsf_send_packet(FFmpeg.AutoGen.AVBSFContext*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Submit a packet for filtering.</summary>
            <param name="pkt">the packet to filter. The bitstream filter will take ownership of the packet and reset the contents of pkt. pkt is not touched if an error occurs. If pkt is empty (i.e. NULL, or pkt-&gt;data is NULL and pkt-&gt;side_data_elems zero), it signals the end of the stream (i.e. no more non-empty packets will be sent; sending more empty packets does nothing) and will cause the filter to output any packets it may have buffered internally.</param>
            <returns>0 on success. AVERROR(EAGAIN) if packets need to be retrieved from the filter (using av_bsf_receive_packet()) before new input can be consumed. Another negative AVERROR value if an error occurs.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_codec_get_pkt_timebase(FFmpeg.AutoGen.AVCodecContext*)">
            <summary>Accessors for some AVCodecContext fields. These used to be provided for ABI compatibility, and do not need to be used anymore.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_codec_is_decoder(FFmpeg.AutoGen.AVCodec*)">
            <summary>Returns a non-zero number if codec is a decoder, zero otherwise</summary>
            <returns>a non-zero number if codec is a decoder, zero otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_codec_is_encoder(FFmpeg.AutoGen.AVCodec*)">
            <summary>Returns a non-zero number if codec is an encoder, zero otherwise</summary>
            <returns>a non-zero number if codec is an encoder, zero otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_codec_iterate(System.Void**)">
            <summary>Iterate over all registered codecs.</summary>
            <param name="opaque">a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration.</param>
            <returns>the next registered codec or NULL when the iteration is finished</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_codec_next(FFmpeg.AutoGen.AVCodec*)">
            <summary>If c is NULL, returns the first registered codec, if c is non-NULL, returns the next registered codec after c, or NULL if c is the last one.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_copy_packet(FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Copy packet, including contents</summary>
            <returns>0 on success, negative AVERROR on fail</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_copy_packet_side_data(FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Copy packet side data</summary>
            <returns>0 on success, negative AVERROR on fail</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_cpb_properties_alloc(System.UInt64*)">
            <summary>Allocate a CPB properties structure and initialize its fields to default values.</summary>
            <param name="size">if non-NULL, the size of the allocated struct will be written here. This is useful for embedding it in side data.</param>
            <returns>the newly allocated struct or NULL on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_d3d11va_alloc_context">
            <summary>Allocate an AVD3D11VAContext.</summary>
            <returns>Newly-allocated AVD3D11VAContext or NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fast_padded_malloc(System.Void*,System.UInt32*,System.UInt64)">
            <summary>Same behaviour av_fast_malloc but the buffer has additional AV_INPUT_BUFFER_PADDING_SIZE at the end which will always be 0.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fast_padded_mallocz(System.Void*,System.UInt32*,System.UInt64)">
            <summary>Same behaviour av_fast_padded_malloc except that buffer will always be 0-initialized after call.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_free_packet(FFmpeg.AutoGen.AVPacket*)">
            <summary>Free a packet.</summary>
            <param name="pkt">packet to free</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_audio_frame_duration(FFmpeg.AutoGen.AVCodecContext*,System.Int32)">
            <summary>Return audio frame duration.</summary>
            <param name="avctx">codec context</param>
            <param name="frame_bytes">size of the frame, or 0 if unknown</param>
            <returns>frame duration, in samples, if known. 0 if not able to determine.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_audio_frame_duration2(FFmpeg.AutoGen.AVCodecParameters*,System.Int32)">
            <summary>This function is the same as av_get_audio_frame_duration(), except it works with AVCodecParameters instead of an AVCodecContext.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_bits_per_sample(FFmpeg.AutoGen.AVCodecID)">
            <summary>Return codec bits per sample.</summary>
            <param name="codec_id">the codec</param>
            <returns>Number of bits per sample or zero if unknown for the given codec.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_codec_tag_string(System.Byte*,System.UInt64,System.UInt32)">
            <summary>Put a string representing the codec tag codec_tag in buf.</summary>
            <param name="buf">buffer to place codec tag in</param>
            <param name="buf_size">size in bytes of buf</param>
            <param name="codec_tag">codec tag to assign</param>
            <returns>the length of the string that would have been generated if enough space had been available, excluding the trailing null</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_exact_bits_per_sample(FFmpeg.AutoGen.AVCodecID)">
            <summary>Return codec bits per sample. Only return non-zero if the bits per sample is exactly correct, not an approximation.</summary>
            <param name="codec_id">the codec</param>
            <returns>Number of bits per sample or zero if unknown for the given codec.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_pcm_codec(FFmpeg.AutoGen.AVSampleFormat,System.Int32)">
            <summary>Return the PCM codec associated with a sample format.</summary>
            <param name="be">endianness, 0 for little, 1 for big, -1 (or anything else) for native</param>
            <returns>AV_CODEC_ID_PCM_* or AV_CODEC_ID_NONE</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_profile_name(FFmpeg.AutoGen.AVCodec*,System.Int32)">
            <summary>Return a name for the specified profile, if available.</summary>
            <param name="codec">the codec that is searched for the given profile</param>
            <param name="profile">the profile value for which a name is requested</param>
            <returns>A name for the profile if found, NULL otherwise.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_grow_packet(FFmpeg.AutoGen.AVPacket*,System.Int32)">
            <summary>Increase packet size, correctly zeroing padding</summary>
            <param name="pkt">packet</param>
            <param name="grow_by">number of bytes by which to increase the size of the packet</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwaccel_next(FFmpeg.AutoGen.AVHWAccel*)">
            <summary>If hwaccel is NULL, returns the first registered hardware accelerator, if hwaccel is non-NULL, returns the next registered hardware accelerator after hwaccel, or NULL if hwaccel is the last one.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_init_packet(FFmpeg.AutoGen.AVPacket*)">
            <summary>Initialize optional fields of a packet with default values.</summary>
            <param name="pkt">packet</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_lockmgr_register(FFmpeg.AutoGen.av_lockmgr_register_cb_func)">
            <summary>Register a user provided lock manager supporting the operations specified by AVLockOp. The &quot;mutex&quot; argument to the function points to a (void *) where the lockmgr should store/get a pointer to a user allocated mutex. It is NULL upon AV_LOCK_CREATE and equal to the value left by the last call for all other ops. If the lock manager is unable to perform the op then it should leave the mutex in the same state as when it was called and return a non-zero value. However, when called with AV_LOCK_DESTROY the mutex will always be assumed to have been successfully destroyed. If av_lockmgr_register succeeds it will return a non-negative value, if it fails it will return a negative value and destroy all mutex and unregister all callbacks. av_lockmgr_register is not thread-safe, it must be called from a single thread before any calls which make use of locking are used.</summary>
            <param name="cb">User defined callback. av_lockmgr_register invokes calls to this callback and the previously registered callback. The callback will be used to create more than one mutex each of which must be backed by its own underlying locking mechanism (i.e. do not use a single static object to implement your lock manager). If cb is set to NULL the lockmgr will be unregistered.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_new_packet(FFmpeg.AutoGen.AVPacket*,System.Int32)">
            <summary>Allocate the payload of a packet and initialize its fields with default values.</summary>
            <param name="pkt">packet</param>
            <param name="size">wanted payload size</param>
            <returns>0 if OK, AVERROR_xxx otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_add_side_data(FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVPacketSideDataType,System.Byte*,System.UInt64)">
            <summary>Wrap an existing array as a packet side data.</summary>
            <param name="pkt">packet</param>
            <param name="type">side information type</param>
            <param name="data">the side data array. It must be allocated with the av_malloc() family of functions. The ownership of the data is transferred to pkt.</param>
            <param name="size">side information size</param>
            <returns>a non-negative number on success, a negative AVERROR code on failure. On failure, the packet is unchanged and the data remains owned by the caller.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_alloc">
            <summary>Allocate an AVPacket and set its fields to default values. The resulting struct must be freed using av_packet_free().</summary>
            <returns>An AVPacket filled with default values or NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_clone(FFmpeg.AutoGen.AVPacket*)">
            <summary>Create a new packet that references the same data as src.</summary>
            <returns>newly created AVPacket on success, NULL on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_copy_props(FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Copy only &quot;properties&quot; fields from src to dst.</summary>
            <param name="dst">Destination packet</param>
            <param name="src">Source packet</param>
            <returns>0 on success AVERROR on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_free(FFmpeg.AutoGen.AVPacket**)">
            <summary>Free the packet, if the packet is reference counted, it will be unreferenced first.</summary>
            <param name="pkt">packet to be freed. The pointer will be set to NULL.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_free_side_data(FFmpeg.AutoGen.AVPacket*)">
            <summary>Convenience function to free all the side data stored. All the other fields stay untouched.</summary>
            <param name="pkt">packet</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_from_data(FFmpeg.AutoGen.AVPacket*,System.Byte*,System.Int32)">
            <summary>Initialize a reference-counted packet from av_malloc()ed data.</summary>
            <param name="pkt">packet to be initialized. This function will set the data, size, and buf fields, all others are left untouched.</param>
            <param name="data">Data allocated by av_malloc() to be used as packet data. If this function returns successfully, the data is owned by the underlying AVBuffer. The caller may not access the data through other means.</param>
            <param name="size">size of data in bytes, without the padding. I.e. the full buffer size is assumed to be size + AV_INPUT_BUFFER_PADDING_SIZE.</param>
            <returns>0 on success, a negative AVERROR on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_get_side_data(FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVPacketSideDataType,System.Int32*)">
            <summary>Get side information from packet.</summary>
            <param name="pkt">packet</param>
            <param name="type">desired side information type</param>
            <param name="size">pointer for side information size to store (optional)</param>
            <returns>pointer to data if present or NULL otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_make_refcounted(FFmpeg.AutoGen.AVPacket*)">
            <summary>Ensure the data described by a given packet is reference counted.</summary>
            <param name="pkt">packet whose data should be made reference counted.</param>
            <returns>0 on success, a negative AVERROR on error. On failure, the packet is unchanged.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_make_writable(FFmpeg.AutoGen.AVPacket*)">
            <summary>Create a writable reference for the data described by a given packet, avoiding data copy if possible.</summary>
            <param name="pkt">Packet whose data should be made writable.</param>
            <returns>0 on success, a negative AVERROR on failure. On failure, the packet is unchanged.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_move_ref(FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Move every field in src to dst and reset src.</summary>
            <param name="dst">Destination packet</param>
            <param name="src">Source packet, will be reset</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_new_side_data(FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVPacketSideDataType,System.Int32)">
            <summary>Allocate new information of a packet.</summary>
            <param name="pkt">packet</param>
            <param name="type">side information type</param>
            <param name="size">side information size</param>
            <returns>pointer to fresh allocated data or NULL otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_pack_dictionary(FFmpeg.AutoGen.AVDictionary*,System.Int32*)">
            <summary>Pack a dictionary for use in side_data.</summary>
            <param name="dict">The dictionary to pack.</param>
            <param name="size">pointer to store the size of the returned data</param>
            <returns>pointer to data if successful, NULL otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_ref(FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Setup a new reference to the data described by a given packet</summary>
            <param name="dst">Destination packet. Will be completely overwritten.</param>
            <param name="src">Source packet</param>
            <returns>0 on success, a negative AVERROR on error. On error, dst will be blank (as if returned by av_packet_alloc()).</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_rescale_ts(FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational)">
            <summary>Convert valid timing fields (timestamps / durations) in a packet from one timebase to another. Timestamps with unknown values (AV_NOPTS_VALUE) will be ignored.</summary>
            <param name="pkt">packet on which the conversion will be performed</param>
            <param name="tb_src">source timebase, in which the timing fields in pkt are expressed</param>
            <param name="tb_dst">destination timebase, to which the timing fields will be converted</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_shrink_side_data(FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVPacketSideDataType,System.Int32)">
            <summary>Shrink the already allocated side data buffer</summary>
            <param name="pkt">packet</param>
            <param name="type">side information type</param>
            <param name="size">new side information size</param>
            <returns>0 on success, &lt; 0 on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_unpack_dictionary(System.Byte*,System.Int32,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Unpack a dictionary from side_data.</summary>
            <param name="data">data from side_data</param>
            <param name="size">size of the data</param>
            <param name="dict">the metadata storage dictionary</param>
            <returns>0 on success, &lt; 0 on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_packet_unref(FFmpeg.AutoGen.AVPacket*)">
            <summary>Wipe the packet.</summary>
            <param name="pkt">The packet to be unreferenced.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_parser_change(FFmpeg.AutoGen.AVCodecParserContext*,FFmpeg.AutoGen.AVCodecContext*,System.Byte**,System.Int32*,System.Byte*,System.Int32,System.Int32)">
            <summary>Returns 0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed use AVBitStreamFilter</summary>
            <returns>0 if the output buffer is a subset of the input, 1 if it is allocated and must be freed</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_parser_iterate(System.Void**)">
            <summary>Iterate over all registered codec parsers.</summary>
            <param name="opaque">a pointer where libavcodec will store the iteration state. Must point to NULL to start the iteration.</param>
            <returns>the next registered codec parser or NULL when the iteration is finished</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_parser_parse2(FFmpeg.AutoGen.AVCodecParserContext*,FFmpeg.AutoGen.AVCodecContext*,System.Byte**,System.Int32*,System.Byte*,System.Int32,System.Int64,System.Int64,System.Int64)">
            <summary>Parse a packet.</summary>
            <param name="s">parser context.</param>
            <param name="avctx">codec context.</param>
            <param name="poutbuf">set to pointer to parsed buffer or NULL if not yet finished.</param>
            <param name="poutbuf_size">set to size of parsed buffer or zero if not yet finished.</param>
            <param name="buf">input buffer.</param>
            <param name="buf_size">buffer size in bytes without the padding. I.e. the full buffer size is assumed to be buf_size + AV_INPUT_BUFFER_PADDING_SIZE. To signal EOF, this should be 0 (so that the last frame can be output).</param>
            <param name="pts">input presentation timestamp.</param>
            <param name="dts">input decoding timestamp.</param>
            <param name="pos">input byte position in stream.</param>
            <returns>the number of bytes of the input bitstream used.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_register_hwaccel(FFmpeg.AutoGen.AVHWAccel*)">
            <summary>Register the hardware accelerator hwaccel.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_shrink_packet(FFmpeg.AutoGen.AVPacket*,System.Int32)">
            <summary>Reduce packet size, correctly zeroing padding</summary>
            <param name="pkt">packet</param>
            <param name="size">new size</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_xiphlacing(System.Byte*,System.UInt32)">
            <summary>Encode extradata length to a buffer. Used by xiph codecs.</summary>
            <param name="s">buffer to write to; must be at least (v/255+1) bytes long</param>
            <param name="v">size of extradata in bytes</param>
            <returns>number of bytes written to the buffer.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_align_dimensions(FFmpeg.AutoGen.AVCodecContext*,System.Int32*,System.Int32*)">
            <summary>Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you do not use any horizontal padding.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_align_dimensions2(FFmpeg.AutoGen.AVCodecContext*,System.Int32*,System.Int32*,FFmpeg.AutoGen.int_array8@)">
            <summary>Modify width and height values so that they will result in a memory buffer that is acceptable for the codec if you also ensure that all line sizes are a multiple of the respective linesize_align[i].</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_alloc_context3(FFmpeg.AutoGen.AVCodec*)">
            <summary>Allocate an AVCodecContext and set its fields to default values. The resulting struct should be freed with avcodec_free_context().</summary>
            <param name="codec">if non-NULL, allocate private data and initialize defaults for the given codec. It is illegal to then call avcodec_open2() with a different codec. If NULL, then the codec-specific defaults won&apos;t be initialized, which may result in suboptimal default settings (this is important mainly for encoders, e.g. libx264).</param>
            <returns>An AVCodecContext filled with default values or NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_chroma_pos_to_enum(System.Int32,System.Int32)">
            <summary>Converts swscale x/y chroma position to AVChromaLocation.</summary>
            <param name="xpos">horizontal chroma sample position</param>
            <param name="ypos">vertical   chroma sample position</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_close(FFmpeg.AutoGen.AVCodecContext*)">
            <summary>Close a given AVCodecContext and free all the data associated with it (but not the AVCodecContext itself).</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_configuration">
            <summary>Return the libavcodec build-time configuration.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_copy_context(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVCodecContext*)">
            <summary>Copy the settings of the source AVCodecContext into the destination AVCodecContext. The resulting destination codec context will be unopened, i.e. you are required to call avcodec_open2() before you can use this AVCodecContext to decode/encode video/audio data.</summary>
            <param name="dest">target codec context, should be initialized with avcodec_alloc_context3(NULL), but otherwise uninitialized</param>
            <param name="src">source codec context</param>
            <returns>AVERROR() on error (e.g. memory allocation error), 0 on success</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_decode_audio4(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVFrame*,System.Int32*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Decode the audio frame of size avpkt-&gt;size from avpkt-&gt;data into frame.</summary>
            <param name="avctx">the codec context</param>
            <param name="frame">The AVFrame in which to store decoded audio samples. The decoder will allocate a buffer for the decoded frame by calling the AVCodecContext.get_buffer2() callback. When AVCodecContext.refcounted_frames is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using av_frame_unref() when the frame is no longer needed. The caller may safely write to the frame if av_frame_is_writable() returns 1. When AVCodecContext.refcounted_frames is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing or flushing the decoder. The caller may not write to it.</param>
            <param name="got_frame_ptr">Zero if no frame could be decoded, otherwise it is non-zero. Note that this field being set to zero does not mean that an error has occurred. For decoders with AV_CODEC_CAP_DELAY set, no given decode call is guaranteed to produce a frame.</param>
            <param name="avpkt">The input AVPacket containing the input buffer. At least avpkt-&gt;data and avpkt-&gt;size should be set. Some decoders might also require additional fields to be set.</param>
            <returns>A negative error code is returned if an error occurred during decoding, otherwise the number of bytes consumed from the input AVPacket is returned.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_decode_subtitle2(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVSubtitle*,System.Int32*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Decode a subtitle message. Return a negative value on error, otherwise return the number of bytes used. If no subtitle could be decompressed, got_sub_ptr is zero. Otherwise, the subtitle is stored in *sub. Note that AV_CODEC_CAP_DR1 is not available for subtitle codecs. This is for simplicity, because the performance difference is expected to be negligible and reusing a get_buffer written for video codecs would probably perform badly due to a potentially very different allocation pattern.</summary>
            <param name="avctx">the codec context</param>
            <param name="sub">The preallocated AVSubtitle in which the decoded subtitle will be stored, must be freed with avsubtitle_free if *got_sub_ptr is set.</param>
            <param name="got_sub_ptr">Zero if no subtitle could be decompressed, otherwise, it is nonzero.</param>
            <param name="avpkt">The input AVPacket containing the input buffer.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_decode_video2(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVFrame*,System.Int32*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Decode the video frame of size avpkt-&gt;size from avpkt-&gt;data into picture. Some decoders may support multiple frames in a single AVPacket, such decoders would then just decode the first frame.</summary>
            <param name="avctx">the codec context</param>
            <param name="picture">The AVFrame in which the decoded video frame will be stored. Use av_frame_alloc() to get an AVFrame. The codec will allocate memory for the actual bitmap by calling the AVCodecContext.get_buffer2() callback. When AVCodecContext.refcounted_frames is set to 1, the frame is reference counted and the returned reference belongs to the caller. The caller must release the frame using av_frame_unref() when the frame is no longer needed. The caller may safely write to the frame if av_frame_is_writable() returns 1. When AVCodecContext.refcounted_frames is set to 0, the returned reference belongs to the decoder and is valid only until the next call to this function or until closing or flushing the decoder. The caller may not write to it.</param>
            <param name="got_picture_ptr">Zero if no frame could be decompressed, otherwise, it is nonzero.</param>
            <param name="avpkt">The input AVPacket containing the input buffer. You can create such packet with av_init_packet() and by then setting data and size, some decoders might in addition need other fields like flags &amp;AV _PKT_FLAG_KEY. All decoders are designed to use the least fields possible.</param>
            <returns>On error a negative value is returned, otherwise the number of bytes used or zero if no frame could be decompressed.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_default_get_buffer2(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVFrame*,System.Int32)">
            <summary>The default callback for AVCodecContext.get_buffer2(). It is made public so it can be called by custom get_buffer2() implementations for decoders without AV_CODEC_CAP_DR1 set.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_descriptor_get(FFmpeg.AutoGen.AVCodecID)">
            <summary>Returns descriptor for given codec ID or NULL if no descriptor exists.</summary>
            <returns>descriptor for given codec ID or NULL if no descriptor exists.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_descriptor_get_by_name(System.String)">
            <summary>Returns codec descriptor with the given name or NULL if no such descriptor exists.</summary>
            <returns>codec descriptor with the given name or NULL if no such descriptor exists.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_descriptor_next(FFmpeg.AutoGen.AVCodecDescriptor*)">
            <summary>Iterate over all codec descriptors known to libavcodec.</summary>
            <param name="prev">previous descriptor. NULL to get the first descriptor.</param>
            <returns>next descriptor or NULL after the last descriptor</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_encode_audio2(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVFrame*,System.Int32*)">
            <summary>Encode a frame of audio.</summary>
            <param name="avctx">codec context</param>
            <param name="avpkt">output AVPacket. The user can supply an output buffer by setting avpkt-&gt;data and avpkt-&gt;size prior to calling the function, but if the size of the user-provided data is not large enough, encoding will fail. If avpkt-&gt;data and avpkt-&gt;size are set, avpkt-&gt;destruct must also be set. All other AVPacket fields will be reset by the encoder using av_init_packet(). If avpkt-&gt;data is NULL, the encoder will allocate it. The encoder will set avpkt-&gt;size to the size of the output packet.</param>
            <param name="frame">AVFrame containing the raw audio data to be encoded. May be NULL when flushing an encoder that has the AV_CODEC_CAP_DELAY capability set. If AV_CODEC_CAP_VARIABLE_FRAME_SIZE is set, then each frame can have any number of samples. If it is not set, frame-&gt;nb_samples must be equal to avctx-&gt;frame_size for all frames except the last. The final frame may be smaller than avctx-&gt;frame_size.</param>
            <param name="got_packet_ptr">This field is set to 1 by libavcodec if the output packet is non-empty, and to 0 if it is empty. If the function returns an error, the packet can be assumed to be invalid, and the value of got_packet_ptr is undefined and should not be used.</param>
            <returns>0 on success, negative error code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_encode_video2(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVFrame*,System.Int32*)">
            <summary>Encode a frame of video.</summary>
            <param name="avctx">codec context</param>
            <param name="avpkt">output AVPacket. The user can supply an output buffer by setting avpkt-&gt;data and avpkt-&gt;size prior to calling the function, but if the size of the user-provided data is not large enough, encoding will fail. All other AVPacket fields will be reset by the encoder using av_init_packet(). If avpkt-&gt;data is NULL, the encoder will allocate it. The encoder will set avpkt-&gt;size to the size of the output packet. The returned data (if any) belongs to the caller, he is responsible for freeing it.</param>
            <param name="frame">AVFrame containing the raw video data to be encoded. May be NULL when flushing an encoder that has the AV_CODEC_CAP_DELAY capability set.</param>
            <param name="got_packet_ptr">This field is set to 1 by libavcodec if the output packet is non-empty, and to 0 if it is empty. If the function returns an error, the packet can be assumed to be invalid, and the value of got_packet_ptr is undefined and should not be used.</param>
            <returns>0 on success, negative error code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_enum_to_chroma_pos(System.Int32*,System.Int32*,FFmpeg.AutoGen.AVChromaLocation)">
            <summary>Converts AVChromaLocation to swscale x/y chroma position.</summary>
            <param name="xpos">horizontal chroma sample position</param>
            <param name="ypos">vertical   chroma sample position</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_fill_audio_frame(FFmpeg.AutoGen.AVFrame*,System.Int32,FFmpeg.AutoGen.AVSampleFormat,System.Byte*,System.Int32,System.Int32)">
            <summary>Fill AVFrame audio data and linesize pointers.</summary>
            <param name="frame">the AVFrame frame-&gt;nb_samples must be set prior to calling the function. This function fills in frame-&gt;data, frame-&gt;extended_data, frame-&gt;linesize[0].</param>
            <param name="nb_channels">channel count</param>
            <param name="sample_fmt">sample format</param>
            <param name="buf">buffer to use for frame data</param>
            <param name="buf_size">size of buffer</param>
            <param name="align">plane size sample alignment (0 = default)</param>
            <returns>&gt;=0 on success, negative error code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_find_best_pix_fmt_of_list(FFmpeg.AutoGen.AVPixelFormat*,FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Int32*)">
            <summary>Find the best pixel format to convert to given a certain source pixel format. When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. avcodec_find_best_pix_fmt_of_2() searches which of the given pixel formats should be used to suffer the least amount of loss. The pixel formats from which it chooses one, are determined by the pix_fmt_list parameter.</summary>
            <param name="pix_fmt_list">AV_PIX_FMT_NONE terminated array of pixel formats to choose from</param>
            <param name="src_pix_fmt">source pixel format</param>
            <param name="has_alpha">Whether the source pixel format alpha channel is used.</param>
            <param name="loss_ptr">Combination of flags informing you what kind of losses will occur.</param>
            <returns>The best pixel format to convert to or -1 if none was found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_find_decoder(FFmpeg.AutoGen.AVCodecID)">
            <summary>Find a registered decoder with a matching codec ID.</summary>
            <param name="id">AVCodecID of the requested decoder</param>
            <returns>A decoder if one was found, NULL otherwise.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_find_decoder_by_name(System.String)">
            <summary>Find a registered decoder with the specified name.</summary>
            <param name="name">name of the requested decoder</param>
            <returns>A decoder if one was found, NULL otherwise.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_find_encoder(FFmpeg.AutoGen.AVCodecID)">
            <summary>Find a registered encoder with a matching codec ID.</summary>
            <param name="id">AVCodecID of the requested encoder</param>
            <returns>An encoder if one was found, NULL otherwise.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_find_encoder_by_name(System.String)">
            <summary>Find a registered encoder with the specified name.</summary>
            <param name="name">name of the requested encoder</param>
            <returns>An encoder if one was found, NULL otherwise.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_flush_buffers(FFmpeg.AutoGen.AVCodecContext*)">
            <summary>Reset the internal codec state / flush internal buffers. Should be called e.g. when seeking or when switching to a different stream.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_free_context(FFmpeg.AutoGen.AVCodecContext**)">
            <summary>Free the codec context and everything associated with it and write NULL to the provided pointer.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_get_class">
            <summary>Get the AVClass for AVCodecContext. It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_get_frame_class">
            <summary>Get the AVClass for AVFrame. It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_get_hw_config(FFmpeg.AutoGen.AVCodec*,System.Int32)">
            <summary>Retrieve supported hardware configurations for a codec.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_get_hw_frames_parameters(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVBufferRef*,FFmpeg.AutoGen.AVPixelFormat,FFmpeg.AutoGen.AVBufferRef**)">
            <summary>Create and return a AVHWFramesContext with values adequate for hardware decoding. This is meant to get called from the get_format callback, and is a helper for preparing a AVHWFramesContext for AVCodecContext.hw_frames_ctx. This API is for decoding with certain hardware acceleration modes/APIs only.</summary>
            <param name="avctx">The context which is currently calling get_format, and which implicitly contains all state needed for filling the returned AVHWFramesContext properly.</param>
            <param name="device_ref">A reference to the AVHWDeviceContext describing the device which will be used by the hardware decoder.</param>
            <param name="hw_pix_fmt">The hwaccel format you are going to return from get_format.</param>
            <param name="out_frames_ref">On success, set to a reference to an _uninitialized_ AVHWFramesContext, created from the given device_ref. Fields will be set to values required for decoding. Not changed if an error is returned.</param>
            <returns>zero on success, a negative value on error. The following error codes have special semantics: AVERROR(ENOENT): the decoder does not support this functionality. Setup is always manual, or it is a decoder which does not support setting AVCodecContext.hw_frames_ctx at all, or it is a software format. AVERROR(EINVAL): it is known that hardware decoding is not supported for this configuration, or the device_ref is not supported for the hwaccel referenced by hw_pix_fmt.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_get_name(FFmpeg.AutoGen.AVCodecID)">
            <summary>Get the name of a codec.</summary>
            <returns>a static string identifying the codec; never NULL</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_get_subtitle_rect_class">
            <summary>Get the AVClass for AVSubtitleRect. It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_get_type(FFmpeg.AutoGen.AVCodecID)">
            <summary>Get the type of the given codec.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_is_open(FFmpeg.AutoGen.AVCodecContext*)">
            <summary>Returns a positive value if s is open (i.e. avcodec_open2() was called on it with no corresponding avcodec_close()), 0 otherwise.</summary>
            <returns>a positive value if s is open (i.e. avcodec_open2() was called on it with no corresponding avcodec_close()), 0 otherwise.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_license">
            <summary>Return the libavcodec license.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_open2(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVCodec*,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Initialize the AVCodecContext to use the given AVCodec. Prior to using this function the context has to be allocated with avcodec_alloc_context3().</summary>
            <param name="avctx">The context to initialize.</param>
            <param name="codec">The codec to open this context for. If a non-NULL codec has been previously passed to avcodec_alloc_context3() or for this context, then this parameter MUST be either NULL or equal to the previously passed codec.</param>
            <param name="options">A dictionary filled with AVCodecContext and codec-private options. On return this object will be filled with options that were not found.</param>
            <returns>zero on success, a negative value on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_parameters_alloc">
            <summary>Allocate a new AVCodecParameters and set its fields to default values (unknown/invalid/0). The returned struct must be freed with avcodec_parameters_free().</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_parameters_copy(FFmpeg.AutoGen.AVCodecParameters*,FFmpeg.AutoGen.AVCodecParameters*)">
            <summary>Copy the contents of src to dst. Any allocated fields in dst are freed and replaced with newly allocated duplicates of the corresponding fields in src.</summary>
            <returns>&gt;= 0 on success, a negative AVERROR code on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_parameters_free(FFmpeg.AutoGen.AVCodecParameters**)">
            <summary>Free an AVCodecParameters instance and everything associated with it and write NULL to the supplied pointer.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_parameters_from_context(FFmpeg.AutoGen.AVCodecParameters*,FFmpeg.AutoGen.AVCodecContext*)">
            <summary>Fill the parameters struct based on the values from the supplied codec context. Any allocated fields in par are freed and replaced with duplicates of the corresponding fields in codec.</summary>
            <returns>&gt;= 0 on success, a negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_parameters_to_context(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVCodecParameters*)">
            <summary>Fill the codec context based on the values from the supplied codec parameters. Any allocated fields in codec that have a corresponding field in par are freed and replaced with duplicates of the corresponding field in par. Fields in codec that do not have a counterpart in par are not touched.</summary>
            <returns>&gt;= 0 on success, a negative AVERROR code on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_pix_fmt_to_codec_tag(FFmpeg.AutoGen.AVPixelFormat)">
            <summary>Return a value representing the fourCC code associated to the pixel format pix_fmt, or 0 if no associated fourCC code can be found.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_profile_name(FFmpeg.AutoGen.AVCodecID,System.Int32)">
            <summary>Return a name for the specified profile, if available.</summary>
            <param name="codec_id">the ID of the codec to which the requested profile belongs</param>
            <param name="profile">the profile value for which a name is requested</param>
            <returns>A name for the profile if found, NULL otherwise.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_receive_frame(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Return decoded output data from a decoder.</summary>
            <param name="avctx">codec context</param>
            <param name="frame">This will be set to a reference-counted video or audio frame (depending on the decoder type) allocated by the decoder. Note that the function will always call av_frame_unref(frame) before doing anything else.</param>
            <returns>0:                 success, a frame was returned AVERROR(EAGAIN):   output is not available in this state - user must try to send new input AVERROR_EOF:       the decoder has been fully flushed, and there will be no more output frames AVERROR(EINVAL):   codec not opened, or it is an encoder AVERROR_INPUT_CHANGED:   current decoded frame has changed parameters with respect to first decoded frame. Applicable when flag AV_CODEC_FLAG_DROPCHANGED is set. other negative values: legitimate decoding errors</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_receive_packet(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Read encoded data from the encoder.</summary>
            <param name="avctx">codec context</param>
            <param name="avpkt">This will be set to a reference-counted packet allocated by the encoder. Note that the function will always call av_packet_unref(avpkt) before doing anything else.</param>
            <returns>0 on success, otherwise negative error code: AVERROR(EAGAIN):   output is not available in the current state - user must try to send input AVERROR_EOF:       the encoder has been fully flushed, and there will be no more output packets AVERROR(EINVAL):   codec not opened, or it is a decoder other errors: legitimate encoding errors</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_register(FFmpeg.AutoGen.AVCodec*)">
            <summary>Register the codec codec and initialize libavcodec.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_register_all">
            <summary>Register all the codecs, parsers and bitstream filters which were enabled at configuration time. If you do not call this function you can select exactly which formats you want to support, by using the individual registration functions.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_send_frame(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Supply a raw video or audio frame to the encoder. Use avcodec_receive_packet() to retrieve buffered output packets.</summary>
            <param name="avctx">codec context</param>
            <param name="frame">AVFrame containing the raw audio or video frame to be encoded. Ownership of the frame remains with the caller, and the encoder will not write to the frame. The encoder may create a reference to the frame data (or copy it if the frame is not reference-counted). It can be NULL, in which case it is considered a flush packet.  This signals the end of the stream. If the encoder still has packets buffered, it will return them after this call. Once flushing mode has been entered, additional flush packets are ignored, and sending frames will return AVERROR_EOF.</param>
            <returns>0 on success, otherwise negative error code: AVERROR(EAGAIN):   input is not accepted in the current state - user must read output with avcodec_receive_packet() (once all output is read, the packet should be resent, and the call will not fail with EAGAIN). AVERROR_EOF:       the encoder has been flushed, and no new frames can be sent to it AVERROR(EINVAL):   codec not opened, refcounted_frames not set, it is a decoder, or requires flush AVERROR(ENOMEM):   failed to add packet to internal queue, or similar other errors: legitimate encoding errors</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_send_packet(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Supply raw packet data as input to a decoder.</summary>
            <param name="avctx">codec context</param>
            <param name="avpkt">The input AVPacket. Usually, this will be a single video frame, or several complete audio frames. Ownership of the packet remains with the caller, and the decoder will not write to the packet. The decoder may create a reference to the packet data (or copy it if the packet is not reference-counted). Unlike with older APIs, the packet is always fully consumed, and if it contains multiple frames (e.g. some audio codecs), will require you to call avcodec_receive_frame() multiple times afterwards before you can send a new packet. It can be NULL (or an AVPacket with data set to NULL and size set to 0); in this case, it is considered a flush packet, which signals the end of the stream. Sending the first flush packet will return success. Subsequent ones are unnecessary and will return AVERROR_EOF. If the decoder still has frames buffered, it will return them after sending a flush packet.</param>
            <returns>0 on success, otherwise negative error code: AVERROR(EAGAIN):   input is not accepted in the current state - user must read output with avcodec_receive_frame() (once all output is read, the packet should be resent, and the call will not fail with EAGAIN). AVERROR_EOF:       the decoder has been flushed, and no new packets can be sent to it (also returned if more than 1 flush packet is sent) AVERROR(EINVAL):   codec not opened, it is an encoder, or requires flush AVERROR(ENOMEM):   failed to add packet to internal queue, or similar other errors: legitimate decoding errors</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avcodec_version">
            <summary>Return the LIBAVCODEC_VERSION_INT constant.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avsubtitle_free(FFmpeg.AutoGen.AVSubtitle*)">
            <summary>Free all allocated data in the given subtitle struct.</summary>
            <param name="sub">AVSubtitle to free.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_input_audio_device_next(FFmpeg.AutoGen.AVInputFormat*)">
            <summary>Audio input devices iterator.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_input_video_device_next(FFmpeg.AutoGen.AVInputFormat*)">
            <summary>Video input devices iterator.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_output_audio_device_next(FFmpeg.AutoGen.AVOutputFormat*)">
            <summary>Audio output devices iterator.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_output_video_device_next(FFmpeg.AutoGen.AVOutputFormat*)">
            <summary>Video output devices iterator.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_app_to_dev_control_message(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVAppToDevMessageType,System.Void*,System.UInt64)">
            <summary>Send control message from application to device.</summary>
            <param name="s">device context.</param>
            <param name="type">message type.</param>
            <param name="data">message data. Exact type depends on message type.</param>
            <param name="data_size">size of message data.</param>
            <returns>&gt;= 0 on success, negative on error. AVERROR(ENOSYS) when device doesn&apos;t implement handler of the message.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_capabilities_create(FFmpeg.AutoGen.AVDeviceCapabilitiesQuery**,FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Initialize capabilities probing API based on AVOption API.</summary>
            <param name="caps">Device capabilities data. Pointer to a NULL pointer must be passed.</param>
            <param name="s">Context of the device.</param>
            <param name="device_options">An AVDictionary filled with device-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL. The same options must be passed later to avformat_write_header() for output devices or avformat_open_input() for input devices, or at any other place that affects device-private options.</param>
            <returns>&gt;= 0 on success, negative otherwise.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_capabilities_free(FFmpeg.AutoGen.AVDeviceCapabilitiesQuery**,FFmpeg.AutoGen.AVFormatContext*)">
            <summary>Free resources created by avdevice_capabilities_create()</summary>
            <param name="caps">Device capabilities data to be freed.</param>
            <param name="s">Context of the device.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_configuration">
            <summary>Return the libavdevice build-time configuration.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_dev_to_app_control_message(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVDevToAppMessageType,System.Void*,System.UInt64)">
            <summary>Send control message from device to application.</summary>
            <param name="s">device context.</param>
            <param name="type">message type.</param>
            <param name="data">message data. Can be NULL.</param>
            <param name="data_size">size of message data.</param>
            <returns>&gt;= 0 on success, negative on error. AVERROR(ENOSYS) when application doesn&apos;t implement handler of the message.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_free_list_devices(FFmpeg.AutoGen.AVDeviceInfoList**)">
            <summary>Convenient function to free result of avdevice_list_devices().</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_license">
            <summary>Return the libavdevice license.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_list_devices(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVDeviceInfoList**)">
            <summary>List devices.</summary>
            <param name="s">device context.</param>
            <param name="device_list">list of autodetected devices.</param>
            <returns>count of autodetected devices, negative on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_list_input_sources(FFmpeg.AutoGen.AVInputFormat*,System.String,FFmpeg.AutoGen.AVDictionary*,FFmpeg.AutoGen.AVDeviceInfoList**)">
            <summary>List devices.</summary>
            <param name="device">device format. May be NULL if device name is set.</param>
            <param name="device_name">device name. May be NULL if device format is set.</param>
            <param name="device_options">An AVDictionary filled with device-private options. May be NULL. The same options must be passed later to avformat_write_header() for output devices or avformat_open_input() for input devices, or at any other place that affects device-private options.</param>
            <param name="device_list">list of autodetected devices</param>
            <returns>count of autodetected devices, negative on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_register_all">
            <summary>Initialize libavdevice and register all the input and output devices.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avdevice_version">
            <summary>Return the LIBAVDEVICE_VERSION_INT constant.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_abuffersink_params_alloc">
            <summary>Create an AVABufferSinkParams structure.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersink_get_frame(FFmpeg.AutoGen.AVFilterContext*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Get a frame with filtered data from sink and put it in frame.</summary>
            <param name="ctx">pointer to a context of a buffersink or abuffersink AVFilter.</param>
            <param name="frame">pointer to an allocated frame that will be filled with data. The data must be freed using av_frame_unref() / av_frame_free()</param>
            <returns>- &gt;= 0 if a frame was successfully returned. - AVERROR(EAGAIN) if no frames are available at this point; more input frames must be added to the filtergraph to get more output. - AVERROR_EOF if there will be no more output frames on this sink. - A different negative AVERROR code in other failure cases.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersink_get_frame_flags(FFmpeg.AutoGen.AVFilterContext*,FFmpeg.AutoGen.AVFrame*,System.Int32)">
            <summary>Get a frame with filtered data from sink and put it in frame.</summary>
            <param name="ctx">pointer to a buffersink or abuffersink filter context.</param>
            <param name="frame">pointer to an allocated frame that will be filled with data. The data must be freed using av_frame_unref() / av_frame_free()</param>
            <param name="flags">a combination of AV_BUFFERSINK_FLAG_* flags</param>
            <returns>&gt;= 0 in for success, a negative AVERROR code for failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersink_get_samples(FFmpeg.AutoGen.AVFilterContext*,FFmpeg.AutoGen.AVFrame*,System.Int32)">
            <summary>Same as av_buffersink_get_frame(), but with the ability to specify the number of samples read. This function is less efficient than av_buffersink_get_frame(), because it copies the data around.</summary>
            <param name="ctx">pointer to a context of the abuffersink AVFilter.</param>
            <param name="frame">pointer to an allocated frame that will be filled with data. The data must be freed using av_frame_unref() / av_frame_free() frame will contain exactly nb_samples audio samples, except at the end of stream, when it can contain less than nb_samples.</param>
            <returns>The return codes have the same meaning as for av_buffersink_get_frame().</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersink_get_type(FFmpeg.AutoGen.AVFilterContext*)">
            <summary>Get the properties of the stream @{</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersink_params_alloc">
            <summary>Create an AVBufferSinkParams structure.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersink_set_frame_size(FFmpeg.AutoGen.AVFilterContext*,System.UInt32)">
            <summary>Set the frame size for an audio buffer sink.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersrc_add_frame(FFmpeg.AutoGen.AVFilterContext*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Add a frame to the buffer source.</summary>
            <param name="ctx">an instance of the buffersrc filter</param>
            <param name="frame">frame to be added. If the frame is reference counted, this function will take ownership of the reference(s) and reset the frame. Otherwise the frame data will be copied. If this function returns an error, the input frame is not touched.</param>
            <returns>0 on success, a negative AVERROR on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersrc_add_frame_flags(FFmpeg.AutoGen.AVFilterContext*,FFmpeg.AutoGen.AVFrame*,System.Int32)">
            <summary>Add a frame to the buffer source.</summary>
            <param name="buffer_src">pointer to a buffer source context</param>
            <param name="frame">a frame, or NULL to mark EOF</param>
            <param name="flags">a combination of AV_BUFFERSRC_FLAG_*</param>
            <returns>&gt;= 0 in case of success, a negative AVERROR code in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersrc_close(FFmpeg.AutoGen.AVFilterContext*,System.Int64,System.UInt32)">
            <summary>Close the buffer source after EOF.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersrc_get_nb_failed_requests(FFmpeg.AutoGen.AVFilterContext*)">
            <summary>Get the number of failed requests.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersrc_parameters_alloc">
            <summary>Allocate a new AVBufferSrcParameters instance. It should be freed by the caller with av_free().</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersrc_parameters_set(FFmpeg.AutoGen.AVFilterContext*,FFmpeg.AutoGen.AVBufferSrcParameters*)">
            <summary>Initialize the buffersrc or abuffersrc filter with the provided parameters. This function may be called multiple times, the later calls override the previous ones. Some of the parameters may also be set through AVOptions, then whatever method is used last takes precedence.</summary>
            <param name="ctx">an instance of the buffersrc or abuffersrc filter</param>
            <param name="param">the stream parameters. The frames later passed to this filter must conform to those parameters. All the allocated fields in param remain owned by the caller, libavfilter will make internal copies or references when necessary.</param>
            <returns>0 on success, a negative AVERROR code on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffersrc_write_frame(FFmpeg.AutoGen.AVFilterContext*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Add a frame to the buffer source.</summary>
            <param name="ctx">an instance of the buffersrc filter</param>
            <param name="frame">frame to be added. If the frame is reference counted, this function will make a new reference to it. Otherwise the frame data will be copied.</param>
            <returns>0 on success, a negative AVERROR on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_filter_iterate(System.Void**)">
            <summary>Iterate over all registered filters.</summary>
            <param name="opaque">a pointer where libavfilter will store the iteration state. Must point to NULL to start the iteration.</param>
            <returns>the next registered filter or NULL when the iteration is finished</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_config_links(FFmpeg.AutoGen.AVFilterContext*)">
            <summary>Negotiate the media format, dimensions, etc of all inputs to a filter.</summary>
            <param name="filter">the filter to negotiate the properties for its inputs</param>
            <returns>zero on successful negotiation</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_configuration">
            <summary>Return the libavfilter build-time configuration.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_free(FFmpeg.AutoGen.AVFilterContext*)">
            <summary>Free a filter context. This will also remove the filter from its filtergraph&apos;s list of filters.</summary>
            <param name="filter">the filter to free</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_get_by_name(System.String)">
            <summary>Get a filter definition matching the given name.</summary>
            <param name="name">the filter name to find</param>
            <returns>the filter definition, if any matching one is registered. NULL if none found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_get_class">
            <summary>Returns AVClass for AVFilterContext.</summary>
            <returns>AVClass for AVFilterContext.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_alloc">
            <summary>Allocate a filter graph.</summary>
            <returns>the allocated filter graph on success or NULL.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_alloc_filter(FFmpeg.AutoGen.AVFilterGraph*,FFmpeg.AutoGen.AVFilter*,System.String)">
            <summary>Create a new filter instance in a filter graph.</summary>
            <param name="graph">graph in which the new filter will be used</param>
            <param name="filter">the filter to create an instance of</param>
            <param name="name">Name to give to the new instance (will be copied to AVFilterContext.name). This may be used by the caller to identify different filters, libavfilter itself assigns no semantics to this parameter. May be NULL.</param>
            <returns>the context of the newly created filter instance (note that it is also retrievable directly through AVFilterGraph.filters or with avfilter_graph_get_filter()) on success or NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_config(FFmpeg.AutoGen.AVFilterGraph*,System.Void*)">
            <summary>Check validity and configure all the links and formats in the graph.</summary>
            <param name="graphctx">the filter graph</param>
            <param name="log_ctx">context used for logging</param>
            <returns>&gt;= 0 in case of success, a negative AVERROR code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_create_filter(FFmpeg.AutoGen.AVFilterContext**,FFmpeg.AutoGen.AVFilter*,System.String,System.String,System.Void*,FFmpeg.AutoGen.AVFilterGraph*)">
            <summary>Create and add a filter instance into an existing graph. The filter instance is created from the filter filt and inited with the parameter args. opaque is currently ignored.</summary>
            <param name="name">the instance name to give to the created filter instance</param>
            <param name="graph_ctx">the filter graph</param>
            <returns>a negative AVERROR error code in case of failure, a non negative value otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_dump(FFmpeg.AutoGen.AVFilterGraph*,System.String)">
            <summary>Dump a graph into a human-readable string representation.</summary>
            <param name="graph">the graph to dump</param>
            <param name="options">formatting options; currently ignored</param>
            <returns>a string, or NULL in case of memory allocation failure; the string must be freed using av_free</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_free(FFmpeg.AutoGen.AVFilterGraph**)">
            <summary>Free a graph, destroy its links, and set *graph to NULL. If *graph is NULL, do nothing.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_get_filter(FFmpeg.AutoGen.AVFilterGraph*,System.String)">
            <summary>Get a filter instance identified by instance name from graph.</summary>
            <param name="graph">filter graph to search through.</param>
            <param name="name">filter instance name (should be unique in the graph).</param>
            <returns>the pointer to the found filter instance or NULL if it cannot be found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_parse(FFmpeg.AutoGen.AVFilterGraph*,System.String,FFmpeg.AutoGen.AVFilterInOut*,FFmpeg.AutoGen.AVFilterInOut*,System.Void*)">
            <summary>Add a graph described by a string to a graph.</summary>
            <param name="graph">the filter graph where to link the parsed graph context</param>
            <param name="filters">string to be parsed</param>
            <param name="inputs">linked list to the inputs of the graph</param>
            <param name="outputs">linked list to the outputs of the graph</param>
            <returns>zero on success, a negative AVERROR code on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_parse_ptr(FFmpeg.AutoGen.AVFilterGraph*,System.String,FFmpeg.AutoGen.AVFilterInOut**,FFmpeg.AutoGen.AVFilterInOut**,System.Void*)">
            <summary>Add a graph described by a string to a graph.</summary>
            <param name="graph">the filter graph where to link the parsed graph context</param>
            <param name="filters">string to be parsed</param>
            <param name="inputs">pointer to a linked list to the inputs of the graph, may be NULL. If non-NULL, *inputs is updated to contain the list of open inputs after the parsing, should be freed with avfilter_inout_free().</param>
            <param name="outputs">pointer to a linked list to the outputs of the graph, may be NULL. If non-NULL, *outputs is updated to contain the list of open outputs after the parsing, should be freed with avfilter_inout_free().</param>
            <returns>non negative on success, a negative AVERROR code on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_parse2(FFmpeg.AutoGen.AVFilterGraph*,System.String,FFmpeg.AutoGen.AVFilterInOut**,FFmpeg.AutoGen.AVFilterInOut**)">
            <summary>Add a graph described by a string to a graph.</summary>
            <param name="graph">the filter graph where to link the parsed graph context</param>
            <param name="filters">string to be parsed</param>
            <param name="inputs">a linked list of all free (unlinked) inputs of the parsed graph will be returned here. It is to be freed by the caller using avfilter_inout_free().</param>
            <param name="outputs">a linked list of all free (unlinked) outputs of the parsed graph will be returned here. It is to be freed by the caller using avfilter_inout_free().</param>
            <returns>zero on success, a negative AVERROR code on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_queue_command(FFmpeg.AutoGen.AVFilterGraph*,System.String,System.String,System.String,System.Int32,System.Double)">
            <summary>Queue a command for one or more filter instances.</summary>
            <param name="graph">the filter graph</param>
            <param name="target">the filter(s) to which the command should be sent &quot;all&quot; sends to all filters otherwise it can be a filter or filter instance name which will send the command to all matching filters.</param>
            <param name="cmd">the command to sent, for handling simplicity all commands must be alphanumeric only</param>
            <param name="arg">the argument for the command</param>
            <param name="ts">time at which the command should be sent to the filter</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_request_oldest(FFmpeg.AutoGen.AVFilterGraph*)">
            <summary>Request a frame on the oldest sink link.</summary>
            <returns>the return value of ff_request_frame(), or AVERROR_EOF if all links returned AVERROR_EOF</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_send_command(FFmpeg.AutoGen.AVFilterGraph*,System.String,System.String,System.String,System.Byte*,System.Int32,System.Int32)">
            <summary>Send a command to one or more filter instances.</summary>
            <param name="graph">the filter graph</param>
            <param name="target">the filter(s) to which the command should be sent &quot;all&quot; sends to all filters otherwise it can be a filter or filter instance name which will send the command to all matching filters.</param>
            <param name="cmd">the command to send, for handling simplicity all commands must be alphanumeric only</param>
            <param name="arg">the argument for the command</param>
            <param name="res">a buffer with size res_size where the filter(s) can return a response.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_graph_set_auto_convert(FFmpeg.AutoGen.AVFilterGraph*,System.UInt32)">
            <summary>Enable or disable automatic format conversion inside the graph.</summary>
            <param name="flags">any of the AVFILTER_AUTO_CONVERT_* constants</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_init_dict(FFmpeg.AutoGen.AVFilterContext*,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Initialize a filter with the supplied dictionary of options.</summary>
            <param name="ctx">uninitialized filter context to initialize</param>
            <param name="options">An AVDictionary filled with options for this filter. On return this parameter will be destroyed and replaced with a dict containing options that were not found. This dictionary must be freed by the caller. May be NULL, then this function is equivalent to avfilter_init_str() with the second parameter set to NULL.</param>
            <returns>0 on success, a negative AVERROR on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_init_str(FFmpeg.AutoGen.AVFilterContext*,System.String)">
            <summary>Initialize a filter with the supplied parameters.</summary>
            <param name="ctx">uninitialized filter context to initialize</param>
            <param name="args">Options to initialize the filter with. This must be a &apos;:&apos;-separated list of options in the &apos;key=value&apos; form. May be NULL if the options have been set directly using the AVOptions API or there are no options that need to be set.</param>
            <returns>0 on success, a negative AVERROR on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_inout_alloc">
            <summary>Allocate a single AVFilterInOut entry. Must be freed with avfilter_inout_free().</summary>
            <returns>allocated AVFilterInOut on success, NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_inout_free(FFmpeg.AutoGen.AVFilterInOut**)">
            <summary>Free the supplied list of AVFilterInOut and set *inout to NULL. If *inout is NULL, do nothing.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_insert_filter(FFmpeg.AutoGen.AVFilterLink*,FFmpeg.AutoGen.AVFilterContext*,System.UInt32,System.UInt32)">
            <summary>Insert a filter in the middle of an existing link.</summary>
            <param name="link">the link into which the filter should be inserted</param>
            <param name="filt">the filter to be inserted</param>
            <param name="filt_srcpad_idx">the input pad on the filter to connect</param>
            <param name="filt_dstpad_idx">the output pad on the filter to connect</param>
            <returns>zero on success</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_license">
            <summary>Return the libavfilter license.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_link(FFmpeg.AutoGen.AVFilterContext*,System.UInt32,FFmpeg.AutoGen.AVFilterContext*,System.UInt32)">
            <summary>Link two filters together.</summary>
            <param name="src">the source filter</param>
            <param name="srcpad">index of the output pad on the source filter</param>
            <param name="dst">the destination filter</param>
            <param name="dstpad">index of the input pad on the destination filter</param>
            <returns>zero on success</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_link_free(FFmpeg.AutoGen.AVFilterLink**)">
            <summary>Free the link in *link, and set its pointer to NULL.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_link_get_channels(FFmpeg.AutoGen.AVFilterLink*)">
            <summary>Get the number of channels of a link.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_link_set_closed(FFmpeg.AutoGen.AVFilterLink*,System.Int32)">
            <summary>Set the closed field of a link.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_next(FFmpeg.AutoGen.AVFilter*)">
            <summary>Iterate over all registered filters.</summary>
            <returns>If prev is non-NULL, next registered filter after prev or NULL if prev is the last filter. If prev is NULL, return the first registered filter.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_pad_count(FFmpeg.AutoGen.AVFilterPad*)">
            <summary>Get the number of elements in a NULL-terminated array of AVFilterPads (e.g. AVFilter.inputs/outputs).</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_pad_get_name(FFmpeg.AutoGen.AVFilterPad*,System.Int32)">
            <summary>Get the name of an AVFilterPad.</summary>
            <param name="pads">an array of AVFilterPads</param>
            <param name="pad_idx">index of the pad in the array; it is the caller&apos;s responsibility to ensure the index is valid</param>
            <returns>name of the pad_idx&apos;th pad in pads</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_pad_get_type(FFmpeg.AutoGen.AVFilterPad*,System.Int32)">
            <summary>Get the type of an AVFilterPad.</summary>
            <param name="pads">an array of AVFilterPads</param>
            <param name="pad_idx">index of the pad in the array; it is the caller&apos;s responsibility to ensure the index is valid</param>
            <returns>type of the pad_idx&apos;th pad in pads</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_process_command(FFmpeg.AutoGen.AVFilterContext*,System.String,System.String,System.Byte*,System.Int32,System.Int32)">
            <summary>Make the filter instance process a command. It is recommended to use avfilter_graph_send_command().</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_register(FFmpeg.AutoGen.AVFilter*)">
            <summary>Register a filter. This is only needed if you plan to use avfilter_get_by_name later to lookup the AVFilter structure by name. A filter can still by instantiated with avfilter_graph_alloc_filter even if it is not registered.</summary>
            <param name="filter">the filter to register</param>
            <returns>0 if the registration was successful, a negative value otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_register_all">
            <summary>Initialize the filter system. Register all builtin filters.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avfilter_version">
            <summary>Return the LIBAVFILTER_VERSION_INT constant.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_add_index_entry(FFmpeg.AutoGen.AVStream*,System.Int64,System.Int64,System.Int32,System.Int32,System.Int32)">
            <summary>Add an index entry into a sorted list. Update the entry if the list already contains it.</summary>
            <param name="timestamp">timestamp in the time base of the given stream</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_append_packet(FFmpeg.AutoGen.AVIOContext*,FFmpeg.AutoGen.AVPacket*,System.Int32)">
            <summary>Read data and append it to the current content of the AVPacket. If pkt-&gt;size is 0 this is identical to av_get_packet. Note that this uses av_grow_packet and thus involves a realloc which is inefficient. Thus this function should only be used when there is no reasonable way to know (an upper bound of) the final size.</summary>
            <param name="s">associated IO context</param>
            <param name="pkt">packet</param>
            <param name="size">amount of data to read</param>
            <returns>&gt;0 (read size) if OK, AVERROR_xxx otherwise, previous data will not be lost even if an error occurs.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_apply_bitstream_filters(FFmpeg.AutoGen.AVCodecContext*,FFmpeg.AutoGen.AVPacket*,FFmpeg.AutoGen.AVBitStreamFilterContext*)">
            <summary>Apply a list of bitstream filters to a packet.</summary>
            <param name="codec">AVCodecContext, usually from an AVStream</param>
            <param name="pkt">the packet to apply filters to. If, on success, the returned packet has size == 0 and side_data_elems == 0, it indicates that the packet should be dropped</param>
            <param name="bsfc">a NULL-terminated list of filters to apply</param>
            <returns>&gt;=0 on success; AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_codec_get_id(FFmpeg.AutoGen.AVCodecTag**,System.UInt32)">
            <summary>Get the AVCodecID for the given codec tag tag. If no codec id is found returns AV_CODEC_ID_NONE.</summary>
            <param name="tags">list of supported codec_id-codec_tag pairs, as stored in AVInputFormat.codec_tag and AVOutputFormat.codec_tag</param>
            <param name="tag">codec tag to match to a codec ID</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_codec_get_tag(FFmpeg.AutoGen.AVCodecTag**,FFmpeg.AutoGen.AVCodecID)">
            <summary>Get the codec tag for the given codec id id. If no codec tag is found returns 0.</summary>
            <param name="tags">list of supported codec_id-codec_tag pairs, as stored in AVInputFormat.codec_tag and AVOutputFormat.codec_tag</param>
            <param name="id">codec ID to match to a codec tag</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_codec_get_tag2(FFmpeg.AutoGen.AVCodecTag**,FFmpeg.AutoGen.AVCodecID,System.UInt32*)">
            <summary>Get the codec tag for the given codec id.</summary>
            <param name="tags">list of supported codec_id - codec_tag pairs, as stored in AVInputFormat.codec_tag and AVOutputFormat.codec_tag</param>
            <param name="id">codec id that should be searched for in the list</param>
            <param name="tag">A pointer to the found tag</param>
            <returns>0 if id was not found in tags, &gt; 0 if it was found</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_demuxer_iterate(System.Void**)">
            <summary>Iterate over all registered demuxers.</summary>
            <param name="opaque">a pointer where libavformat will store the iteration state. Must point to NULL to start the iteration.</param>
            <returns>the next registered demuxer or NULL when the iteration is finished</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dump_format(FFmpeg.AutoGen.AVFormatContext*,System.Int32,System.String,System.Int32)">
            <summary>Print detailed information about the input or output format, such as duration, bitrate, streams, container, programs, metadata, side data, codec and time base.</summary>
            <param name="ic">the context to analyze</param>
            <param name="index">index of the stream to dump information about</param>
            <param name="url">the URL to print, such as source or destination file</param>
            <param name="is_output">Select whether the specified context is an input(0) or output(1)</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_filename_number_test(System.String)">
            <summary>Check whether filename actually is a numbered sequence generator.</summary>
            <param name="filename">possible numbered sequence string</param>
            <returns>1 if a valid numbered sequence string, 0 otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_find_best_stream(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVMediaType,System.Int32,System.Int32,FFmpeg.AutoGen.AVCodec**,System.Int32)">
            <summary>Find the &quot;best&quot; stream in the file. The best stream is determined according to various heuristics as the most likely to be what the user expects. If the decoder parameter is non-NULL, av_find_best_stream will find the default decoder for the stream&apos;s codec; streams for which no decoder can be found are ignored.</summary>
            <param name="ic">media file handle</param>
            <param name="type">stream type: video, audio, subtitles, etc.</param>
            <param name="wanted_stream_nb">user-requested stream number, or -1 for automatic selection</param>
            <param name="related_stream">try to find a stream related (eg. in the same program) to this one, or -1 if none</param>
            <param name="decoder_ret">if non-NULL, returns the decoder for the selected stream</param>
            <param name="flags">flags; none are currently defined</param>
            <returns>the non-negative stream number in case of success, AVERROR_STREAM_NOT_FOUND if no stream with the requested type could be found, AVERROR_DECODER_NOT_FOUND if streams were found but no decoder</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_find_input_format(System.String)">
            <summary>Find AVInputFormat based on the short name of the input format.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_find_program_from_stream(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVProgram*,System.Int32)">
            <summary>Find the programs which belong to a given stream.</summary>
            <param name="ic">media file handle</param>
            <param name="last">the last found program, the search will start after this program, or from the beginning if it is NULL</param>
            <param name="s">stream index</param>
            <returns>the next program which belongs to s, NULL if no program is found or the last program is not among the programs of ic.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fmt_ctx_get_duration_estimation_method(FFmpeg.AutoGen.AVFormatContext*)">
            <summary>Returns the method used to set ctx-&gt;duration.</summary>
            <returns>AVFMT_DURATION_FROM_PTS, AVFMT_DURATION_FROM_STREAM, or AVFMT_DURATION_FROM_BITRATE.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_format_get_probe_score(FFmpeg.AutoGen.AVFormatContext*)">
            <summary>Accessors for some AVFormatContext fields. These used to be provided for ABI compatibility, and do not need to be used anymore.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_format_inject_global_side_data(FFmpeg.AutoGen.AVFormatContext*)">
            <summary>This function will cause global side data to be injected in the next packet of each stream as well as after any subsequent seek.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_frame_filename2(System.Byte*,System.Int32,System.String,System.Int32,System.Int32)">
            <summary>Return in &apos;buf&apos; the path with &apos;%d&apos; replaced by a number.</summary>
            <param name="buf">destination buffer</param>
            <param name="buf_size">destination buffer size</param>
            <param name="path">numbered sequence string</param>
            <param name="number">frame number</param>
            <param name="flags">AV_FRAME_FILENAME_FLAGS_*</param>
            <returns>0 if OK, -1 on format error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_output_timestamp(FFmpeg.AutoGen.AVFormatContext*,System.Int32,System.Int64*,System.Int64*)">
            <summary>Get timing information for the data currently output. The exact meaning of &quot;currently output&quot; depends on the format. It is mostly relevant for devices that have an internal buffer and/or work in real time.</summary>
            <param name="s">media file handle</param>
            <param name="stream">stream in the media file</param>
            <param name="dts">DTS of the last packet output for the stream, in stream time_base units</param>
            <param name="wall">absolute time when that packet whas output, in microsecond</param>
            <returns>0 if OK, AVERROR(ENOSYS) if the format does not support it Note: some formats or devices may not allow to measure dts and wall atomically.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_packet(FFmpeg.AutoGen.AVIOContext*,FFmpeg.AutoGen.AVPacket*,System.Int32)">
            <summary>Allocate and read the payload of a packet and initialize its fields with default values.</summary>
            <param name="s">associated IO context</param>
            <param name="pkt">packet</param>
            <param name="size">desired payload size</param>
            <returns>&gt;0 (read size) if OK, AVERROR_xxx otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_guess_codec(FFmpeg.AutoGen.AVOutputFormat*,System.String,System.String,System.String,FFmpeg.AutoGen.AVMediaType)">
            <summary>Guess the codec ID based upon muxer and filename.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_guess_format(System.String,System.String,System.String)">
            <summary>Return the output format in the list of registered output formats which best matches the provided parameters, or return NULL if there is no match.</summary>
            <param name="short_name">if non-NULL checks if short_name matches with the names of the registered formats</param>
            <param name="filename">if non-NULL checks if filename terminates with the extensions of the registered formats</param>
            <param name="mime_type">if non-NULL checks if mime_type matches with the MIME type of the registered formats</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_guess_frame_rate(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVStream*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Guess the frame rate, based on both the container and codec information.</summary>
            <param name="ctx">the format context which the stream is part of</param>
            <param name="stream">the stream which the frame is part of</param>
            <param name="frame">the frame for which the frame rate should be determined, may be NULL</param>
            <returns>the guessed (valid) frame rate, 0/1 if no idea</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_guess_sample_aspect_ratio(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVStream*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Guess the sample aspect ratio of a frame, based on both the stream and the frame aspect ratio.</summary>
            <param name="format">the format context which the stream is part of</param>
            <param name="stream">the stream which the frame is part of</param>
            <param name="frame">the frame with the aspect ratio to be determined</param>
            <returns>the guessed (valid) sample_aspect_ratio, 0/1 if no idea</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hex_dump(FFmpeg.AutoGen._iobuf*,System.Byte*,System.Int32)">
            <summary>Send a nice hexadecimal dump of a buffer to the specified file stream.</summary>
            <param name="f">The file stream pointer where the dump should be sent to.</param>
            <param name="buf">buffer</param>
            <param name="size">buffer size</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hex_dump_log(System.Void*,System.Int32,System.Byte*,System.Int32)">
            <summary>Send a nice hexadecimal dump of a buffer to the log.</summary>
            <param name="avcl">A pointer to an arbitrary struct of which the first field is a pointer to an AVClass struct.</param>
            <param name="level">The importance level of the message, lower values signifying higher importance.</param>
            <param name="buf">buffer</param>
            <param name="size">buffer size</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_iformat_next(FFmpeg.AutoGen.AVInputFormat*)">
            <summary>If f is NULL, returns the first registered input format, if f is non-NULL, returns the next registered input format after f or NULL if f is the last one.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_index_search_timestamp(FFmpeg.AutoGen.AVStream*,System.Int64,System.Int32)">
            <summary>Get the index for a specific timestamp.</summary>
            <param name="st">stream that the timestamp belongs to</param>
            <param name="timestamp">timestamp to retrieve the index for</param>
            <param name="flags">if AVSEEK_FLAG_BACKWARD then the returned index will correspond to the timestamp which is &lt; = the requested one, if backward is 0, then it will be &gt;= if AVSEEK_FLAG_ANY seek to any frame, only keyframes otherwise</param>
            <returns>&lt; 0 if no such timestamp could be found</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_interleaved_write_frame(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Write a packet to an output media file ensuring correct interleaving.</summary>
            <param name="s">media file handle</param>
            <param name="pkt">The packet containing the data to be written.  If the packet is reference-counted, this function will take ownership of this reference and unreference it later when it sees fit. The caller must not access the data through this reference after this function returns. If the packet is not reference-counted, libavformat will make a copy.  This parameter can be NULL (at any time, not just at the end), to flush the interleaving queues.  Packet&apos;s</param>
            <returns>0 on success, a negative AVERROR on error. Libavformat will always take care of freeing the packet, even if this function fails.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_interleaved_write_uncoded_frame(FFmpeg.AutoGen.AVFormatContext*,System.Int32,FFmpeg.AutoGen.AVFrame*)">
            <summary>Write an uncoded frame to an output media file.</summary>
            <returns>&gt;=0 for success, a negative code on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_match_ext(System.String,System.String)">
            <summary>Return a positive value if the given filename has one of the given extensions, 0 otherwise.</summary>
            <param name="filename">file name to check against the given extensions</param>
            <param name="extensions">a comma-separated list of filename extensions</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_muxer_iterate(System.Void**)">
            <summary>Iterate over all registered muxers.</summary>
            <param name="opaque">a pointer where libavformat will store the iteration state. Must point to NULL to start the iteration.</param>
            <returns>the next registered muxer or NULL when the iteration is finished</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_oformat_next(FFmpeg.AutoGen.AVOutputFormat*)">
            <summary>If f is NULL, returns the first registered output format, if f is non-NULL, returns the next registered output format after f or NULL if f is the last one.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_pkt_dump_log2(System.Void*,System.Int32,FFmpeg.AutoGen.AVPacket*,System.Int32,FFmpeg.AutoGen.AVStream*)">
            <summary>Send a nice dump of a packet to the log.</summary>
            <param name="avcl">A pointer to an arbitrary struct of which the first field is a pointer to an AVClass struct.</param>
            <param name="level">The importance level of the message, lower values signifying higher importance.</param>
            <param name="pkt">packet to dump</param>
            <param name="dump_payload">True if the payload must be displayed, too.</param>
            <param name="st">AVStream that the packet belongs to</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_pkt_dump2(FFmpeg.AutoGen._iobuf*,FFmpeg.AutoGen.AVPacket*,System.Int32,FFmpeg.AutoGen.AVStream*)">
            <summary>Send a nice dump of a packet to the specified file stream.</summary>
            <param name="f">The file stream pointer where the dump should be sent to.</param>
            <param name="pkt">packet to dump</param>
            <param name="dump_payload">True if the payload must be displayed, too.</param>
            <param name="st">AVStream that the packet belongs to</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_probe_input_buffer(FFmpeg.AutoGen.AVIOContext*,FFmpeg.AutoGen.AVInputFormat**,System.String,System.Void*,System.UInt32,System.UInt32)">
            <summary>Like av_probe_input_buffer2() but returns 0 on success</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_probe_input_buffer2(FFmpeg.AutoGen.AVIOContext*,FFmpeg.AutoGen.AVInputFormat**,System.String,System.Void*,System.UInt32,System.UInt32)">
            <summary>Probe a bytestream to determine the input format. Each time a probe returns with a score that is too low, the probe buffer size is increased and another attempt is made. When the maximum probe size is reached, the input format with the highest score is returned.</summary>
            <param name="pb">the bytestream to probe</param>
            <param name="fmt">the input format is put here</param>
            <param name="url">the url of the stream</param>
            <param name="logctx">the log context</param>
            <param name="offset">the offset within the bytestream to probe from</param>
            <param name="max_probe_size">the maximum probe buffer size (zero for default)</param>
            <returns>the score in case of success, a negative value corresponding to an the maximal score is AVPROBE_SCORE_MAX AVERROR code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_probe_input_format(FFmpeg.AutoGen.AVProbeData*,System.Int32)">
            <summary>Guess the file format.</summary>
            <param name="pd">data to be probed</param>
            <param name="is_opened">Whether the file is already opened; determines whether demuxers with or without AVFMT_NOFILE are probed.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_probe_input_format2(FFmpeg.AutoGen.AVProbeData*,System.Int32,System.Int32*)">
            <summary>Guess the file format.</summary>
            <param name="pd">data to be probed</param>
            <param name="is_opened">Whether the file is already opened; determines whether demuxers with or without AVFMT_NOFILE are probed.</param>
            <param name="score_max">A probe score larger that this is required to accept a detection, the variable is set to the actual detection score afterwards. If the score is &lt; = AVPROBE_SCORE_MAX / 4 it is recommended to retry with a larger probe buffer.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_probe_input_format3(FFmpeg.AutoGen.AVProbeData*,System.Int32,System.Int32*)">
            <summary>Guess the file format.</summary>
            <param name="is_opened">Whether the file is already opened; determines whether demuxers with or without AVFMT_NOFILE are probed.</param>
            <param name="score_ret">The score of the best detection.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_read_frame(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Return the next frame of a stream. This function returns what is stored in the file, and does not validate that what is there are valid frames for the decoder. It will split what is stored in the file into frames and return one for each call. It will not omit invalid data between valid frames so as to give the decoder the maximum information possible for decoding.</summary>
            <returns>0 if OK, &lt; 0 on error or end of file. On error, pkt will be blank (as if it came from av_packet_alloc()).</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_read_pause(FFmpeg.AutoGen.AVFormatContext*)">
            <summary>Pause a network-based stream (e.g. RTSP stream).</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_read_play(FFmpeg.AutoGen.AVFormatContext*)">
            <summary>Start playing a network-based stream (e.g. RTSP stream) at the current position.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_register_all">
            <summary>Initialize libavformat and register all the muxers, demuxers and protocols. If you do not call this function, then you can select exactly which formats you want to support.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_sdp_create(FFmpeg.AutoGen.AVFormatContext**,System.Int32,System.Byte*,System.Int32)">
            <summary>Generate an SDP for an RTP session.</summary>
            <param name="ac">array of AVFormatContexts describing the RTP streams. If the array is composed by only one context, such context can contain multiple AVStreams (one AVStream per RTP stream). Otherwise, all the contexts in the array (an AVCodecContext per RTP stream) must contain only one AVStream.</param>
            <param name="n_files">number of AVCodecContexts contained in ac</param>
            <param name="buf">buffer where the SDP will be stored (must be allocated by the caller)</param>
            <param name="size">the size of the buffer</param>
            <returns>0 if OK, AVERROR_xxx on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_seek_frame(FFmpeg.AutoGen.AVFormatContext*,System.Int32,System.Int64,System.Int32)">
            <summary>Seek to the keyframe at timestamp. &apos;timestamp&apos; in &apos;stream_index&apos;.</summary>
            <param name="s">media file handle</param>
            <param name="stream_index">If stream_index is (-1), a default stream is selected, and timestamp is automatically converted from AV_TIME_BASE units to the stream specific time_base.</param>
            <param name="timestamp">Timestamp in AVStream.time_base units or, if no stream is specified, in AV_TIME_BASE units.</param>
            <param name="flags">flags which select direction and seeking mode</param>
            <returns>&gt;= 0 on success</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_stream_add_side_data(FFmpeg.AutoGen.AVStream*,FFmpeg.AutoGen.AVPacketSideDataType,System.Byte*,System.UInt64)">
            <summary>Wrap an existing array as stream side data.</summary>
            <param name="st">stream</param>
            <param name="type">side information type</param>
            <param name="data">the side data array. It must be allocated with the av_malloc() family of functions. The ownership of the data is transferred to st.</param>
            <param name="size">side information size</param>
            <returns>zero on success, a negative AVERROR code on failure. On failure, the stream is unchanged and the data remains owned by the caller.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_stream_get_codec_timebase(FFmpeg.AutoGen.AVStream*)">
            <summary>Get the internal codec timebase from a stream.</summary>
            <param name="st">input stream to extract the timebase from</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_stream_get_end_pts(FFmpeg.AutoGen.AVStream*)">
            <summary>Returns the pts of the last muxed packet + its duration</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_stream_get_r_frame_rate(FFmpeg.AutoGen.AVStream*)">
            <summary>Accessors for some AVStream fields. These used to be provided for ABI compatibility, and do not need to be used anymore.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_stream_get_side_data(FFmpeg.AutoGen.AVStream*,FFmpeg.AutoGen.AVPacketSideDataType,System.Int32*)">
            <summary>Get side information from stream.</summary>
            <param name="stream">stream</param>
            <param name="type">desired side information type</param>
            <param name="size">pointer for side information size to store (optional)</param>
            <returns>pointer to data if present or NULL otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_stream_new_side_data(FFmpeg.AutoGen.AVStream*,FFmpeg.AutoGen.AVPacketSideDataType,System.Int32)">
            <summary>Allocate new information from stream.</summary>
            <param name="stream">stream</param>
            <param name="type">desired side information type</param>
            <param name="size">side information size</param>
            <returns>pointer to fresh allocated data or NULL otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_url_split(System.Byte*,System.Int32,System.Byte*,System.Int32,System.Byte*,System.Int32,System.Int32*,System.Byte*,System.Int32,System.String)">
            <summary>Split a URL string into components.</summary>
            <param name="proto">the buffer for the protocol</param>
            <param name="proto_size">the size of the proto buffer</param>
            <param name="authorization">the buffer for the authorization</param>
            <param name="authorization_size">the size of the authorization buffer</param>
            <param name="hostname">the buffer for the host name</param>
            <param name="hostname_size">the size of the hostname buffer</param>
            <param name="port_ptr">a pointer to store the port number in</param>
            <param name="path">the buffer for the path</param>
            <param name="path_size">the size of the path buffer</param>
            <param name="url">the URL to split</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_write_frame(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVPacket*)">
            <summary>Write a packet to an output media file.</summary>
            <param name="s">media file handle</param>
            <param name="pkt">The packet containing the data to be written. Note that unlike av_interleaved_write_frame(), this function does not take ownership of the packet passed to it (though some muxers may make an internal reference to the input packet).  This parameter can be NULL (at any time, not just at the end), in order to immediately flush data buffered within the muxer, for muxers that buffer up data internally before writing it to the output.  Packet&apos;s</param>
            <returns>&lt; 0 on error, = 0 if OK, 1 if flushed and there is no more data to flush</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_write_trailer(FFmpeg.AutoGen.AVFormatContext*)">
            <summary>Write the stream trailer to an output media file and free the file private data.</summary>
            <param name="s">media file handle</param>
            <returns>0 if OK, AVERROR_xxx on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_write_uncoded_frame(FFmpeg.AutoGen.AVFormatContext*,System.Int32,FFmpeg.AutoGen.AVFrame*)">
            <summary>Write an uncoded frame to an output media file.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_write_uncoded_frame_query(FFmpeg.AutoGen.AVFormatContext*,System.Int32)">
            <summary>Test whether a muxer supports uncoded frame.</summary>
            <returns>&gt;=0 if an uncoded frame can be written to that muxer and stream,  &lt; 0 if not</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_alloc_context">
            <summary>Allocate an AVFormatContext. avformat_free_context() can be used to free the context and everything allocated by the framework within it.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_alloc_output_context2(FFmpeg.AutoGen.AVFormatContext**,FFmpeg.AutoGen.AVOutputFormat*,System.String,System.String)">
            <summary>Allocate an AVFormatContext for an output format. avformat_free_context() can be used to free the context and everything allocated by the framework within it.</summary>
            <param name="oformat">format to use for allocating the context, if NULL format_name and filename are used instead</param>
            <param name="format_name">the name of output format to use for allocating the context, if NULL filename is used instead</param>
            <param name="filename">the name of the filename to use for allocating the context, may be NULL</param>
            <returns>&gt;= 0 in case of success, a negative AVERROR code in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_close_input(FFmpeg.AutoGen.AVFormatContext**)">
            <summary>Close an opened input AVFormatContext. Free it and all its contents and set *s to NULL.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_configuration">
            <summary>Return the libavformat build-time configuration.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_find_stream_info(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Read packets of a media file to get stream information. This is useful for file formats with no headers such as MPEG. This function also computes the real framerate in case of MPEG-2 repeat frame mode. The logical file position is not changed by this function; examined packets may be buffered for later processing.</summary>
            <param name="ic">media file handle</param>
            <param name="options">If non-NULL, an ic.nb_streams long array of pointers to dictionaries, where i-th member contains options for codec corresponding to i-th stream. On return each dictionary will be filled with options that were not found.</param>
            <returns>&gt;=0 if OK, AVERROR_xxx on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_flush(FFmpeg.AutoGen.AVFormatContext*)">
            <summary>Discard all internally buffered data. This can be useful when dealing with discontinuities in the byte stream. Generally works only with formats that can resync. This includes headerless formats like MPEG-TS/TS but should also work with NUT, Ogg and in a limited way AVI for example.</summary>
            <param name="s">media file handle</param>
            <returns>&gt;=0 on success, error code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_free_context(FFmpeg.AutoGen.AVFormatContext*)">
            <summary>Free an AVFormatContext and all its streams.</summary>
            <param name="s">context to free</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_get_class">
            <summary>Get the AVClass for AVFormatContext. It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_get_mov_audio_tags">
            <summary>Returns the table mapping MOV FourCCs for audio to AVCodecID.</summary>
            <returns>the table mapping MOV FourCCs for audio to AVCodecID.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_get_mov_video_tags">
            <summary>Returns the table mapping MOV FourCCs for video to libavcodec AVCodecID.</summary>
            <returns>the table mapping MOV FourCCs for video to libavcodec AVCodecID.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_get_riff_audio_tags">
            <summary>Returns the table mapping RIFF FourCCs for audio to AVCodecID.</summary>
            <returns>the table mapping RIFF FourCCs for audio to AVCodecID.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_get_riff_video_tags">
            <summary>@{ Get the tables mapping RIFF FourCCs to libavcodec AVCodecIDs. The tables are meant to be passed to av_codec_get_id()/av_codec_get_tag() as in the following code:</summary>
            <returns>the table mapping RIFF FourCCs for video to libavcodec AVCodecID.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_init_output(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Allocate the stream private data and initialize the codec, but do not write the header. May optionally be used before avformat_write_header to initialize stream parameters before actually writing the header. If using this function, do not pass the same options to avformat_write_header.</summary>
            <param name="s">Media file handle, must be allocated with avformat_alloc_context(). Its oformat field must be set to the desired output format; Its pb field must be set to an already opened AVIOContext.</param>
            <param name="options">An AVDictionary filled with AVFormatContext and muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.</param>
            <returns>AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec requires avformat_write_header to fully initialize, AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec has been fully initialized, negative AVERROR on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_license">
            <summary>Return the libavformat license.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_match_stream_specifier(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVStream*,System.String)">
            <summary>Check if the stream st contained in s is matched by the stream specifier spec.</summary>
            <returns>&gt;0 if st is matched by spec; 0  if st is not matched by spec; AVERROR code if spec is invalid</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_network_deinit">
            <summary>Undo the initialization done by avformat_network_init. Call it only once for each time you called avformat_network_init.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_network_init">
            <summary>Do global initialization of network libraries. This is optional, and not recommended anymore.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_new_stream(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVCodec*)">
            <summary>Add a new stream to a media file.</summary>
            <param name="s">media file handle</param>
            <param name="c">If non-NULL, the AVCodecContext corresponding to the new stream will be initialized to use this codec. This is needed for e.g. codec-specific defaults to be set, so codec should be provided if it is known.</param>
            <returns>newly created stream or NULL on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_open_input(FFmpeg.AutoGen.AVFormatContext**,System.String,FFmpeg.AutoGen.AVInputFormat*,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Open an input stream and read the header. The codecs are not opened. The stream must be closed with avformat_close_input().</summary>
            <param name="ps">Pointer to user-supplied AVFormatContext (allocated by avformat_alloc_context). May be a pointer to NULL, in which case an AVFormatContext is allocated by this function and written into ps. Note that a user-supplied AVFormatContext will be freed on failure.</param>
            <param name="url">URL of the stream to open.</param>
            <param name="fmt">If non-NULL, this parameter forces a specific input format. Otherwise the format is autodetected.</param>
            <param name="options">A dictionary filled with AVFormatContext and demuxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.</param>
            <returns>0 on success, a negative AVERROR on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_query_codec(FFmpeg.AutoGen.AVOutputFormat*,FFmpeg.AutoGen.AVCodecID,System.Int32)">
            <summary>Test if the given container can store a codec.</summary>
            <param name="ofmt">container to check for compatibility</param>
            <param name="codec_id">codec to potentially store in container</param>
            <param name="std_compliance">standards compliance level, one of FF_COMPLIANCE_*</param>
            <returns>1 if codec with ID codec_id can be stored in ofmt, 0 if it cannot. A negative number if this information is not available.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_seek_file(FFmpeg.AutoGen.AVFormatContext*,System.Int32,System.Int64,System.Int64,System.Int64,System.Int32)">
            <summary>Seek to timestamp ts. Seeking will be done so that the point from which all active streams can be presented successfully will be closest to ts and within min/max_ts. Active streams are all streams that have AVStream.discard &lt; AVDISCARD_ALL.</summary>
            <param name="s">media file handle</param>
            <param name="stream_index">index of the stream which is used as time base reference</param>
            <param name="min_ts">smallest acceptable timestamp</param>
            <param name="ts">target timestamp</param>
            <param name="max_ts">largest acceptable timestamp</param>
            <param name="flags">flags</param>
            <returns>&gt;=0 on success, error code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_transfer_internal_stream_timing_info(FFmpeg.AutoGen.AVOutputFormat*,FFmpeg.AutoGen.AVStream*,FFmpeg.AutoGen.AVStream*,FFmpeg.AutoGen.AVTimebaseSource)">
            <summary>Transfer internal timing information from one stream to another.</summary>
            <param name="ofmt">target output format for ost</param>
            <param name="ost">output stream which needs timings copy and adjustments</param>
            <param name="ist">reference input stream to copy timings from</param>
            <param name="copy_tb">define from where the stream codec timebase needs to be imported</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_version">
            <summary>Return the LIBAVFORMAT_VERSION_INT constant.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avformat_write_header(FFmpeg.AutoGen.AVFormatContext*,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Allocate the stream private data and write the stream header to an output media file.</summary>
            <param name="s">Media file handle, must be allocated with avformat_alloc_context(). Its oformat field must be set to the desired output format; Its pb field must be set to an already opened AVIOContext.</param>
            <param name="options">An AVDictionary filled with AVFormatContext and muxer-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.</param>
            <returns>AVSTREAM_INIT_IN_WRITE_HEADER on success if the codec had not already been fully initialized in avformat_init, AVSTREAM_INIT_IN_INIT_OUTPUT  on success if the codec had already been fully initialized in avformat_init, negative AVERROR on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_accept(FFmpeg.AutoGen.AVIOContext*,FFmpeg.AutoGen.AVIOContext**)">
            <summary>Accept and allocate a client context on a server context.</summary>
            <param name="s">the server context</param>
            <param name="c">the client context, must be unallocated</param>
            <returns>&gt;= 0 on success or a negative value corresponding to an AVERROR on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_alloc_context(System.Byte*,System.Int32,System.Int32,System.Void*,FFmpeg.AutoGen.avio_alloc_context_read_packet_func,FFmpeg.AutoGen.avio_alloc_context_write_packet_func,FFmpeg.AutoGen.avio_alloc_context_seek_func)">
            <summary>Allocate and initialize an AVIOContext for buffered I/O. It must be later freed with avio_context_free().</summary>
            <param name="buffer">Memory block for input/output operations via AVIOContext. The buffer must be allocated with av_malloc() and friends. It may be freed and replaced with a new buffer by libavformat. AVIOContext.buffer holds the buffer currently in use, which must be later freed with av_free().</param>
            <param name="buffer_size">The buffer size is very important for performance. For protocols with fixed blocksize it should be set to this blocksize. For others a typical size is a cache page, e.g. 4kb.</param>
            <param name="write_flag">Set to 1 if the buffer should be writable, 0 otherwise.</param>
            <param name="opaque">An opaque pointer to user-specific data.</param>
            <param name="read_packet">A function for refilling the buffer, may be NULL. For stream protocols, must never return 0 but rather a proper AVERROR code.</param>
            <param name="write_packet">A function for writing the buffer contents, may be NULL. The function may not change the input buffers content.</param>
            <param name="seek">A function for seeking to specified byte position, may be NULL.</param>
            <returns>Allocated AVIOContext or NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_check(System.String,System.Int32)">
            <summary>Return AVIO_FLAG_* access flags corresponding to the access permissions of the resource in url, or a negative value corresponding to an AVERROR code in case of failure. The returned access flags are masked by the value in flags.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_close(FFmpeg.AutoGen.AVIOContext*)">
            <summary>Close the resource accessed by the AVIOContext s and free it. This function can only be used if s was opened by avio_open().</summary>
            <returns>0 on success, an AVERROR &lt; 0 on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_close_dir(FFmpeg.AutoGen.AVIODirContext**)">
            <summary>Close directory.</summary>
            <param name="s">directory read context.</param>
            <returns>&gt;=0 on success or negative on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_close_dyn_buf(FFmpeg.AutoGen.AVIOContext*,System.Byte**)">
            <summary>Return the written size and a pointer to the buffer. The buffer must be freed with av_free(). Padding of AV_INPUT_BUFFER_PADDING_SIZE is added to the buffer.</summary>
            <param name="s">IO context</param>
            <param name="pbuffer">pointer to a byte buffer</param>
            <returns>the length of the byte buffer</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_closep(FFmpeg.AutoGen.AVIOContext**)">
            <summary>Close the resource accessed by the AVIOContext *s, free it and set the pointer pointing to it to NULL. This function can only be used if s was opened by avio_open().</summary>
            <returns>0 on success, an AVERROR &lt; 0 on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_context_free(FFmpeg.AutoGen.AVIOContext**)">
            <summary>Free the supplied IO context and everything associated with it.</summary>
            <param name="s">Double pointer to the IO context. This function will write NULL into s.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_enum_protocols(System.Void**,System.Int32)">
            <summary>Iterate through names of available protocols.</summary>
            <param name="opaque">A private pointer representing current protocol. It must be a pointer to NULL on first iteration and will be updated by successive calls to avio_enum_protocols.</param>
            <param name="output">If set to 1, iterate over output protocols, otherwise over input protocols.</param>
            <returns>A static string containing the name of current protocol or NULL</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_feof(FFmpeg.AutoGen.AVIOContext*)">
            <summary>Similar to feof() but also returns nonzero on read errors.</summary>
            <returns>non zero if and only if at end of file or a read error happened when reading.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_find_protocol_name(System.String)">
            <summary>Return the name of the protocol that will handle the passed URL.</summary>
            <returns>Name of the protocol or NULL.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_flush(FFmpeg.AutoGen.AVIOContext*)">
            <summary>Force flushing of buffered data.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_free_directory_entry(FFmpeg.AutoGen.AVIODirEntry**)">
            <summary>Free entry allocated by avio_read_dir().</summary>
            <param name="entry">entry to be freed.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_get_dyn_buf(FFmpeg.AutoGen.AVIOContext*,System.Byte**)">
            <summary>Return the written size and a pointer to the buffer. The AVIOContext stream is left intact. The buffer must NOT be freed. No padding is added to the buffer.</summary>
            <param name="s">IO context</param>
            <param name="pbuffer">pointer to a byte buffer</param>
            <returns>the length of the byte buffer</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_get_str(FFmpeg.AutoGen.AVIOContext*,System.Int32,System.Byte*,System.Int32)">
            <summary>Read a string from pb into buf. The reading will terminate when either a NULL character was encountered, maxlen bytes have been read, or nothing more can be read from pb. The result is guaranteed to be NULL-terminated, it will be truncated if buf is too small. Note that the string is not interpreted or validated in any way, it might get truncated in the middle of a sequence for multi-byte encodings.</summary>
            <returns>number of bytes read (is always &lt; = maxlen). If reading ends on EOF or error, the return value will be one more than bytes actually read.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_get_str16le(FFmpeg.AutoGen.AVIOContext*,System.Int32,System.Byte*,System.Int32)">
            <summary>Read a UTF-16 string from pb and convert it to UTF-8. The reading will terminate when either a null or invalid character was encountered or maxlen bytes have been read.</summary>
            <returns>number of bytes read (is always &lt; = maxlen)</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_handshake(FFmpeg.AutoGen.AVIOContext*)">
            <summary>Perform one step of the protocol handshake to accept a new client. This function must be called on a client returned by avio_accept() before using it as a read/write context. It is separate from avio_accept() because it may block. A step of the handshake is defined by places where the application may decide to change the proceedings. For example, on a protocol with a request header and a reply header, each one can constitute a step because the application may use the parameters from the request to change parameters in the reply; or each individual chunk of the request can constitute a step. If the handshake is already finished, avio_handshake() does nothing and returns 0 immediately.</summary>
            <param name="c">the client context to perform the handshake on</param>
            <returns>0   on a complete and successful handshake &gt; 0 if the handshake progressed, but is not complete  &lt; 0 for an AVERROR code</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_open(FFmpeg.AutoGen.AVIOContext**,System.String,System.Int32)">
            <summary>Create and initialize a AVIOContext for accessing the resource indicated by url.</summary>
            <param name="s">Used to return the pointer to the created AVIOContext. In case of failure the pointed to value is set to NULL.</param>
            <param name="url">resource to access</param>
            <param name="flags">flags which control how the resource indicated by url is to be opened</param>
            <returns>&gt;= 0 in case of success, a negative value corresponding to an AVERROR code in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_open_dir(FFmpeg.AutoGen.AVIODirContext**,System.String,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Open directory for reading.</summary>
            <param name="s">directory read context. Pointer to a NULL pointer must be passed.</param>
            <param name="url">directory to be listed.</param>
            <param name="options">A dictionary filled with protocol-private options. On return this parameter will be destroyed and replaced with a dictionary containing options that were not found. May be NULL.</param>
            <returns>&gt;=0 on success or negative on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_open_dyn_buf(FFmpeg.AutoGen.AVIOContext**)">
            <summary>Open a write only memory stream.</summary>
            <param name="s">new IO context</param>
            <returns>zero if no error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_open2(FFmpeg.AutoGen.AVIOContext**,System.String,System.Int32,FFmpeg.AutoGen.AVIOInterruptCB*,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Create and initialize a AVIOContext for accessing the resource indicated by url.</summary>
            <param name="s">Used to return the pointer to the created AVIOContext. In case of failure the pointed to value is set to NULL.</param>
            <param name="url">resource to access</param>
            <param name="flags">flags which control how the resource indicated by url is to be opened</param>
            <param name="int_cb">an interrupt callback to be used at the protocols level</param>
            <param name="options">A dictionary filled with protocol-private options. On return this parameter will be destroyed and replaced with a dict containing options that were not found. May be NULL.</param>
            <returns>&gt;= 0 in case of success, a negative value corresponding to an AVERROR code in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_pause(FFmpeg.AutoGen.AVIOContext*,System.Int32)">
            <summary>Pause and resume playing - only meaningful if using a network streaming protocol (e.g. MMS).</summary>
            <param name="h">IO context from which to call the read_pause function pointer</param>
            <param name="pause">1 for pause, 0 for resume</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_print_string_array(FFmpeg.AutoGen.AVIOContext*,System.Byte*[])">
            <summary>Write a NULL terminated array of strings to the context. Usually you don&apos;t need to use this function directly but its macro wrapper, avio_print.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_printf(FFmpeg.AutoGen.AVIOContext*,System.String)">
            <summary>Writes a formatted string to the context.</summary>
            <returns>number of bytes written, &lt; 0 on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_protocol_get_class(System.String)">
            <summary>Get AVClass by names of available protocols.</summary>
            <returns>A AVClass of input protocol name or NULL</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_put_str(FFmpeg.AutoGen.AVIOContext*,System.String)">
            <summary>Write a NULL-terminated string.</summary>
            <returns>number of bytes written.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_put_str16be(FFmpeg.AutoGen.AVIOContext*,System.String)">
            <summary>Convert an UTF-8 string to UTF-16BE and write it.</summary>
            <param name="s">the AVIOContext</param>
            <param name="str">NULL-terminated UTF-8 string</param>
            <returns>number of bytes written.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_put_str16le(FFmpeg.AutoGen.AVIOContext*,System.String)">
            <summary>Convert an UTF-8 string to UTF-16LE and write it.</summary>
            <param name="s">the AVIOContext</param>
            <param name="str">NULL-terminated UTF-8 string</param>
            <returns>number of bytes written.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_r8(FFmpeg.AutoGen.AVIOContext*)">
            <summary>@{</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_read(FFmpeg.AutoGen.AVIOContext*,System.Byte*,System.Int32)">
            <summary>Read size bytes from AVIOContext into buf.</summary>
            <returns>number of bytes read or AVERROR</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_read_dir(FFmpeg.AutoGen.AVIODirContext*,FFmpeg.AutoGen.AVIODirEntry**)">
            <summary>Get next directory entry.</summary>
            <param name="s">directory read context.</param>
            <param name="next">next entry or NULL when no more entries.</param>
            <returns>&gt;=0 on success or negative on error. End of list is not considered an error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_read_partial(FFmpeg.AutoGen.AVIOContext*,System.Byte*,System.Int32)">
            <summary>Read size bytes from AVIOContext into buf. Unlike avio_read(), this is allowed to read fewer bytes than requested. The missing bytes can be read in the next call. This always tries to read at least 1 byte. Useful to reduce latency in certain cases.</summary>
            <returns>number of bytes read or AVERROR</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_read_to_bprint(FFmpeg.AutoGen.AVIOContext*,FFmpeg.AutoGen.AVBPrint*,System.UInt64)">
            <summary>Read contents of h into print buffer, up to max_size bytes, or up to EOF.</summary>
            <returns>0 for success (max_size bytes read or EOF reached), negative error code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_seek(FFmpeg.AutoGen.AVIOContext*,System.Int64,System.Int32)">
            <summary>fseek() equivalent for AVIOContext.</summary>
            <returns>new position or AVERROR.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_seek_time(FFmpeg.AutoGen.AVIOContext*,System.Int32,System.Int64,System.Int32)">
            <summary>Seek to a given timestamp relative to some component stream. Only meaningful if using a network streaming protocol (e.g. MMS.).</summary>
            <param name="h">IO context from which to call the seek function pointers</param>
            <param name="stream_index">The stream index that the timestamp is relative to. If stream_index is (-1) the timestamp should be in AV_TIME_BASE units from the beginning of the presentation. If a stream_index &gt;= 0 is used and the protocol does not support seeking based on component streams, the call will fail.</param>
            <param name="timestamp">timestamp in AVStream.time_base units or if there is no stream specified then in AV_TIME_BASE units.</param>
            <param name="flags">Optional combination of AVSEEK_FLAG_BACKWARD, AVSEEK_FLAG_BYTE and AVSEEK_FLAG_ANY. The protocol may silently ignore AVSEEK_FLAG_BACKWARD and AVSEEK_FLAG_ANY, but AVSEEK_FLAG_BYTE will fail if used and not supported.</param>
            <returns>&gt;= 0 on success</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_size(FFmpeg.AutoGen.AVIOContext*)">
            <summary>Get the filesize.</summary>
            <returns>filesize or AVERROR</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_skip(FFmpeg.AutoGen.AVIOContext*,System.Int64)">
            <summary>Skip given number of bytes forward</summary>
            <returns>new position or AVERROR.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_write_marker(FFmpeg.AutoGen.AVIOContext*,System.Int64,FFmpeg.AutoGen.AVIODataMarkerType)">
            <summary>Mark the written bytestream as a specific type.</summary>
            <param name="time">the stream time the current bytestream pos corresponds to (in AV_TIME_BASE units), or AV_NOPTS_VALUE if unknown or not applicable</param>
            <param name="type">the kind of data written starting at the current pos</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avpriv_io_delete(System.String)">
            <summary>Delete a resource.</summary>
            <param name="url">resource to be deleted.</param>
            <returns>&gt;=0 on success or negative on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avpriv_io_move(System.String,System.String)">
            <summary>Move or rename a resource.</summary>
            <param name="url_src">url to resource to be moved</param>
            <param name="url_dst">new url to resource if the operation succeeded</param>
            <returns>&gt;=0 on success or negative on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_add_q(FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational)">
            <summary>Add two rationals.</summary>
            <param name="b">First rational</param>
            <param name="c">Second rational</param>
            <returns>b+c</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_add_stable(FFmpeg.AutoGen.AVRational,System.Int64,FFmpeg.AutoGen.AVRational,System.Int64)">
            <summary>Add a value to a timestamp.</summary>
            <param name="ts_tb">Input timestamp time base</param>
            <param name="ts">Input timestamp</param>
            <param name="inc_tb">Time base of `inc`</param>
            <param name="inc">Value to be added</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_alloc(FFmpeg.AutoGen.AVSampleFormat,System.Int32,System.Int32)">
            <summary>Allocate an AVAudioFifo.</summary>
            <param name="sample_fmt">sample format</param>
            <param name="channels">number of channels</param>
            <param name="nb_samples">initial allocation size, in samples</param>
            <returns>newly allocated AVAudioFifo, or NULL on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_drain(FFmpeg.AutoGen.AVAudioFifo*,System.Int32)">
            <summary>Drain data from an AVAudioFifo.</summary>
            <param name="af">AVAudioFifo to drain</param>
            <param name="nb_samples">number of samples to drain</param>
            <returns>0 if OK, or negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_free(FFmpeg.AutoGen.AVAudioFifo*)">
            <summary>Free an AVAudioFifo.</summary>
            <param name="af">AVAudioFifo to free</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_peek(FFmpeg.AutoGen.AVAudioFifo*,System.Void**,System.Int32)">
            <summary>Peek data from an AVAudioFifo.</summary>
            <param name="af">AVAudioFifo to read from</param>
            <param name="data">audio data plane pointers</param>
            <param name="nb_samples">number of samples to peek</param>
            <returns>number of samples actually peek, or negative AVERROR code on failure. The number of samples actually peek will not be greater than nb_samples, and will only be less than nb_samples if av_audio_fifo_size is less than nb_samples.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_peek_at(FFmpeg.AutoGen.AVAudioFifo*,System.Void**,System.Int32,System.Int32)">
            <summary>Peek data from an AVAudioFifo.</summary>
            <param name="af">AVAudioFifo to read from</param>
            <param name="data">audio data plane pointers</param>
            <param name="nb_samples">number of samples to peek</param>
            <param name="offset">offset from current read position</param>
            <returns>number of samples actually peek, or negative AVERROR code on failure. The number of samples actually peek will not be greater than nb_samples, and will only be less than nb_samples if av_audio_fifo_size is less than nb_samples.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_read(FFmpeg.AutoGen.AVAudioFifo*,System.Void**,System.Int32)">
            <summary>Read data from an AVAudioFifo.</summary>
            <param name="af">AVAudioFifo to read from</param>
            <param name="data">audio data plane pointers</param>
            <param name="nb_samples">number of samples to read</param>
            <returns>number of samples actually read, or negative AVERROR code on failure. The number of samples actually read will not be greater than nb_samples, and will only be less than nb_samples if av_audio_fifo_size is less than nb_samples.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_realloc(FFmpeg.AutoGen.AVAudioFifo*,System.Int32)">
            <summary>Reallocate an AVAudioFifo.</summary>
            <param name="af">AVAudioFifo to reallocate</param>
            <param name="nb_samples">new allocation size, in samples</param>
            <returns>0 if OK, or negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_reset(FFmpeg.AutoGen.AVAudioFifo*)">
            <summary>Reset the AVAudioFifo buffer.</summary>
            <param name="af">AVAudioFifo to reset</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_size(FFmpeg.AutoGen.AVAudioFifo*)">
            <summary>Get the current number of samples in the AVAudioFifo available for reading.</summary>
            <param name="af">the AVAudioFifo to query</param>
            <returns>number of samples available for reading</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_space(FFmpeg.AutoGen.AVAudioFifo*)">
            <summary>Get the current number of samples in the AVAudioFifo available for writing.</summary>
            <param name="af">the AVAudioFifo to query</param>
            <returns>number of samples available for writing</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_audio_fifo_write(FFmpeg.AutoGen.AVAudioFifo*,System.Void**,System.Int32)">
            <summary>Write data to an AVAudioFifo.</summary>
            <param name="af">AVAudioFifo to write to</param>
            <param name="data">audio data plane pointers</param>
            <param name="nb_samples">number of samples to write</param>
            <returns>number of samples actually written, or negative AVERROR code on failure. If successful, the number of samples actually written will always be nb_samples.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_bprint_channel_layout(FFmpeg.AutoGen.AVBPrint*,System.Int32,System.UInt64)">
            <summary>Append a description of a channel layout to a bprint buffer.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_alloc(System.Int32)">
            <summary>Allocate an AVBuffer of the given size using av_malloc().</summary>
            <returns>an AVBufferRef of given size or NULL when out of memory</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_allocz(System.Int32)">
            <summary>Same as av_buffer_alloc(), except the returned buffer will be initialized to zero.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_create(System.Byte*,System.Int32,FFmpeg.AutoGen.av_buffer_create_free_func,System.Void*,System.Int32)">
            <summary>Create an AVBuffer from an existing array.</summary>
            <param name="data">data array</param>
            <param name="size">size of data in bytes</param>
            <param name="free">a callback for freeing this buffer&apos;s data</param>
            <param name="opaque">parameter to be got for processing or passed to free</param>
            <param name="flags">a combination of AV_BUFFER_FLAG_*</param>
            <returns>an AVBufferRef referring to data on success, NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_default_free(System.Void*,System.Byte*)">
            <summary>Default free callback, which calls av_free() on the buffer data. This function is meant to be passed to av_buffer_create(), not called directly.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_get_opaque(FFmpeg.AutoGen.AVBufferRef*)">
            <summary>Returns the opaque parameter set by av_buffer_create.</summary>
            <returns>the opaque parameter set by av_buffer_create.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_is_writable(FFmpeg.AutoGen.AVBufferRef*)">
            <summary>Returns 1 if the caller may write to the data referred to by buf (which is true if and only if buf is the only reference to the underlying AVBuffer). Return 0 otherwise. A positive answer is valid until av_buffer_ref() is called on buf.</summary>
            <returns>1 if the caller may write to the data referred to by buf (which is true if and only if buf is the only reference to the underlying AVBuffer). Return 0 otherwise. A positive answer is valid until av_buffer_ref() is called on buf.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_make_writable(FFmpeg.AutoGen.AVBufferRef**)">
            <summary>Create a writable reference from a given buffer reference, avoiding data copy if possible.</summary>
            <param name="buf">buffer reference to make writable. On success, buf is either left untouched, or it is unreferenced and a new writable AVBufferRef is written in its place. On failure, buf is left untouched.</param>
            <returns>0 on success, a negative AVERROR on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_pool_buffer_get_opaque(FFmpeg.AutoGen.AVBufferRef*)">
            <summary>Query the original opaque parameter of an allocated buffer in the pool.</summary>
            <param name="ref">a buffer reference to a buffer returned by av_buffer_pool_get.</param>
            <returns>the opaque parameter set by the buffer allocator function of the buffer pool.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_pool_get(FFmpeg.AutoGen.AVBufferPool*)">
            <summary>Allocate a new AVBuffer, reusing an old buffer from the pool when available. This function may be called simultaneously from multiple threads.</summary>
            <returns>a reference to the new buffer on success, NULL on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_pool_init(System.Int32,FFmpeg.AutoGen.av_buffer_pool_init_alloc_func)">
            <summary>Allocate and initialize a buffer pool.</summary>
            <param name="size">size of each buffer in this pool</param>
            <param name="alloc">a function that will be used to allocate new buffers when the pool is empty. May be NULL, then the default allocator will be used (av_buffer_alloc()).</param>
            <returns>newly created buffer pool on success, NULL on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_pool_init2(System.Int32,System.Void*,FFmpeg.AutoGen.av_buffer_pool_init2_alloc_func,FFmpeg.AutoGen.av_buffer_pool_init2_pool_free_func)">
            <summary>Allocate and initialize a buffer pool with a more complex allocator.</summary>
            <param name="size">size of each buffer in this pool</param>
            <param name="opaque">arbitrary user data used by the allocator</param>
            <param name="alloc">a function that will be used to allocate new buffers when the pool is empty. May be NULL, then the default allocator will be used (av_buffer_alloc()).</param>
            <param name="pool_free">a function that will be called immediately before the pool is freed. I.e. after av_buffer_pool_uninit() is called by the caller and all the frames are returned to the pool and freed. It is intended to uninitialize the user opaque data. May be NULL.</param>
            <returns>newly created buffer pool on success, NULL on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_pool_uninit(FFmpeg.AutoGen.AVBufferPool**)">
            <summary>Mark the pool as being available for freeing. It will actually be freed only once all the allocated buffers associated with the pool are released. Thus it is safe to call this function while some of the allocated buffers are still in use.</summary>
            <param name="pool">pointer to the pool to be freed. It will be set to NULL.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_realloc(FFmpeg.AutoGen.AVBufferRef**,System.Int32)">
            <summary>Reallocate a given buffer.</summary>
            <param name="buf">a buffer reference to reallocate. On success, buf will be unreferenced and a new reference with the required size will be written in its place. On failure buf will be left untouched. *buf may be NULL, then a new buffer is allocated.</param>
            <param name="size">required new buffer size.</param>
            <returns>0 on success, a negative AVERROR on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_ref(FFmpeg.AutoGen.AVBufferRef*)">
            <summary>Create a new reference to an AVBuffer.</summary>
            <returns>a new AVBufferRef referring to the same AVBuffer as buf or NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_buffer_unref(FFmpeg.AutoGen.AVBufferRef**)">
            <summary>Free a given reference and automatically free the buffer if there are no more references to it.</summary>
            <param name="buf">the reference to be freed. The pointer is set to NULL on return.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_calloc(System.UInt64,System.UInt64)">
            <summary>Non-inlined equivalent of av_mallocz_array().</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_channel_layout_extract_channel(System.UInt64,System.Int32)">
            <summary>Get the channel with the given index in channel_layout.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_chroma_location_from_name(System.String)">
            <summary>Returns the AVChromaLocation value for name or an AVError if not found.</summary>
            <returns>the AVChromaLocation value for name or an AVError if not found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_chroma_location_name(FFmpeg.AutoGen.AVChromaLocation)">
            <summary>Returns the name for provided chroma location or NULL if unknown.</summary>
            <returns>the name for provided chroma location or NULL if unknown.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_color_primaries_from_name(System.String)">
            <summary>Returns the AVColorPrimaries value for name or an AVError if not found.</summary>
            <returns>the AVColorPrimaries value for name or an AVError if not found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_color_primaries_name(FFmpeg.AutoGen.AVColorPrimaries)">
            <summary>Returns the name for provided color primaries or NULL if unknown.</summary>
            <returns>the name for provided color primaries or NULL if unknown.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_color_range_from_name(System.String)">
            <summary>Returns the AVColorRange value for name or an AVError if not found.</summary>
            <returns>the AVColorRange value for name or an AVError if not found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_color_range_name(FFmpeg.AutoGen.AVColorRange)">
            <summary>Returns the name for provided color range or NULL if unknown.</summary>
            <returns>the name for provided color range or NULL if unknown.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_color_space_from_name(System.String)">
            <summary>Returns the AVColorSpace value for name or an AVError if not found.</summary>
            <returns>the AVColorSpace value for name or an AVError if not found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_color_space_name(FFmpeg.AutoGen.AVColorSpace)">
            <summary>Returns the name for provided color space or NULL if unknown.</summary>
            <returns>the name for provided color space or NULL if unknown.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_color_transfer_from_name(System.String)">
            <summary>Returns the AVColorTransferCharacteristic value for name or an AVError if not found.</summary>
            <returns>the AVColorTransferCharacteristic value for name or an AVError if not found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_color_transfer_name(FFmpeg.AutoGen.AVColorTransferCharacteristic)">
            <summary>Returns the name for provided color transfer or NULL if unknown.</summary>
            <returns>the name for provided color transfer or NULL if unknown.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_compare_mod(System.UInt64,System.UInt64,System.UInt64)">
            <summary>Compare the remainders of two integer operands divided by a common divisor.</summary>
            <param name="mod">Divisor; must be a power of 2</param>
            <returns>- a negative value if `a % mod &lt; b % mod` - a positive value if `a % mod &gt; b % mod` - zero             if `a % mod == b % mod`</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_compare_ts(System.Int64,FFmpeg.AutoGen.AVRational,System.Int64,FFmpeg.AutoGen.AVRational)">
            <summary>Compare two timestamps each in its own time base.</summary>
            <returns>One of the following values: - -1 if `ts_a` is before `ts_b` - 1 if `ts_a` is after `ts_b` - 0 if they represent the same position</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_cpu_count">
            <summary>Returns the number of logical CPU cores present.</summary>
            <returns>the number of logical CPU cores present.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_cpu_max_align">
            <summary>Get the maximum data alignment that may be required by FFmpeg.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_d2q(System.Double,System.Int32)">
            <summary>Convert a double precision floating point number to a rational.</summary>
            <param name="d">`double` to convert</param>
            <param name="max">Maximum allowed numerator and denominator</param>
            <returns>`d` in AVRational form</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_default_item_name(System.Void*)">
            <summary>Return the context name</summary>
            <param name="ctx">The AVClass context</param>
            <returns>The AVClass class_name</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dict_copy(FFmpeg.AutoGen.AVDictionary**,FFmpeg.AutoGen.AVDictionary*,System.Int32)">
            <summary>Copy entries from one AVDictionary struct into another.</summary>
            <param name="dst">pointer to a pointer to a AVDictionary struct. If *dst is NULL, this function will allocate a struct for you and put it in *dst</param>
            <param name="src">pointer to source AVDictionary struct</param>
            <param name="flags">flags to use when setting entries in *dst</param>
            <returns>0 on success, negative AVERROR code on failure. If dst was allocated by this function, callers should free the associated memory.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dict_count(FFmpeg.AutoGen.AVDictionary*)">
            <summary>Get number of entries in dictionary.</summary>
            <param name="m">dictionary</param>
            <returns>number of entries in dictionary</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dict_free(FFmpeg.AutoGen.AVDictionary**)">
            <summary>Free all the memory allocated for an AVDictionary struct and all keys and values.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dict_get(FFmpeg.AutoGen.AVDictionary*,System.String,FFmpeg.AutoGen.AVDictionaryEntry*,System.Int32)">
            <summary>Get a dictionary entry with matching key.</summary>
            <param name="key">matching key</param>
            <param name="prev">Set to the previous matching element to find the next. If set to NULL the first matching element is returned.</param>
            <param name="flags">a collection of AV_DICT_* flags controlling how the entry is retrieved</param>
            <returns>found entry or NULL in case no matching entry was found in the dictionary</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dict_get_string(FFmpeg.AutoGen.AVDictionary*,System.Byte**,System.Byte,System.Byte)">
            <summary>Get dictionary entries as a string.</summary>
            <param name="m">dictionary</param>
            <param name="buffer">Pointer to buffer that will be allocated with string containg entries. Buffer must be freed by the caller when is no longer needed.</param>
            <param name="key_val_sep">character used to separate key from value</param>
            <param name="pairs_sep">character used to separate two pairs from each other</param>
            <returns>&gt;= 0 on success, negative on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dict_parse_string(FFmpeg.AutoGen.AVDictionary**,System.String,System.String,System.String,System.Int32)">
            <summary>Parse the key/value pairs list and add the parsed entries to a dictionary.</summary>
            <param name="key_val_sep">a 0-terminated list of characters used to separate key from value</param>
            <param name="pairs_sep">a 0-terminated list of characters used to separate two pairs from each other</param>
            <param name="flags">flags to use when adding to dictionary. AV_DICT_DONT_STRDUP_KEY and AV_DICT_DONT_STRDUP_VAL are ignored since the key/value tokens will always be duplicated.</param>
            <returns>0 on success, negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dict_set(FFmpeg.AutoGen.AVDictionary**,System.String,System.String,System.Int32)">
            <summary>Set the given entry in *pm, overwriting an existing entry.</summary>
            <param name="pm">pointer to a pointer to a dictionary struct. If *pm is NULL a dictionary struct is allocated and put in *pm.</param>
            <param name="key">entry key to add to *pm (will either be av_strduped or added as a new key depending on flags)</param>
            <param name="value">entry value to add to *pm (will be av_strduped or added as a new key depending on flags). Passing a NULL value will cause an existing entry to be deleted.</param>
            <returns>&gt;= 0 on success otherwise an error code &lt; 0</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dict_set_int(FFmpeg.AutoGen.AVDictionary**,System.String,System.Int64,System.Int32)">
            <summary>Convenience wrapper for av_dict_set that converts the value to a string and stores it.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_div_q(FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational)">
            <summary>Divide one rational by another.</summary>
            <param name="b">First rational</param>
            <param name="c">Second rational</param>
            <returns>b/c</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dynarray_add(System.Void*,System.Int32*,System.Void*)">
            <summary>Add the pointer to an element to a dynamic array.</summary>
            <param name="tab_ptr">Pointer to the array to grow</param>
            <param name="nb_ptr">Pointer to the number of elements in the array</param>
            <param name="elem">Element to add</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dynarray_add_nofree(System.Void*,System.Int32*,System.Void*)">
            <summary>Add an element to a dynamic array.</summary>
            <returns>&gt;=0 on success, negative otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_dynarray2_add(System.Void**,System.Int32*,System.UInt64,System.Byte*)">
            <summary>Add an element of size `elem_size` to a dynamic array.</summary>
            <param name="tab_ptr">Pointer to the array to grow</param>
            <param name="nb_ptr">Pointer to the number of elements in the array</param>
            <param name="elem_size">Size in bytes of an element in the array</param>
            <param name="elem_data">Pointer to the data of the element to add. If `NULL`, the space of the newly added element is allocated but left uninitialized.</param>
            <returns>Pointer to the data of the element to copy in the newly allocated space</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fast_malloc(System.Void*,System.UInt32*,System.UInt64)">
            <summary>Allocate a buffer, reusing the given one if large enough.</summary>
            <param name="ptr">Pointer to pointer to an already allocated buffer. `*ptr` will be overwritten with pointer to new buffer on success or `NULL` on failure</param>
            <param name="size">Pointer to the size of buffer `*ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure.</param>
            <param name="min_size">Desired minimal size of buffer `*ptr`</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fast_mallocz(System.Void*,System.UInt32*,System.UInt64)">
            <summary>Allocate and clear a buffer, reusing the given one if large enough.</summary>
            <param name="ptr">Pointer to pointer to an already allocated buffer. `*ptr` will be overwritten with pointer to new buffer on success or `NULL` on failure</param>
            <param name="size">Pointer to the size of buffer `*ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure.</param>
            <param name="min_size">Desired minimal size of buffer `*ptr`</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fast_realloc(System.Void*,System.UInt32*,System.UInt64)">
            <summary>Reallocate the given buffer if it is not large enough, otherwise do nothing.</summary>
            <param name="ptr">Already allocated buffer, or `NULL`</param>
            <param name="size">Pointer to the size of buffer `ptr`. `*size` is updated to the new allocated size, in particular 0 in case of failure.</param>
            <param name="min_size">Desired minimal size of buffer `ptr`</param>
            <returns>`ptr` if the buffer is large enough, a pointer to newly reallocated buffer if the buffer was not large enough, or `NULL` in case of error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_alloc(System.UInt32)">
            <summary>Initialize an AVFifoBuffer.</summary>
            <param name="size">of FIFO</param>
            <returns>AVFifoBuffer or NULL in case of memory allocation failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_alloc_array(System.UInt64,System.UInt64)">
            <summary>Initialize an AVFifoBuffer.</summary>
            <param name="nmemb">number of elements</param>
            <param name="size">size of the single element</param>
            <returns>AVFifoBuffer or NULL in case of memory allocation failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_drain(FFmpeg.AutoGen.AVFifoBuffer*,System.Int32)">
            <summary>Read and discard the specified amount of data from an AVFifoBuffer.</summary>
            <param name="f">AVFifoBuffer to read from</param>
            <param name="size">amount of data to read in bytes</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_free(FFmpeg.AutoGen.AVFifoBuffer*)">
            <summary>Free an AVFifoBuffer.</summary>
            <param name="f">AVFifoBuffer to free</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_freep(FFmpeg.AutoGen.AVFifoBuffer**)">
            <summary>Free an AVFifoBuffer and reset pointer to NULL.</summary>
            <param name="f">AVFifoBuffer to free</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_generic_peek(FFmpeg.AutoGen.AVFifoBuffer*,System.Void*,System.Int32,FFmpeg.AutoGen.av_fifo_generic_peek_func_func)">
            <summary>Feed data from an AVFifoBuffer to a user-supplied callback. Similar as av_fifo_gereric_read but without discarding data.</summary>
            <param name="f">AVFifoBuffer to read from</param>
            <param name="dest">data destination</param>
            <param name="buf_size">number of bytes to read</param>
            <param name="func">generic read function</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_generic_peek_at(FFmpeg.AutoGen.AVFifoBuffer*,System.Void*,System.Int32,System.Int32,FFmpeg.AutoGen.av_fifo_generic_peek_at_func_func)">
            <summary>Feed data at specific position from an AVFifoBuffer to a user-supplied callback. Similar as av_fifo_gereric_read but without discarding data.</summary>
            <param name="f">AVFifoBuffer to read from</param>
            <param name="dest">data destination</param>
            <param name="offset">offset from current read position</param>
            <param name="buf_size">number of bytes to read</param>
            <param name="func">generic read function</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_generic_read(FFmpeg.AutoGen.AVFifoBuffer*,System.Void*,System.Int32,FFmpeg.AutoGen.av_fifo_generic_read_func_func)">
            <summary>Feed data from an AVFifoBuffer to a user-supplied callback.</summary>
            <param name="f">AVFifoBuffer to read from</param>
            <param name="dest">data destination</param>
            <param name="buf_size">number of bytes to read</param>
            <param name="func">generic read function</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_generic_write(FFmpeg.AutoGen.AVFifoBuffer*,System.Void*,System.Int32,FFmpeg.AutoGen.av_fifo_generic_write_func_func)">
            <summary>Feed data from a user-supplied callback to an AVFifoBuffer.</summary>
            <param name="f">AVFifoBuffer to write to</param>
            <param name="src">data source; non-const since it may be used as a modifiable context by the function defined in func</param>
            <param name="size">number of bytes to write</param>
            <param name="func">generic write function; the first parameter is src, the second is dest_buf, the third is dest_buf_size. func must return the number of bytes written to dest_buf, or &lt; = 0 to indicate no more data available to write. If func is NULL, src is interpreted as a simple byte array for source data.</param>
            <returns>the number of bytes written to the FIFO</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_grow(FFmpeg.AutoGen.AVFifoBuffer*,System.UInt32)">
            <summary>Enlarge an AVFifoBuffer. In case of reallocation failure, the old FIFO is kept unchanged. The new fifo size may be larger than the requested size.</summary>
            <param name="f">AVFifoBuffer to resize</param>
            <param name="additional_space">the amount of space in bytes to allocate in addition to av_fifo_size()</param>
            <returns>&lt; 0 for failure, &gt;=0 otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_realloc2(FFmpeg.AutoGen.AVFifoBuffer*,System.UInt32)">
            <summary>Resize an AVFifoBuffer. In case of reallocation failure, the old FIFO is kept unchanged.</summary>
            <param name="f">AVFifoBuffer to resize</param>
            <param name="size">new AVFifoBuffer size in bytes</param>
            <returns>&lt; 0 for failure, &gt;=0 otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_reset(FFmpeg.AutoGen.AVFifoBuffer*)">
            <summary>Reset the AVFifoBuffer to the state right after av_fifo_alloc, in particular it is emptied.</summary>
            <param name="f">AVFifoBuffer to reset</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_size(FFmpeg.AutoGen.AVFifoBuffer*)">
            <summary>Return the amount of data in bytes in the AVFifoBuffer, that is the amount of data you can read from it.</summary>
            <param name="f">AVFifoBuffer to read from</param>
            <returns>size</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_space(FFmpeg.AutoGen.AVFifoBuffer*)">
            <summary>Return the amount of space in bytes in the AVFifoBuffer, that is the amount of data you can write into it.</summary>
            <param name="f">AVFifoBuffer to write into</param>
            <returns>size</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_find_best_pix_fmt_of_2(FFmpeg.AutoGen.AVPixelFormat,FFmpeg.AutoGen.AVPixelFormat,FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Int32*)">
            <summary>Compute what kind of losses will occur when converting from one specific pixel format to another. When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. These losses can involve loss of chroma, but also loss of resolution, loss of color depth, loss due to the color space conversion, loss of the alpha bits or loss due to color quantization. av_get_fix_fmt_loss() informs you about the various types of losses which will occur when converting from one pixel format to another.</summary>
            <param name="src_pix_fmt">source pixel format</param>
            <param name="has_alpha">Whether the source pixel format alpha channel is used.</param>
            <returns>Combination of flags informing you what kind of losses will occur (maximum loss for an invalid dst_pix_fmt).</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_find_nearest_q_idx(FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational*)">
            <summary>Find the value in a list of rationals nearest a given reference rational.</summary>
            <param name="q">Reference rational</param>
            <param name="q_list">Array of rationals terminated by `{0, 0}`</param>
            <returns>Index of the nearest value found in the array</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fopen_utf8(System.String,System.String)">
            <summary>Open a file using a UTF-8 filename. The API of this function matches POSIX fopen(), errors are returned through errno.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_force_cpu_flags(System.Int32)">
            <summary>Disables cpu detection and forces the specified flags. -1 is a special case that disables forcing of specific flags.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fourcc_make_string(System.Byte*,System.UInt32)">
            <summary>Fill the provided buffer with a string containing a FourCC (four-character code) representation.</summary>
            <param name="buf">a buffer with size in bytes of at least AV_FOURCC_MAX_STRING_SIZE</param>
            <param name="fourcc">the fourcc to represent</param>
            <returns>the buffer in input</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_alloc">
            <summary>Allocate an AVFrame and set its fields to default values. The resulting struct must be freed using av_frame_free().</summary>
            <returns>An AVFrame filled with default values or NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_apply_cropping(FFmpeg.AutoGen.AVFrame*,System.Int32)">
            <summary>Crop the given video AVFrame according to its crop_left/crop_top/crop_right/ crop_bottom fields. If cropping is successful, the function will adjust the data pointers and the width/height fields, and set the crop fields to 0.</summary>
            <param name="frame">the frame which should be cropped</param>
            <param name="flags">Some combination of AV_FRAME_CROP_* flags, or 0.</param>
            <returns>&gt;= 0 on success, a negative AVERROR on error. If the cropping fields were invalid, AVERROR(ERANGE) is returned, and nothing is changed.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_clone(FFmpeg.AutoGen.AVFrame*)">
            <summary>Create a new frame that references the same data as src.</summary>
            <returns>newly created AVFrame on success, NULL on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_copy(FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Copy the frame data from src to dst.</summary>
            <returns>&gt;= 0 on success, a negative AVERROR on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_copy_props(FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Copy only &quot;metadata&quot; fields from src to dst.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_free(FFmpeg.AutoGen.AVFrame**)">
            <summary>Free the frame and any dynamically allocated objects in it, e.g. extended_data. If the frame is reference counted, it will be unreferenced first.</summary>
            <param name="frame">frame to be freed. The pointer will be set to NULL.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_get_best_effort_timestamp(FFmpeg.AutoGen.AVFrame*)">
            <summary>Accessors for some AVFrame fields. These used to be provided for ABI compatibility, and do not need to be used anymore.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_get_buffer(FFmpeg.AutoGen.AVFrame*,System.Int32)">
            <summary>Allocate new buffer(s) for audio or video data.</summary>
            <param name="frame">frame in which to store the new buffers.</param>
            <param name="align">Required buffer size alignment. If equal to 0, alignment will be chosen automatically for the current CPU. It is highly recommended to pass 0 here unless you know what you are doing.</param>
            <returns>0 on success, a negative AVERROR on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_get_plane_buffer(FFmpeg.AutoGen.AVFrame*,System.Int32)">
            <summary>Get the buffer reference a given data plane is stored in.</summary>
            <param name="plane">index of the data plane of interest in frame-&gt;extended_data.</param>
            <returns>the buffer reference that contains the plane or NULL if the input frame is not valid.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_get_side_data(FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrameSideDataType)">
            <summary>Returns a pointer to the side data of a given type on success, NULL if there is no side data with such type in this frame.</summary>
            <returns>a pointer to the side data of a given type on success, NULL if there is no side data with such type in this frame.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_is_writable(FFmpeg.AutoGen.AVFrame*)">
            <summary>Check if the frame data is writable.</summary>
            <returns>A positive value if the frame data is writable (which is true if and only if each of the underlying buffers has only one reference, namely the one stored in this frame). Return 0 otherwise.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_make_writable(FFmpeg.AutoGen.AVFrame*)">
            <summary>Ensure that the frame data is writable, avoiding data copy if possible.</summary>
            <returns>0 on success, a negative AVERROR on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_move_ref(FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Move everything contained in src to dst and reset src.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_new_side_data(FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrameSideDataType,System.Int32)">
            <summary>Add a new side data to a frame.</summary>
            <param name="frame">a frame to which the side data should be added</param>
            <param name="type">type of the added side data</param>
            <param name="size">size of the side data</param>
            <returns>newly added side data on success, NULL on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_new_side_data_from_buf(FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrameSideDataType,FFmpeg.AutoGen.AVBufferRef*)">
            <summary>Add a new side data to a frame from an existing AVBufferRef</summary>
            <param name="frame">a frame to which the side data should be added</param>
            <param name="type">the type of the added side data</param>
            <param name="buf">an AVBufferRef to add as side data. The ownership of the reference is transferred to the frame.</param>
            <returns>newly added side data on success, NULL on error. On failure the frame is unchanged and the AVBufferRef remains owned by the caller.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_ref(FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Set up a new reference to the data described by the source frame.</summary>
            <returns>0 on success, a negative AVERROR on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_remove_side_data(FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrameSideDataType)">
            <summary>Remove and free all side data instances of the given type.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_side_data_name(FFmpeg.AutoGen.AVFrameSideDataType)">
            <summary>Returns a string identifying the side data type</summary>
            <returns>a string identifying the side data type</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_frame_unref(FFmpeg.AutoGen.AVFrame*)">
            <summary>Unreference all the buffers referenced by frame and reset the frame fields.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_free(System.Void*)">
            <summary>Free a memory block which has been allocated with a function of av_malloc() or av_realloc() family.</summary>
            <param name="ptr">Pointer to the memory block which should be freed.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_freep(System.Void*)">
            <summary>Free a memory block which has been allocated with a function of av_malloc() or av_realloc() family, and set the pointer pointing to it to `NULL`.</summary>
            <param name="ptr">Pointer to the pointer to the memory block which should be freed</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_gcd(System.Int64,System.Int64)">
            <summary>Compute the greatest common divisor of two integer operands.</summary>
            <returns>GCD of a and b up to sign; if a &gt;= 0 and b &gt;= 0, return value is &gt;= 0; if a == 0 and b == 0, returns 0.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_gcd_q(FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational,System.Int32,FFmpeg.AutoGen.AVRational)">
            <summary>Return the best rational so that a and b are multiple of it. If the resulting denominator is larger than max_den, return def.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_alt_sample_fmt(FFmpeg.AutoGen.AVSampleFormat,System.Int32)">
            <summary>Return the planar&lt;-&gt;packed alternative form of the given sample format, or AV_SAMPLE_FMT_NONE on error. If the passed sample_fmt is already in the requested planar/packed format, the format returned is the same as the input.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_bits_per_pixel(FFmpeg.AutoGen.AVPixFmtDescriptor*)">
            <summary>Return the number of bits per pixel used by the pixel format described by pixdesc. Note that this is not the same as the number of bits per sample.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_bytes_per_sample(FFmpeg.AutoGen.AVSampleFormat)">
            <summary>Return number of bytes per sample.</summary>
            <param name="sample_fmt">the sample format</param>
            <returns>number of bytes per sample or zero if unknown for the given sample format</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_channel_description(System.UInt64)">
            <summary>Get the description of a given channel.</summary>
            <param name="channel">a channel layout with a single channel</param>
            <returns>channel description on success, NULL on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_channel_layout(System.String)">
            <summary>Return a channel layout id that matches name, or 0 if no match is found.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_channel_layout_channel_index(System.UInt64,System.UInt64)">
            <summary>Get the index of a channel in channel_layout.</summary>
            <param name="channel">a channel layout describing exactly one channel which must be present in channel_layout.</param>
            <returns>index of channel in channel_layout on success, a negative AVERROR on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_channel_layout_nb_channels(System.UInt64)">
            <summary>Return the number of channels in the channel layout.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_channel_layout_string(System.Byte*,System.Int32,System.Int32,System.UInt64)">
            <summary>Return a description of a channel layout. If nb_channels is &lt;= 0, it is guessed from the channel_layout.</summary>
            <param name="buf">put here the string containing the channel layout</param>
            <param name="buf_size">size in bytes of the buffer</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_channel_name(System.UInt64)">
            <summary>Get the name of a given channel.</summary>
            <returns>channel name on success, NULL on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_colorspace_name(FFmpeg.AutoGen.AVColorSpace)">
            <summary>Get the name of a colorspace.</summary>
            <returns>a static string identifying the colorspace; can be NULL.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_cpu_flags">
            <summary>Return the flags which specify extensions supported by the CPU. The returned value is affected by av_force_cpu_flags() if that was used before. So av_get_cpu_flags() can easily be used in an application to detect the enabled cpu flags.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_default_channel_layout(System.Int32)">
            <summary>Return default channel layout for a given number of channels.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_extended_channel_layout(System.String,System.UInt64*,System.Int32*)">
            <summary>Return a channel layout and the number of channels based on the specified name.</summary>
            <param name="name">channel layout specification string</param>
            <param name="channel_layout">parsed channel layout (0 if unknown)</param>
            <param name="nb_channels">number of channels</param>
            <returns>0 on success, AVERROR(EINVAL) if the parsing fails.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_media_type_string(FFmpeg.AutoGen.AVMediaType)">
            <summary>Return a string describing the media_type enum, NULL if media_type is unknown.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_packed_sample_fmt(FFmpeg.AutoGen.AVSampleFormat)">
            <summary>Get the packed alternative form of the given sample format.</summary>
            <returns>the packed alternative form of the given sample format or AV_SAMPLE_FMT_NONE on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_padded_bits_per_pixel(FFmpeg.AutoGen.AVPixFmtDescriptor*)">
            <summary>Return the number of bits per pixel for the pixel format described by pixdesc, including any padding or unused bits.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_picture_type_char(FFmpeg.AutoGen.AVPictureType)">
            <summary>Return a single letter to describe the given picture type pict_type.</summary>
            <param name="pict_type">the picture type</param>
            <returns>a single character representing the picture type, &apos;?&apos; if pict_type is unknown</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_pix_fmt(System.String)">
            <summary>Return the pixel format corresponding to name.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_pix_fmt_loss(FFmpeg.AutoGen.AVPixelFormat,FFmpeg.AutoGen.AVPixelFormat,System.Int32)">
            <summary>Compute what kind of losses will occur when converting from one specific pixel format to another. When converting from one pixel format to another, information loss may occur. For example, when converting from RGB24 to GRAY, the color information will be lost. Similarly, other losses occur when converting from some formats to other formats. These losses can involve loss of chroma, but also loss of resolution, loss of color depth, loss due to the color space conversion, loss of the alpha bits or loss due to color quantization. av_get_fix_fmt_loss() informs you about the various types of losses which will occur when converting from one pixel format to another.</summary>
            <param name="dst_pix_fmt">destination pixel format</param>
            <param name="src_pix_fmt">source pixel format</param>
            <param name="has_alpha">Whether the source pixel format alpha channel is used.</param>
            <returns>Combination of flags informing you what kind of losses will occur (maximum loss for an invalid dst_pix_fmt).</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_pix_fmt_name(FFmpeg.AutoGen.AVPixelFormat)">
            <summary>Return the short name for a pixel format, NULL in case pix_fmt is unknown.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_pix_fmt_string(System.Byte*,System.Int32,FFmpeg.AutoGen.AVPixelFormat)">
            <summary>Print in buf the string corresponding to the pixel format with number pix_fmt, or a header if pix_fmt is negative.</summary>
            <param name="buf">the buffer where to write the string</param>
            <param name="buf_size">the size of buf</param>
            <param name="pix_fmt">the number of the pixel format to print the corresponding info string, or a negative value to print the corresponding header.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_planar_sample_fmt(FFmpeg.AutoGen.AVSampleFormat)">
            <summary>Get the planar alternative form of the given sample format.</summary>
            <returns>the planar alternative form of the given sample format or AV_SAMPLE_FMT_NONE on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_sample_fmt(System.String)">
            <summary>Return a sample format corresponding to name, or AV_SAMPLE_FMT_NONE on error.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_sample_fmt_name(FFmpeg.AutoGen.AVSampleFormat)">
            <summary>Return the name of sample_fmt, or NULL if sample_fmt is not recognized.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_sample_fmt_string(System.Byte*,System.Int32,FFmpeg.AutoGen.AVSampleFormat)">
            <summary>Generate a string corresponding to the sample format with sample_fmt, or a header if sample_fmt is negative.</summary>
            <param name="buf">the buffer where to write the string</param>
            <param name="buf_size">the size of buf</param>
            <param name="sample_fmt">the number of the sample format to print the corresponding info string, or a negative value to print the corresponding header.</param>
            <returns>the pointer to the filled buffer or NULL if sample_fmt is unknown or in case of other errors</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_standard_channel_layout(System.UInt32,System.UInt64*,System.Byte**)">
            <summary>Get the value and name of a standard channel layout.</summary>
            <param name="index">index in an internal list, starting at 0</param>
            <param name="layout">channel layout mask</param>
            <param name="name">name of the layout</param>
            <returns>0  if the layout exists,  &lt; 0 if index is beyond the limits</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_get_time_base_q">
            <summary>Return the fractional representation of the internal time base.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_gettime">
            <summary>Get the current time in microseconds.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_gettime_relative">
            <summary>Get the current time in microseconds since some unspecified starting point. On platforms that support it, the time comes from a monotonic clock This property makes this time source ideal for measuring relative time. The returned values may not be monotonic on platforms where a monotonic clock is not available.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_gettime_relative_is_monotonic">
            <summary>Indicates with a boolean result if the av_gettime_relative() time source is monotonic.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwdevice_ctx_alloc(FFmpeg.AutoGen.AVHWDeviceType)">
            <summary>Allocate an AVHWDeviceContext for a given hardware type.</summary>
            <param name="type">the type of the hardware device to allocate.</param>
            <returns>a reference to the newly created AVHWDeviceContext on success or NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwdevice_ctx_create(FFmpeg.AutoGen.AVBufferRef**,FFmpeg.AutoGen.AVHWDeviceType,System.String,FFmpeg.AutoGen.AVDictionary*,System.Int32)">
            <summary>Open a device of the specified type and create an AVHWDeviceContext for it.</summary>
            <param name="device_ctx">On success, a reference to the newly-created device context will be written here. The reference is owned by the caller and must be released with av_buffer_unref() when no longer needed. On failure, NULL will be written to this pointer.</param>
            <param name="type">The type of the device to create.</param>
            <param name="device">A type-specific string identifying the device to open.</param>
            <param name="opts">A dictionary of additional (type-specific) options to use in opening the device. The dictionary remains owned by the caller.</param>
            <param name="flags">currently unused</param>
            <returns>0 on success, a negative AVERROR code on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwdevice_ctx_create_derived(FFmpeg.AutoGen.AVBufferRef**,FFmpeg.AutoGen.AVHWDeviceType,FFmpeg.AutoGen.AVBufferRef*,System.Int32)">
            <summary>Create a new device of the specified type from an existing device.</summary>
            <param name="dst_ctx">On success, a reference to the newly-created AVHWDeviceContext.</param>
            <param name="type">The type of the new device to create.</param>
            <param name="src_ctx">A reference to an existing AVHWDeviceContext which will be used to create the new device.</param>
            <param name="flags">Currently unused; should be set to zero.</param>
            <returns>Zero on success, a negative AVERROR code on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwdevice_ctx_create_derived_opts(FFmpeg.AutoGen.AVBufferRef**,FFmpeg.AutoGen.AVHWDeviceType,FFmpeg.AutoGen.AVBufferRef*,FFmpeg.AutoGen.AVDictionary*,System.Int32)">
            <summary>Create a new device of the specified type from an existing device.</summary>
            <param name="dst_ctx">On success, a reference to the newly-created AVHWDeviceContext.</param>
            <param name="type">The type of the new device to create.</param>
            <param name="src_ctx">A reference to an existing AVHWDeviceContext which will be used to create the new device.</param>
            <param name="options">Options for the new device to create, same format as in av_hwdevice_ctx_create.</param>
            <param name="flags">Currently unused; should be set to zero.</param>
            <returns>Zero on success, a negative AVERROR code on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwdevice_ctx_init(FFmpeg.AutoGen.AVBufferRef*)">
            <summary>Finalize the device context before use. This function must be called after the context is filled with all the required information and before it is used in any way.</summary>
            <param name="ref">a reference to the AVHWDeviceContext</param>
            <returns>0 on success, a negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwdevice_find_type_by_name(System.String)">
            <summary>Look up an AVHWDeviceType by name.</summary>
            <param name="name">String name of the device type (case-insensitive).</param>
            <returns>The type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if not found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwdevice_get_hwframe_constraints(FFmpeg.AutoGen.AVBufferRef*,System.Void*)">
            <summary>Get the constraints on HW frames given a device and the HW-specific configuration to be used with that device. If no HW-specific configuration is provided, returns the maximum possible capabilities of the device.</summary>
            <param name="ref">a reference to the associated AVHWDeviceContext.</param>
            <param name="hwconfig">a filled HW-specific configuration structure, or NULL to return the maximum possible capabilities of the device.</param>
            <returns>AVHWFramesConstraints structure describing the constraints on the device, or NULL if not available.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwdevice_get_type_name(FFmpeg.AutoGen.AVHWDeviceType)">
            <summary>Get the string name of an AVHWDeviceType.</summary>
            <param name="type">Type from enum AVHWDeviceType.</param>
            <returns>Pointer to a static string containing the name, or NULL if the type is not valid.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwdevice_hwconfig_alloc(FFmpeg.AutoGen.AVBufferRef*)">
            <summary>Allocate a HW-specific configuration structure for a given HW device. After use, the user must free all members as required by the specific hardware structure being used, then free the structure itself with av_free().</summary>
            <param name="device_ctx">a reference to the associated AVHWDeviceContext.</param>
            <returns>The newly created HW-specific configuration structure on success or NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwdevice_iterate_types(FFmpeg.AutoGen.AVHWDeviceType)">
            <summary>Iterate over supported device types.</summary>
            <returns>The next usable device type from enum AVHWDeviceType, or AV_HWDEVICE_TYPE_NONE if there are no more.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwframe_constraints_free(FFmpeg.AutoGen.AVHWFramesConstraints**)">
            <summary>Free an AVHWFrameConstraints structure.</summary>
            <param name="constraints">The (filled or unfilled) AVHWFrameConstraints structure.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwframe_ctx_alloc(FFmpeg.AutoGen.AVBufferRef*)">
            <summary>Allocate an AVHWFramesContext tied to a given device context.</summary>
            <param name="device_ctx">a reference to a AVHWDeviceContext. This function will make a new reference for internal use, the one passed to the function remains owned by the caller.</param>
            <returns>a reference to the newly created AVHWFramesContext on success or NULL on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwframe_ctx_create_derived(FFmpeg.AutoGen.AVBufferRef**,FFmpeg.AutoGen.AVPixelFormat,FFmpeg.AutoGen.AVBufferRef*,FFmpeg.AutoGen.AVBufferRef*,System.Int32)">
            <summary>Create and initialise an AVHWFramesContext as a mapping of another existing AVHWFramesContext on a different device.</summary>
            <param name="derived_frame_ctx">On success, a reference to the newly created AVHWFramesContext.</param>
            <param name="derived_device_ctx">A reference to the device to create the new AVHWFramesContext on.</param>
            <param name="source_frame_ctx">A reference to an existing AVHWFramesContext which will be mapped to the derived context.</param>
            <param name="flags">Some combination of AV_HWFRAME_MAP_* flags, defining the mapping parameters to apply to frames which are allocated in the derived device.</param>
            <returns>Zero on success, negative AVERROR code on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwframe_ctx_init(FFmpeg.AutoGen.AVBufferRef*)">
            <summary>Finalize the context before use. This function must be called after the context is filled with all the required information and before it is attached to any frames.</summary>
            <param name="ref">a reference to the AVHWFramesContext</param>
            <returns>0 on success, a negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwframe_get_buffer(FFmpeg.AutoGen.AVBufferRef*,FFmpeg.AutoGen.AVFrame*,System.Int32)">
            <summary>Allocate a new frame attached to the given AVHWFramesContext.</summary>
            <param name="hwframe_ctx">a reference to an AVHWFramesContext</param>
            <param name="frame">an empty (freshly allocated or unreffed) frame to be filled with newly allocated buffers.</param>
            <param name="flags">currently unused, should be set to zero</param>
            <returns>0 on success, a negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwframe_map(FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrame*,System.Int32)">
            <summary>Map a hardware frame.</summary>
            <param name="dst">Destination frame, to contain the mapping.</param>
            <param name="src">Source frame, to be mapped.</param>
            <param name="flags">Some combination of AV_HWFRAME_MAP_* flags.</param>
            <returns>Zero on success, negative AVERROR code on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwframe_transfer_data(FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrame*,System.Int32)">
            <summary>Copy data to or from a hw surface. At least one of dst/src must have an AVHWFramesContext attached.</summary>
            <param name="dst">the destination frame. dst is not touched on failure.</param>
            <param name="src">the source frame.</param>
            <param name="flags">currently unused, should be set to zero</param>
            <returns>0 on success, a negative AVERROR error code on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_hwframe_transfer_get_formats(FFmpeg.AutoGen.AVBufferRef*,FFmpeg.AutoGen.AVHWFrameTransferDirection,FFmpeg.AutoGen.AVPixelFormat**,System.Int32)">
            <summary>Get a list of possible source or target formats usable in av_hwframe_transfer_data().</summary>
            <param name="hwframe_ctx">the frame context to obtain the information for</param>
            <param name="dir">the direction of the transfer</param>
            <param name="formats">the pointer to the output format list will be written here. The list is terminated with AV_PIX_FMT_NONE and must be freed by the caller when no longer needed using av_free(). If this function returns successfully, the format list will have at least one item (not counting the terminator). On failure, the contents of this pointer are unspecified.</param>
            <param name="flags">currently unused, should be set to zero</param>
            <returns>0 on success, a negative AVERROR code on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_alloc(FFmpeg.AutoGen.byte_ptrArray4@,FFmpeg.AutoGen.int_array4@,System.Int32,System.Int32,FFmpeg.AutoGen.AVPixelFormat,System.Int32)">
            <summary>Allocate an image with size w and h and pixel format pix_fmt, and fill pointers and linesizes accordingly. The allocated image buffer has to be freed by using av_freep(&amp;pointers[0]).</summary>
            <param name="align">the value to use for buffer size alignment</param>
            <returns>the size in bytes required for the image buffer, a negative error code in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_check_sar(System.UInt32,System.UInt32,FFmpeg.AutoGen.AVRational)">
            <summary>Check if the given sample aspect ratio of an image is valid.</summary>
            <param name="w">width of the image</param>
            <param name="h">height of the image</param>
            <param name="sar">sample aspect ratio of the image</param>
            <returns>0 if valid, a negative AVERROR code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_check_size(System.UInt32,System.UInt32,System.Int32,System.Void*)">
            <summary>Check if the given dimension of an image is valid, meaning that all bytes of the image can be addressed with a signed int.</summary>
            <param name="w">the width of the picture</param>
            <param name="h">the height of the picture</param>
            <param name="log_offset">the offset to sum to the log level for logging with log_ctx</param>
            <param name="log_ctx">the parent logging context, it may be NULL</param>
            <returns>&gt;= 0 if valid, a negative error code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_check_size2(System.UInt32,System.UInt32,System.Int64,FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Void*)">
            <summary>Check if the given dimension of an image is valid, meaning that all bytes of a plane of an image with the specified pix_fmt can be addressed with a signed int.</summary>
            <param name="w">the width of the picture</param>
            <param name="h">the height of the picture</param>
            <param name="max_pixels">the maximum number of pixels the user wants to accept</param>
            <param name="pix_fmt">the pixel format, can be AV_PIX_FMT_NONE if unknown.</param>
            <param name="log_offset">the offset to sum to the log level for logging with log_ctx</param>
            <param name="log_ctx">the parent logging context, it may be NULL</param>
            <returns>&gt;= 0 if valid, a negative error code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_copy(FFmpeg.AutoGen.byte_ptrArray4@,FFmpeg.AutoGen.int_array4@,FFmpeg.AutoGen.byte_ptrArray4@,FFmpeg.AutoGen.int_array4,FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Int32)">
            <summary>Copy image in src_data to dst_data.</summary>
            <param name="dst_linesizes">linesizes for the image in dst_data</param>
            <param name="src_linesizes">linesizes for the image in src_data</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_copy_plane(System.Byte*,System.Int32,System.Byte*,System.Int32,System.Int32,System.Int32)">
            <summary>Copy image plane from src to dst. That is, copy &quot;height&quot; number of lines of &quot;bytewidth&quot; bytes each. The first byte of each successive line is separated by *_linesize bytes.</summary>
            <param name="dst_linesize">linesize for the image plane in dst</param>
            <param name="src_linesize">linesize for the image plane in src</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_copy_to_buffer(System.Byte*,System.Int32,FFmpeg.AutoGen.byte_ptrArray4,FFmpeg.AutoGen.int_array4,FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Int32,System.Int32)">
            <summary>Copy image data from an image into a buffer.</summary>
            <param name="dst">a buffer into which picture data will be copied</param>
            <param name="dst_size">the size in bytes of dst</param>
            <param name="src_data">pointers containing the source image data</param>
            <param name="src_linesize">linesizes for the image in src_data</param>
            <param name="pix_fmt">the pixel format of the source image</param>
            <param name="width">the width of the source image in pixels</param>
            <param name="height">the height of the source image in pixels</param>
            <param name="align">the assumed linesize alignment for dst</param>
            <returns>the number of bytes written to dst, or a negative value (error code) on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_copy_uc_from(FFmpeg.AutoGen.byte_ptrArray4@,FFmpeg.AutoGen.long_array4,FFmpeg.AutoGen.byte_ptrArray4@,FFmpeg.AutoGen.long_array4,FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Int32)">
            <summary>Copy image data located in uncacheable (e.g. GPU mapped) memory. Where available, this function will use special functionality for reading from such memory, which may result in greatly improved performance compared to plain av_image_copy().</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_fill_arrays(FFmpeg.AutoGen.byte_ptrArray4@,FFmpeg.AutoGen.int_array4@,System.Byte*,FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Int32,System.Int32)">
            <summary>Setup the data pointers and linesizes based on the specified image parameters and the provided array.</summary>
            <param name="dst_data">data pointers to be filled in</param>
            <param name="dst_linesize">linesizes for the image in dst_data to be filled in</param>
            <param name="src">buffer which will contain or contains the actual image data, can be NULL</param>
            <param name="pix_fmt">the pixel format of the image</param>
            <param name="width">the width of the image in pixels</param>
            <param name="height">the height of the image in pixels</param>
            <param name="align">the value used in src for linesize alignment</param>
            <returns>the size in bytes required for src, a negative error code in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_fill_black(FFmpeg.AutoGen.byte_ptrArray4@,FFmpeg.AutoGen.long_array4,FFmpeg.AutoGen.AVPixelFormat,FFmpeg.AutoGen.AVColorRange,System.Int32,System.Int32)">
            <summary>Overwrite the image data with black. This is suitable for filling a sub-rectangle of an image, meaning the padding between the right most pixel and the left most pixel on the next line will not be overwritten. For some formats, the image size might be rounded up due to inherent alignment.</summary>
            <param name="dst_data">data pointers to destination image</param>
            <param name="dst_linesize">linesizes for the destination image</param>
            <param name="pix_fmt">the pixel format of the image</param>
            <param name="range">the color range of the image (important for colorspaces such as YUV)</param>
            <param name="width">the width of the image in pixels</param>
            <param name="height">the height of the image in pixels</param>
            <returns>0 if the image data was cleared, a negative AVERROR code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_fill_linesizes(FFmpeg.AutoGen.int_array4@,FFmpeg.AutoGen.AVPixelFormat,System.Int32)">
            <summary>Fill plane linesizes for an image with pixel format pix_fmt and width width.</summary>
            <param name="linesizes">array to be filled with the linesize for each plane</param>
            <returns>&gt;= 0 in case of success, a negative error code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_fill_max_pixsteps(FFmpeg.AutoGen.int_array4@,FFmpeg.AutoGen.int_array4@,FFmpeg.AutoGen.AVPixFmtDescriptor*)">
            <summary>Compute the max pixel step for each plane of an image with a format described by pixdesc.</summary>
            <param name="max_pixsteps">an array which is filled with the max pixel step for each plane. Since a plane may contain different pixel components, the computed max_pixsteps[plane] is relative to the component in the plane with the max pixel step.</param>
            <param name="max_pixstep_comps">an array which is filled with the component for each plane which has the max pixel step. May be NULL.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_fill_pointers(FFmpeg.AutoGen.byte_ptrArray4@,FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Byte*,FFmpeg.AutoGen.int_array4)">
            <summary>Fill plane data pointers for an image with pixel format pix_fmt and height height.</summary>
            <param name="data">pointers array to be filled with the pointer for each image plane</param>
            <param name="ptr">the pointer to a buffer which will contain the image</param>
            <param name="linesizes">the array containing the linesize for each plane, should be filled by av_image_fill_linesizes()</param>
            <returns>the size in bytes required for the image buffer, a negative error code in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_get_buffer_size(FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Int32,System.Int32)">
            <summary>Return the size in bytes of the amount of data required to store an image with the given parameters.</summary>
            <param name="pix_fmt">the pixel format of the image</param>
            <param name="width">the width of the image in pixels</param>
            <param name="height">the height of the image in pixels</param>
            <param name="align">the assumed linesize alignment</param>
            <returns>the buffer size in bytes, a negative error code in case of failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_image_get_linesize(FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Int32)">
            <summary>Compute the size of an image line with format pix_fmt and width width for the plane plane.</summary>
            <returns>the computed size in bytes</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_int_list_length_for_size(System.UInt32,System.Void*,System.UInt64)">
            <summary>Compute the length of an integer list.</summary>
            <param name="elsize">size in bytes of each list element (only 1, 2, 4 or 8)</param>
            <param name="list">pointer to the list</param>
            <param name="term">list terminator (usually 0 or -1)</param>
            <returns>length of the list, in elements, not counting the terminator</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_log(System.Void*,System.Int32,System.String)">
            <summary>Send the specified message to the log if the level is less than or equal to the current av_log_level. By default, all logging messages are sent to stderr. This behavior can be altered by setting a different logging callback function.</summary>
            <param name="avcl">A pointer to an arbitrary struct of which the first field is a pointer to an AVClass struct or NULL if general log.</param>
            <param name="level">The importance level of the message expressed using a</param>
            <param name="fmt">The format string (printf-compatible) that specifies how subsequent arguments are converted to output.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_log_default_callback(System.Void*,System.Int32,System.String,System.Byte*)">
            <summary>Default logging callback</summary>
            <param name="avcl">A pointer to an arbitrary struct of which the first field is a pointer to an AVClass struct.</param>
            <param name="level">The importance level of the message expressed using a</param>
            <param name="fmt">The format string (printf-compatible) that specifies how subsequent arguments are converted to output.</param>
            <param name="vl">The arguments referenced by the format string.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_log_format_line(System.Void*,System.Int32,System.String,System.Byte*,System.Byte*,System.Int32,System.Int32*)">
            <summary>Format a line of log the same way as the default callback.</summary>
            <param name="line">buffer to receive the formatted line</param>
            <param name="line_size">size of the buffer</param>
            <param name="print_prefix">used to store whether the prefix must be printed; must point to a persistent integer initially set to 1</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_log_format_line2(System.Void*,System.Int32,System.String,System.Byte*,System.Byte*,System.Int32,System.Int32*)">
            <summary>Format a line of log the same way as the default callback.</summary>
            <param name="line">buffer to receive the formatted line; may be NULL if line_size is 0</param>
            <param name="line_size">size of the buffer; at most line_size-1 characters will be written to the buffer, plus one null terminator</param>
            <param name="print_prefix">used to store whether the prefix must be printed; must point to a persistent integer initially set to 1</param>
            <returns>Returns a negative value if an error occurred, otherwise returns the number of characters that would have been written for a sufficiently large buffer, not including the terminating null character. If the return value is not less than line_size, it means that the log message was truncated to fit the buffer.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_log_get_level">
            <summary>Get the current log level</summary>
            <returns>Current log level</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_log_once(System.Void*,System.Int32,System.Int32,System.Int32*,System.String)">
            <summary>Send the specified message to the log once with the initial_level and then with the subsequent_level. By default, all logging messages are sent to stderr. This behavior can be altered by setting a different logging callback function.</summary>
            <param name="avcl">A pointer to an arbitrary struct of which the first field is a pointer to an AVClass struct or NULL if general log.</param>
            <param name="initial_level">importance level of the message expressed using a</param>
            <param name="subsequent_level">importance level of the message expressed using a</param>
            <param name="state">a variable to keep trak of if a message has already been printed this must be initialized to 0 before the first use. The same state must not be accessed by 2 Threads simultaneously.</param>
            <param name="fmt">The format string (printf-compatible) that specifies how subsequent arguments are converted to output.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_log_set_callback(FFmpeg.AutoGen.av_log_set_callback_callback_func)">
            <summary>Set the logging callback</summary>
            <param name="callback">A logging function with a compatible signature.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_log_set_level(System.Int32)">
            <summary>Set the log level</summary>
            <param name="level">Logging level</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_malloc(System.UInt64)">
            <summary>Allocate a memory block with alignment suitable for all memory accesses (including vectors if available on the CPU).</summary>
            <param name="size">Size in bytes for the memory block to be allocated</param>
            <returns>Pointer to the allocated block, or `NULL` if the block cannot be allocated</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_malloc_array(System.UInt64,System.UInt64)">
            <summary>Allocate a memory block for an array with av_malloc().</summary>
            <param name="nmemb">Number of element</param>
            <param name="size">Size of a single element</param>
            <returns>Pointer to the allocated block, or `NULL` if the block cannot be allocated</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_mallocz(System.UInt64)">
            <summary>Allocate a memory block with alignment suitable for all memory accesses (including vectors if available on the CPU) and zero all the bytes of the block.</summary>
            <param name="size">Size in bytes for the memory block to be allocated</param>
            <returns>Pointer to the allocated block, or `NULL` if it cannot be allocated</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_mallocz_array(System.UInt64,System.UInt64)">
            <summary>Allocate a memory block for an array with av_mallocz().</summary>
            <param name="nmemb">Number of elements</param>
            <param name="size">Size of the single element</param>
            <returns>Pointer to the allocated block, or `NULL` if the block cannot be allocated</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_max_alloc(System.UInt64)">
            <summary>Set the maximum size that may be allocated in one block.</summary>
            <param name="max">Value to be set as the new maximum size</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_memcpy_backptr(System.Byte*,System.Int32,System.Int32)">
            <summary>Overlapping memcpy() implementation.</summary>
            <param name="dst">Destination buffer</param>
            <param name="back">Number of bytes back to start copying (i.e. the initial size of the overlapping window); must be &gt; 0</param>
            <param name="cnt">Number of bytes to copy; must be &gt;= 0</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_memdup(System.Void*,System.UInt64)">
            <summary>Duplicate a buffer with av_malloc().</summary>
            <param name="p">Buffer to be duplicated</param>
            <param name="size">Size in bytes of the buffer copied</param>
            <returns>Pointer to a newly allocated buffer containing a copy of `p` or `NULL` if the buffer cannot be allocated</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_mul_q(FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational)">
            <summary>Multiply two rationals.</summary>
            <param name="b">First rational</param>
            <param name="c">Second rational</param>
            <returns>b*c</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_nearer_q(FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational)">
            <summary>Find which of the two rationals is closer to another rational.</summary>
            <param name="q">Rational to be compared against</param>
            <returns>One of the following values: - 1 if `q1` is nearer to `q` than `q2` - -1 if `q2` is nearer to `q` than `q1` - 0 if they have the same distance</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_child_class_next(FFmpeg.AutoGen.AVClass*,FFmpeg.AutoGen.AVClass*)">
            <summary>Iterate over potential AVOptions-enabled children of parent.</summary>
            <param name="prev">result of a previous call to this function or NULL</param>
            <returns>AVClass corresponding to next potential child or NULL</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_child_next(System.Void*,System.Void*)">
            <summary>Iterate over AVOptions-enabled children of obj.</summary>
            <param name="prev">result of a previous call to this function or NULL</param>
            <returns>next AVOptions-enabled child or NULL</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_copy(System.Void*,System.Void*)">
            <summary>Copy options from src object into dest object.</summary>
            <param name="dest">Object to copy from</param>
            <param name="src">Object to copy into</param>
            <returns>0 on success, negative on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_eval_flags(System.Void*,FFmpeg.AutoGen.AVOption*,System.String,System.Int32*)">
            <summary>@{ This group of functions can be used to evaluate option strings and get numbers out of them. They do the same thing as av_opt_set(), except the result is written into the caller-supplied pointer.</summary>
            <param name="obj">a struct whose first element is a pointer to AVClass.</param>
            <param name="o">an option for which the string is to be evaluated.</param>
            <param name="val">string to be evaluated.</param>
            <returns>0 on success, a negative number on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_find(System.Void*,System.String,System.String,System.Int32,System.Int32)">
            <summary>Look for an option in an object. Consider only options which have all the specified flags set.</summary>
            <param name="obj">A pointer to a struct whose first element is a pointer to an AVClass. Alternatively a double pointer to an AVClass, if AV_OPT_SEARCH_FAKE_OBJ search flag is set.</param>
            <param name="name">The name of the option to look for.</param>
            <param name="unit">When searching for named constants, name of the unit it belongs to.</param>
            <param name="opt_flags">Find only options with all the specified flags set (AV_OPT_FLAG).</param>
            <param name="search_flags">A combination of AV_OPT_SEARCH_*.</param>
            <returns>A pointer to the option found, or NULL if no option was found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_find2(System.Void*,System.String,System.String,System.Int32,System.Int32,System.Void**)">
            <summary>Look for an option in an object. Consider only options which have all the specified flags set.</summary>
            <param name="obj">A pointer to a struct whose first element is a pointer to an AVClass. Alternatively a double pointer to an AVClass, if AV_OPT_SEARCH_FAKE_OBJ search flag is set.</param>
            <param name="name">The name of the option to look for.</param>
            <param name="unit">When searching for named constants, name of the unit it belongs to.</param>
            <param name="opt_flags">Find only options with all the specified flags set (AV_OPT_FLAG).</param>
            <param name="search_flags">A combination of AV_OPT_SEARCH_*.</param>
            <param name="target_obj">if non-NULL, an object to which the option belongs will be written here. It may be different from obj if AV_OPT_SEARCH_CHILDREN is present in search_flags. This parameter is ignored if search_flags contain AV_OPT_SEARCH_FAKE_OBJ.</param>
            <returns>A pointer to the option found, or NULL if no option was found.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_flag_is_set(System.Void*,System.String,System.String)">
            <summary>Check whether a particular flag is set in a flags field.</summary>
            <param name="field_name">the name of the flag field option</param>
            <param name="flag_name">the name of the flag to check</param>
            <returns>non-zero if the flag is set, zero if the flag isn&apos;t set, isn&apos;t of the right type, or the flags field doesn&apos;t exist.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_free(System.Void*)">
            <summary>Free all allocated objects in obj.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_freep_ranges(FFmpeg.AutoGen.AVOptionRanges**)">
            <summary>Free an AVOptionRanges struct and set it to NULL.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_get(System.Void*,System.String,System.Int32,System.Byte**)">
            <summary>@{ Those functions get a value of the option with the given name from an object.</summary>
            <param name="obj">a struct whose first element is a pointer to an AVClass.</param>
            <param name="name">name of the option to get.</param>
            <param name="search_flags">flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN is passed here, then the option may be found in a child of obj.</param>
            <param name="out_val">value of the option will be written here</param>
            <returns>&gt;=0 on success, a negative error code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_get_dict_val(System.Void*,System.String,System.Int32,FFmpeg.AutoGen.AVDictionary**)">
            <param name="out_val">The returned dictionary is a copy of the actual value and must be freed with av_dict_free() by the caller</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_get_key_value(System.Byte**,System.String,System.String,System.UInt32,System.Byte**,System.Byte**)">
            <summary>Extract a key-value pair from the beginning of a string.</summary>
            <param name="ropts">pointer to the options string, will be updated to point to the rest of the string (one of the pairs_sep or the final NUL)</param>
            <param name="key_val_sep">a 0-terminated list of characters used to separate key from value, for example &apos;=&apos;</param>
            <param name="pairs_sep">a 0-terminated list of characters used to separate two pairs from each other, for example &apos;:&apos; or &apos;,&apos;</param>
            <param name="flags">flags; see the AV_OPT_FLAG_* values below</param>
            <param name="rkey">parsed key; must be freed using av_free()</param>
            <param name="rval">parsed value; must be freed using av_free()</param>
            <returns>&gt;=0 for success, or a negative value corresponding to an AVERROR code in case of error; in particular: AVERROR(EINVAL) if no key is present</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_is_set_to_default(System.Void*,FFmpeg.AutoGen.AVOption*)">
            <summary>Check if given option is set to its default value.</summary>
            <param name="obj">AVClass object to check option on</param>
            <param name="o">option to be checked</param>
            <returns>&gt;0 when option is set to its default, 0 when option is not set its default,  &lt; 0 on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_is_set_to_default_by_name(System.Void*,System.String,System.Int32)">
            <summary>Check if given option is set to its default value.</summary>
            <param name="obj">AVClass object to check option on</param>
            <param name="name">option name</param>
            <param name="search_flags">combination of AV_OPT_SEARCH_*</param>
            <returns>&gt;0 when option is set to its default, 0 when option is not set its default,  &lt; 0 on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_next(System.Void*,FFmpeg.AutoGen.AVOption*)">
            <summary>Iterate over all AVOptions belonging to obj.</summary>
            <param name="obj">an AVOptions-enabled struct or a double pointer to an AVClass describing it.</param>
            <param name="prev">result of the previous call to av_opt_next() on this object or NULL</param>
            <returns>next AVOption or NULL</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_ptr(FFmpeg.AutoGen.AVClass*,System.Void*,System.String)">
            <summary>@}</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_query_ranges(FFmpeg.AutoGen.AVOptionRanges**,System.Void*,System.String,System.Int32)">
            <summary>Get a list of allowed ranges for the given option.</summary>
            <param name="flags">is a bitmask of flags, undefined flags should not be set and should be ignored AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component,</param>
            <returns>number of compontents returned on success, a negative errro code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_query_ranges_default(FFmpeg.AutoGen.AVOptionRanges**,System.Void*,System.String,System.Int32)">
            <summary>Get a default list of allowed ranges for the given option.</summary>
            <param name="flags">is a bitmask of flags, undefined flags should not be set and should be ignored AV_OPT_SEARCH_FAKE_OBJ indicates that the obj is a double pointer to a AVClass instead of a full instance AV_OPT_MULTI_COMPONENT_RANGE indicates that function may return more than one component,</param>
            <returns>number of compontents returned on success, a negative errro code otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_serialize(System.Void*,System.Int32,System.Int32,System.Byte**,System.Byte,System.Byte)">
            <summary>Serialize object&apos;s options.</summary>
            <param name="obj">AVClass object to serialize</param>
            <param name="opt_flags">serialize options with all the specified flags set (AV_OPT_FLAG)</param>
            <param name="flags">combination of AV_OPT_SERIALIZE_* flags</param>
            <param name="buffer">Pointer to buffer that will be allocated with string containg serialized options. Buffer must be freed by the caller when is no longer needed.</param>
            <param name="key_val_sep">character used to separate key from value</param>
            <param name="pairs_sep">character used to separate two pairs from each other</param>
            <returns>&gt;= 0 on success, negative on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_set(System.Void*,System.String,System.String,System.Int32)">
            <summary>@{ Those functions set the field of obj with the given name to value.</summary>
            <param name="obj">A struct whose first element is a pointer to an AVClass.</param>
            <param name="name">the name of the field to set</param>
            <param name="val">The value to set. In case of av_opt_set() if the field is not of a string type, then the given string is parsed. SI postfixes and some named scalars are supported. If the field is of a numeric type, it has to be a numeric or named scalar. Behavior with more than one scalar and +- infix operators is undefined. If the field is of a flags type, it has to be a sequence of numeric scalars or named flags separated by &apos;+&apos; or &apos;-&apos;. Prefixing a flag with &apos;+&apos; causes it to be set without affecting the other flags; similarly, &apos;-&apos; unsets a flag. If the field is of a dictionary type, it has to be a &apos;:&apos; separated list of key=value parameters. Values containing &apos;:&apos; special characters must be escaped.</param>
            <param name="search_flags">flags passed to av_opt_find2. I.e. if AV_OPT_SEARCH_CHILDREN is passed here, then the option may be set on a child of obj.</param>
            <returns>0 if the value has been set, or an AVERROR code in case of error: AVERROR_OPTION_NOT_FOUND if no matching option exists AVERROR(ERANGE) if the value is out of range AVERROR(EINVAL) if the value is not valid</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_set_defaults(System.Void*)">
            <summary>Set the values of all AVOption fields to their default values.</summary>
            <param name="s">an AVOption-enabled struct (its first member must be a pointer to AVClass)</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_set_defaults2(System.Void*,System.Int32,System.Int32)">
            <summary>Set the values of all AVOption fields to their default values. Only these AVOption fields for which (opt-&gt;flags &amp; mask) == flags will have their default applied to s.</summary>
            <param name="s">an AVOption-enabled struct (its first member must be a pointer to AVClass)</param>
            <param name="mask">combination of AV_OPT_FLAG_*</param>
            <param name="flags">combination of AV_OPT_FLAG_*</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_set_dict(System.Void*,FFmpeg.AutoGen.AVDictionary**)">
            <summary>Set all the options from a given dictionary on an object.</summary>
            <param name="obj">a struct whose first element is a pointer to AVClass</param>
            <param name="options">options to process. This dictionary will be freed and replaced by a new one containing all options not found in obj. Of course this new dictionary needs to be freed by caller with av_dict_free().</param>
            <returns>0 on success, a negative AVERROR if some option was found in obj, but could not be set.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_set_dict2(System.Void*,FFmpeg.AutoGen.AVDictionary**,System.Int32)">
            <summary>Set all the options from a given dictionary on an object.</summary>
            <param name="obj">a struct whose first element is a pointer to AVClass</param>
            <param name="options">options to process. This dictionary will be freed and replaced by a new one containing all options not found in obj. Of course this new dictionary needs to be freed by caller with av_dict_free().</param>
            <param name="search_flags">A combination of AV_OPT_SEARCH_*.</param>
            <returns>0 on success, a negative AVERROR if some option was found in obj, but could not be set.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_set_from_string(System.Void*,System.String,System.Byte**,System.String,System.String)">
            <summary>Parse the key-value pairs list in opts. For each key=value pair found, set the value of the corresponding option in ctx.</summary>
            <param name="ctx">the AVClass object to set options on</param>
            <param name="opts">the options string, key-value pairs separated by a delimiter</param>
            <param name="shorthand">a NULL-terminated array of options names for shorthand notation: if the first field in opts has no key part, the key is taken from the first element of shorthand; then again for the second, etc., until either opts is finished, shorthand is finished or a named option is found; after that, all options must be named</param>
            <param name="key_val_sep">a 0-terminated list of characters used to separate key from value, for example &apos;=&apos;</param>
            <param name="pairs_sep">a 0-terminated list of characters used to separate two pairs from each other, for example &apos;:&apos; or &apos;,&apos;</param>
            <returns>the number of successfully set key=value pairs, or a negative value corresponding to an AVERROR code in case of error: AVERROR(EINVAL) if opts cannot be parsed, the error code issued by av_set_string3() if a key/value pair cannot be set</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_opt_show2(System.Void*,System.Void*,System.Int32,System.Int32)">
            <summary>Show the obj options.</summary>
            <param name="av_log_obj">log context to use for showing the options</param>
            <param name="req_flags">requested flags for the options to show. Show only the options for which it is opt-&gt;flags &amp; req_flags.</param>
            <param name="rej_flags">rejected flags for the options to show. Show only the options for which it is !(opt-&gt;flags &amp; req_flags).</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_parse_cpu_caps(System.UInt32*,System.String)">
            <summary>Parse CPU caps from a string and update the given AV_CPU_* flags based on that.</summary>
            <returns>negative on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_parse_cpu_flags(System.String)">
            <summary>Parse CPU flags from a string.</summary>
            <returns>a combination of AV_CPU_* flags, negative on error.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_pix_fmt_count_planes(FFmpeg.AutoGen.AVPixelFormat)">
            <summary>Returns number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a valid pixel format.</summary>
            <returns>number of planes in pix_fmt, a negative AVERROR if pix_fmt is not a valid pixel format.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_pix_fmt_desc_get(FFmpeg.AutoGen.AVPixelFormat)">
            <summary>Returns a pixel format descriptor for provided pixel format or NULL if this pixel format is unknown.</summary>
            <returns>a pixel format descriptor for provided pixel format or NULL if this pixel format is unknown.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_pix_fmt_desc_get_id(FFmpeg.AutoGen.AVPixFmtDescriptor*)">
            <summary>Returns an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc is not a valid pointer to a pixel format descriptor.</summary>
            <returns>an AVPixelFormat id described by desc, or AV_PIX_FMT_NONE if desc is not a valid pointer to a pixel format descriptor.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_pix_fmt_desc_next(FFmpeg.AutoGen.AVPixFmtDescriptor*)">
            <summary>Iterate over all pixel format descriptors known to libavutil.</summary>
            <param name="prev">previous descriptor. NULL to get the first descriptor.</param>
            <returns>next descriptor or NULL after the last descriptor</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_pix_fmt_get_chroma_sub_sample(FFmpeg.AutoGen.AVPixelFormat,System.Int32*,System.Int32*)">
            <summary>Utility function to access log2_chroma_w log2_chroma_h from the pixel format AVPixFmtDescriptor.</summary>
            <param name="pix_fmt">the pixel format</param>
            <param name="h_shift">store log2_chroma_w (horizontal/width shift)</param>
            <param name="v_shift">store log2_chroma_h (vertical/height shift)</param>
            <returns>0 on success, AVERROR(ENOSYS) on invalid or unknown pixel format</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_pix_fmt_swap_endianness(FFmpeg.AutoGen.AVPixelFormat)">
            <summary>Utility function to swap the endianness of a pixel format.</summary>
            <param name="pix_fmt">the pixel format</param>
            <returns>pixel format with swapped endianness if it exists, otherwise AV_PIX_FMT_NONE</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_q2intfloat(FFmpeg.AutoGen.AVRational)">
            <summary>Convert an AVRational to a IEEE 32-bit `float` expressed in fixed-point format.</summary>
            <param name="q">Rational to be converted</param>
            <returns>Equivalent floating-point value, expressed as an unsigned 32-bit integer.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_read_image_line2(System.Void*,FFmpeg.AutoGen.byte_ptrArray4@,FFmpeg.AutoGen.int_array4,FFmpeg.AutoGen.AVPixFmtDescriptor*,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Read a line from an image, and write the values of the pixel format component c to dst.</summary>
            <param name="data">the array containing the pointers to the planes of the image</param>
            <param name="linesize">the array containing the linesizes of the image</param>
            <param name="desc">the pixel format descriptor for the image</param>
            <param name="x">the horizontal coordinate of the first pixel to read</param>
            <param name="y">the vertical coordinate of the first pixel to read</param>
            <param name="w">the width of the line to read, that is the number of values to write to dst</param>
            <param name="read_pal_component">if not zero and the format is a paletted format writes the values corresponding to the palette component c in data[1] to dst, rather than the palette indexes in data[0]. The behavior is undefined if the format is not paletted.</param>
            <param name="dst_element_size">size of elements in dst array (2 or 4 byte)</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_realloc(System.Void*,System.UInt64)">
            <summary>Allocate, reallocate, or free a block of memory.</summary>
            <param name="ptr">Pointer to a memory block already allocated with av_realloc() or `NULL`</param>
            <param name="size">Size in bytes of the memory block to be allocated or reallocated</param>
            <returns>Pointer to a newly-reallocated block or `NULL` if the block cannot be reallocated or the function is used to free the memory block</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_realloc_array(System.Void*,System.UInt64,System.UInt64)">
            <summary>Allocate, reallocate, or free an array.</summary>
            <param name="ptr">Pointer to a memory block already allocated with av_realloc() or `NULL`</param>
            <param name="nmemb">Number of elements in the array</param>
            <param name="size">Size of the single element of the array</param>
            <returns>Pointer to a newly-reallocated block or NULL if the block cannot be reallocated or the function is used to free the memory block</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_realloc_f(System.Void*,System.UInt64,System.UInt64)">
            <summary>Allocate, reallocate, or free a block of memory.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_reallocp(System.Void*,System.UInt64)">
            <summary>Allocate, reallocate, or free a block of memory through a pointer to a pointer.</summary>
            <param name="ptr">Pointer to a pointer to a memory block already allocated with av_realloc(), or a pointer to `NULL`. The pointer is updated on success, or freed on failure.</param>
            <param name="size">Size in bytes for the memory block to be allocated or reallocated</param>
            <returns>Zero on success, an AVERROR error code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_reallocp_array(System.Void*,System.UInt64,System.UInt64)">
            <summary>Allocate, reallocate, or free an array through a pointer to a pointer.</summary>
            <param name="ptr">Pointer to a pointer to a memory block already allocated with av_realloc(), or a pointer to `NULL`. The pointer is updated on success, or freed on failure.</param>
            <param name="nmemb">Number of elements</param>
            <param name="size">Size of the single element</param>
            <returns>Zero on success, an AVERROR error code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_reduce(System.Int32*,System.Int32*,System.Int64,System.Int64,System.Int64)">
            <summary>Reduce a fraction.</summary>
            <param name="dst_num">Destination numerator</param>
            <param name="dst_den">Destination denominator</param>
            <param name="num">Source numerator</param>
            <param name="den">Source denominator</param>
            <param name="max">Maximum allowed values for `dst_num` &amp; `dst_den`</param>
            <returns>1 if the operation is exact, 0 otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_rescale(System.Int64,System.Int64,System.Int64)">
            <summary>Rescale a 64-bit integer with rounding to nearest.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_rescale_delta(FFmpeg.AutoGen.AVRational,System.Int64,FFmpeg.AutoGen.AVRational,System.Int32,System.Int64*,FFmpeg.AutoGen.AVRational)">
            <summary>Rescale a timestamp while preserving known durations.</summary>
            <param name="in_tb">Input time base</param>
            <param name="in_ts">Input timestamp</param>
            <param name="fs_tb">Duration time base; typically this is finer-grained (greater) than `in_tb` and `out_tb`</param>
            <param name="duration">Duration till the next call to this function (i.e. duration of the current packet/frame)</param>
            <param name="last">Pointer to a timestamp expressed in terms of `fs_tb`, acting as a state variable</param>
            <param name="out_tb">Output timebase</param>
            <returns>Timestamp expressed in terms of `out_tb`</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_rescale_q(System.Int64,FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational)">
            <summary>Rescale a 64-bit integer by 2 rational numbers.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_rescale_q_rnd(System.Int64,FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRounding)">
            <summary>Rescale a 64-bit integer by 2 rational numbers with specified rounding.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_rescale_rnd(System.Int64,System.Int64,System.Int64,FFmpeg.AutoGen.AVRounding)">
            <summary>Rescale a 64-bit integer with specified rounding.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_sample_fmt_is_planar(FFmpeg.AutoGen.AVSampleFormat)">
            <summary>Check if the sample format is planar.</summary>
            <param name="sample_fmt">the sample format to inspect</param>
            <returns>1 if the sample format is planar, 0 if it is interleaved</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_samples_alloc(System.Byte**,System.Int32*,System.Int32,System.Int32,FFmpeg.AutoGen.AVSampleFormat,System.Int32)">
            <summary>Allocate a samples buffer for nb_samples samples, and fill data pointers and linesize accordingly. The allocated samples buffer can be freed by using av_freep(&amp;audio_data[0]) Allocated data will be initialized to silence.</summary>
            <param name="audio_data">array to be filled with the pointer for each channel</param>
            <param name="linesize">aligned size for audio buffer(s), may be NULL</param>
            <param name="nb_channels">number of audio channels</param>
            <param name="nb_samples">number of samples per channel</param>
            <param name="align">buffer size alignment (0 = default, 1 = no alignment)</param>
            <returns>&gt;=0 on success or a negative error code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_samples_alloc_array_and_samples(System.Byte***,System.Int32*,System.Int32,System.Int32,FFmpeg.AutoGen.AVSampleFormat,System.Int32)">
            <summary>Allocate a data pointers array, samples buffer for nb_samples samples, and fill data pointers and linesize accordingly.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_samples_copy(System.Byte**,System.Byte**,System.Int32,System.Int32,System.Int32,System.Int32,FFmpeg.AutoGen.AVSampleFormat)">
            <summary>Copy samples from src to dst.</summary>
            <param name="dst">destination array of pointers to data planes</param>
            <param name="src">source array of pointers to data planes</param>
            <param name="dst_offset">offset in samples at which the data will be written to dst</param>
            <param name="src_offset">offset in samples at which the data will be read from src</param>
            <param name="nb_samples">number of samples to be copied</param>
            <param name="nb_channels">number of audio channels</param>
            <param name="sample_fmt">audio sample format</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_samples_fill_arrays(System.Byte**,System.Int32*,System.Byte*,System.Int32,System.Int32,FFmpeg.AutoGen.AVSampleFormat,System.Int32)">
            <summary>Fill plane data pointers and linesize for samples with sample format sample_fmt.</summary>
            <param name="audio_data">array to be filled with the pointer for each channel</param>
            <param name="linesize">calculated linesize, may be NULL</param>
            <param name="buf">the pointer to a buffer containing the samples</param>
            <param name="nb_channels">the number of channels</param>
            <param name="nb_samples">the number of samples in a single channel</param>
            <param name="sample_fmt">the sample format</param>
            <param name="align">buffer size alignment (0 = default, 1 = no alignment)</param>
            <returns>&gt;=0 on success or a negative error code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_samples_get_buffer_size(System.Int32*,System.Int32,System.Int32,FFmpeg.AutoGen.AVSampleFormat,System.Int32)">
            <summary>Get the required buffer size for the given audio parameters.</summary>
            <param name="linesize">calculated linesize, may be NULL</param>
            <param name="nb_channels">the number of channels</param>
            <param name="nb_samples">the number of samples in a single channel</param>
            <param name="sample_fmt">the sample format</param>
            <param name="align">buffer size alignment (0 = default, 1 = no alignment)</param>
            <returns>required buffer size, or negative error code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_samples_set_silence(System.Byte**,System.Int32,System.Int32,System.Int32,FFmpeg.AutoGen.AVSampleFormat)">
            <summary>Fill an audio buffer with silence.</summary>
            <param name="audio_data">array of pointers to data planes</param>
            <param name="offset">offset in samples at which to start filling</param>
            <param name="nb_samples">number of samples to fill</param>
            <param name="nb_channels">number of audio channels</param>
            <param name="sample_fmt">audio sample format</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_set_cpu_flags_mask(System.Int32)">
            <summary>Set a mask on flags returned by av_get_cpu_flags(). This function is mainly useful for testing. Please use av_force_cpu_flags() and av_get_cpu_flags() instead which are more flexible</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_set_options_string(System.Void*,System.String,System.String,System.String)">
            <summary>Parse the key/value pairs list in opts. For each key/value pair found, stores the value in the field in ctx that is named like the key. ctx must be an AVClass context, storing is done using AVOptions.</summary>
            <param name="opts">options string to parse, may be NULL</param>
            <param name="key_val_sep">a 0-terminated list of characters used to separate key from value</param>
            <param name="pairs_sep">a 0-terminated list of characters used to separate two pairs from each other</param>
            <returns>the number of successfully set key/value pairs, or a negative value corresponding to an AVERROR code in case of error: AVERROR(EINVAL) if opts cannot be parsed, the error code issued by av_opt_set() if a key/value pair cannot be set</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_strdup(System.String)">
            <summary>Duplicate a string.</summary>
            <param name="s">String to be duplicated</param>
            <returns>Pointer to a newly-allocated string containing a copy of `s` or `NULL` if the string cannot be allocated</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_strerror(System.Int32,System.Byte*,System.UInt64)">
            <summary>Put a description of the AVERROR code errnum in errbuf. In case of failure the global variable errno is set to indicate the error. Even in case of failure av_strerror() will print a generic error message indicating the errnum provided to errbuf.</summary>
            <param name="errnum">error code to describe</param>
            <param name="errbuf">buffer to which description is written</param>
            <param name="errbuf_size">the size in bytes of errbuf</param>
            <returns>0 on success, a negative value if a description for errnum cannot be found</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_strndup(System.String,System.UInt64)">
            <summary>Duplicate a substring of a string.</summary>
            <param name="s">String to be duplicated</param>
            <param name="len">Maximum length of the resulting string (not counting the terminating byte)</param>
            <returns>Pointer to a newly-allocated string containing a substring of `s` or `NULL` if the string cannot be allocated</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_sub_q(FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational)">
            <summary>Subtract one rational from another.</summary>
            <param name="b">First rational</param>
            <param name="c">Second rational</param>
            <returns>b-c</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_timecode_adjust_ntsc_framenum2(System.Int32,System.Int32)">
            <summary>Adjust frame number for NTSC drop frame time code.</summary>
            <param name="framenum">frame number to adjust</param>
            <param name="fps">frame per second, 30 or 60</param>
            <returns>adjusted frame number</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_timecode_check_frame_rate(FFmpeg.AutoGen.AVRational)">
            <summary>Check if the timecode feature is available for the given frame rate</summary>
            <returns>0 if supported, &lt; 0 otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_timecode_get_smpte_from_framenum(FFmpeg.AutoGen.AVTimecode*,System.Int32)">
            <summary>Convert frame number to SMPTE 12M binary representation.</summary>
            <param name="tc">timecode data correctly initialized</param>
            <param name="framenum">frame number</param>
            <returns>the SMPTE binary representation</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_timecode_init(FFmpeg.AutoGen.AVTimecode*,FFmpeg.AutoGen.AVRational,System.Int32,System.Int32,System.Void*)">
            <summary>Init a timecode struct with the passed parameters.</summary>
            <param name="tc">pointer to an allocated AVTimecode</param>
            <param name="rate">frame rate in rational form</param>
            <param name="flags">miscellaneous flags such as drop frame, +24 hours, ... (see AVTimecodeFlag)</param>
            <param name="frame_start">the first frame number</param>
            <param name="log_ctx">a pointer to an arbitrary struct of which the first field is a pointer to an AVClass struct (used for av_log)</param>
            <returns>0 on success, AVERROR otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_timecode_init_from_string(FFmpeg.AutoGen.AVTimecode*,FFmpeg.AutoGen.AVRational,System.String,System.Void*)">
            <summary>Parse timecode representation (hh:mm:ss[:;.]ff).</summary>
            <param name="tc">pointer to an allocated AVTimecode</param>
            <param name="rate">frame rate in rational form</param>
            <param name="str">timecode string which will determine the frame start</param>
            <param name="log_ctx">a pointer to an arbitrary struct of which the first field is a pointer to an AVClass struct (used for av_log).</param>
            <returns>0 on success, AVERROR otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_timecode_make_mpeg_tc_string(System.Byte*,System.UInt32)">
            <summary>Get the timecode string from the 25-bit timecode format (MPEG GOP format).</summary>
            <param name="buf">destination buffer, must be at least AV_TIMECODE_STR_SIZE long</param>
            <param name="tc25bit">the 25-bits timecode</param>
            <returns>the buf parameter</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_timecode_make_smpte_tc_string(System.Byte*,System.UInt32,System.Int32)">
            <summary>Get the timecode string from the SMPTE timecode format.</summary>
            <param name="buf">destination buffer, must be at least AV_TIMECODE_STR_SIZE long</param>
            <param name="tcsmpte">the 32-bit SMPTE timecode</param>
            <param name="prevent_df">prevent the use of a drop flag when it is known the DF bit is arbitrary</param>
            <returns>the buf parameter</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_timecode_make_string(FFmpeg.AutoGen.AVTimecode*,System.Byte*,System.Int32)">
            <summary>Load timecode string in buf.</summary>
            <param name="tc">timecode data correctly initialized</param>
            <param name="buf">destination buffer, must be at least AV_TIMECODE_STR_SIZE long</param>
            <param name="framenum">frame number</param>
            <returns>the buf parameter</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_tree_enumerate(FFmpeg.AutoGen.AVTreeNode*,System.Void*,FFmpeg.AutoGen.av_tree_enumerate_cmp_func,FFmpeg.AutoGen.av_tree_enumerate_enu_func)">
            <summary>Apply enu(opaque, &amp;elem) to all the elements in the tree in a given range.</summary>
            <param name="cmp">a comparison function that returns &lt; 0 for an element below the range, &gt; 0 for an element above the range and == 0 for an element inside the range</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_tree_find(FFmpeg.AutoGen.AVTreeNode*,System.Void*,FFmpeg.AutoGen.av_tree_find_cmp_func,FFmpeg.AutoGen.void_ptrArray2@)">
            <summary>Find an element.</summary>
            <param name="root">a pointer to the root node of the tree</param>
            <param name="cmp">compare function used to compare elements in the tree, API identical to that of Standard C&apos;s qsort It is guaranteed that the first and only the first argument to cmp() will be the key parameter to av_tree_find(), thus it could if the user wants, be a different type (like an opaque context).</param>
            <param name="next">If next is not NULL, then next[0] will contain the previous element and next[1] the next element. If either does not exist, then the corresponding entry in next is unchanged.</param>
            <returns>An element with cmp(key, elem) == 0 or NULL if no such element exists in the tree.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_tree_insert(FFmpeg.AutoGen.AVTreeNode**,System.Void*,FFmpeg.AutoGen.av_tree_insert_cmp_func,FFmpeg.AutoGen.AVTreeNode**)">
            <summary>Insert or remove an element.</summary>
            <param name="rootp">A pointer to a pointer to the root node of the tree; note that the root node can change during insertions, this is required to keep the tree balanced.</param>
            <param name="key">pointer to the element key to insert in the tree</param>
            <param name="cmp">compare function used to compare elements in the tree, API identical to that of Standard C&apos;s qsort</param>
            <param name="next">Used to allocate and free AVTreeNodes. For insertion the user must set it to an allocated and zeroed object of at least av_tree_node_size bytes size. av_tree_insert() will set it to NULL if it has been consumed. For deleting elements *next is set to NULL by the user and av_tree_insert() will set it to the AVTreeNode which was used for the removed element. This allows the use of flat arrays, which have lower overhead compared to many malloced elements. You might want to define a function like:</param>
            <returns>If no insertion happened, the found element; if an insertion or removal happened, then either key or NULL will be returned. Which one it is depends on the tree state and the implementation. You should make no assumptions that it&apos;s one or the other in the code.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_tree_node_alloc">
            <summary>Allocate an AVTreeNode.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_usleep(System.UInt32)">
            <summary>Sleep for a period of time. Although the duration is expressed in microseconds, the actual delay may be rounded to the precision of the system timer.</summary>
            <param name="usec">Number of microseconds to sleep.</param>
            <returns>zero on success or (negative) error code.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_version_info">
            <summary>Return an informative version string. This usually is the actual release version number or a git commit description. This string has no fixed format and can change any time. It should never be parsed by code.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_vlog(System.Void*,System.Int32,System.String,System.Byte*)">
            <summary>Send the specified message to the log if the level is less than or equal to the current av_log_level. By default, all logging messages are sent to stderr. This behavior can be altered by setting a different logging callback function.</summary>
            <param name="avcl">A pointer to an arbitrary struct of which the first field is a pointer to an AVClass struct.</param>
            <param name="level">The importance level of the message expressed using a</param>
            <param name="fmt">The format string (printf-compatible) that specifies how subsequent arguments are converted to output.</param>
            <param name="vl">The arguments referenced by the format string.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_write_image_line2(System.Void*,FFmpeg.AutoGen.byte_ptrArray4@,FFmpeg.AutoGen.int_array4,FFmpeg.AutoGen.AVPixFmtDescriptor*,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Write the values from src to the pixel format component c of an image line.</summary>
            <param name="src">array containing the values to write</param>
            <param name="data">the array containing the pointers to the planes of the image to write into. It is supposed to be zeroed.</param>
            <param name="linesize">the array containing the linesizes of the image</param>
            <param name="desc">the pixel format descriptor for the image</param>
            <param name="x">the horizontal coordinate of the first pixel to write</param>
            <param name="y">the vertical coordinate of the first pixel to write</param>
            <param name="w">the width of the line to write, that is the number of values to write to the image line</param>
            <param name="src_element_size">size of elements in src array (2 or 4 byte)</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avutil_configuration">
            <summary>Return the libavutil build-time configuration.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avutil_license">
            <summary>Return the libavutil license.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avutil_version">
            <summary>Return the LIBAVUTIL_VERSION_INT constant.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.postproc_configuration">
            <summary>Return the libpostproc build-time configuration.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.postproc_license">
            <summary>Return the libpostproc license.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.postproc_version">
            <summary>Return the LIBPOSTPROC_VERSION_INT constant.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.pp_get_mode_by_name_and_quality(System.String,System.Int32)">
            <summary>Return a pp_mode or NULL if an error occurred.</summary>
            <param name="name">the string after &quot;-pp&quot; on the command line</param>
            <param name="quality">a number from 0 to PP_QUALITY_MAX</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_alloc">
            <summary>Allocate SwrContext.</summary>
            <returns>NULL on error, allocated context otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_alloc_set_opts(FFmpeg.AutoGen.SwrContext*,System.Int64,FFmpeg.AutoGen.AVSampleFormat,System.Int32,System.Int64,FFmpeg.AutoGen.AVSampleFormat,System.Int32,System.Int32,System.Void*)">
            <summary>Allocate SwrContext if needed and set/reset common parameters.</summary>
            <param name="s">existing Swr context if available, or NULL if not</param>
            <param name="out_ch_layout">output channel layout (AV_CH_LAYOUT_*)</param>
            <param name="out_sample_fmt">output sample format (AV_SAMPLE_FMT_*).</param>
            <param name="out_sample_rate">output sample rate (frequency in Hz)</param>
            <param name="in_ch_layout">input channel layout (AV_CH_LAYOUT_*)</param>
            <param name="in_sample_fmt">input sample format (AV_SAMPLE_FMT_*).</param>
            <param name="in_sample_rate">input sample rate (frequency in Hz)</param>
            <param name="log_offset">logging level offset</param>
            <param name="log_ctx">parent logging context, can be NULL</param>
            <returns>NULL on error, allocated context otherwise</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_build_matrix(System.UInt64,System.UInt64,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double*,System.Int32,FFmpeg.AutoGen.AVMatrixEncoding,System.Void*)">
            <summary>Generate a channel mixing matrix.</summary>
            <param name="in_layout">input channel layout</param>
            <param name="out_layout">output channel layout</param>
            <param name="center_mix_level">mix level for the center channel</param>
            <param name="surround_mix_level">mix level for the surround channel(s)</param>
            <param name="lfe_mix_level">mix level for the low-frequency effects channel</param>
            <param name="rematrix_maxval">if 1.0, coefficients will be normalized to prevent overflow. if INT_MAX, coefficients will not be normalized.</param>
            <param name="matrix">mixing coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o.</param>
            <param name="stride">distance between adjacent input channels in the matrix array</param>
            <param name="matrix_encoding">matrixed stereo downmix mode (e.g. dplii)</param>
            <param name="log_ctx">parent logging context, can be NULL</param>
            <returns>0 on success, negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_close(FFmpeg.AutoGen.SwrContext*)">
            <summary>Closes the context so that swr_is_initialized() returns 0.</summary>
            <param name="s">Swr context to be closed</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_config_frame(FFmpeg.AutoGen.SwrContext*,FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Configure or reconfigure the SwrContext using the information provided by the AVFrames.</summary>
            <param name="swr">audio resample context</param>
            <returns>0 on success, AVERROR on failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_convert(FFmpeg.AutoGen.SwrContext*,System.Byte**,System.Int32,System.Byte**,System.Int32)">
            <summary>Convert audio.</summary>
            <param name="s">allocated Swr context, with parameters set</param>
            <param name="out">output buffers, only the first one need be set in case of packed audio</param>
            <param name="out_count">amount of space available for output in samples per channel</param>
            <param name="in">input buffers, only the first one need to be set in case of packed audio</param>
            <param name="in_count">number of input samples available in one channel</param>
            <returns>number of samples output per channel, negative value on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_convert_frame(FFmpeg.AutoGen.SwrContext*,FFmpeg.AutoGen.AVFrame*,FFmpeg.AutoGen.AVFrame*)">
            <summary>Convert the samples in the input AVFrame and write them to the output AVFrame.</summary>
            <param name="swr">audio resample context</param>
            <param name="output">output AVFrame</param>
            <param name="input">input AVFrame</param>
            <returns>0 on success, AVERROR on failure or nonmatching configuration.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_drop_output(FFmpeg.AutoGen.SwrContext*,System.Int32)">
            <summary>Drops the specified number of output samples.</summary>
            <param name="s">allocated Swr context</param>
            <param name="count">number of samples to be dropped</param>
            <returns>&gt;= 0 on success, or a negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_free(FFmpeg.AutoGen.SwrContext**)">
            <summary>Free the given SwrContext and set the pointer to NULL.</summary>
            <param name="s">a pointer to a pointer to Swr context</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_get_class">
            <summary>Get the AVClass for SwrContext. It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.</summary>
            <returns>the AVClass of SwrContext</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_get_delay(FFmpeg.AutoGen.SwrContext*,System.Int64)">
            <summary>Gets the delay the next input sample will experience relative to the next output sample.</summary>
            <param name="s">swr context</param>
            <param name="base">timebase in which the returned delay will be:</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_get_out_samples(FFmpeg.AutoGen.SwrContext*,System.Int32)">
            <summary>Find an upper bound on the number of samples that the next swr_convert call will output, if called with in_samples of input samples. This depends on the internal state, and anything changing the internal state (like further swr_convert() calls) will may change the number of samples swr_get_out_samples() returns for the same number of input samples.</summary>
            <param name="in_samples">number of input samples.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_init(FFmpeg.AutoGen.SwrContext*)">
            <summary>Initialize context after user parameters have been set.</summary>
            <param name="s">Swr context to initialize</param>
            <returns>AVERROR error code in case of failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_inject_silence(FFmpeg.AutoGen.SwrContext*,System.Int32)">
            <summary>Injects the specified number of silence samples.</summary>
            <param name="s">allocated Swr context</param>
            <param name="count">number of samples to be dropped</param>
            <returns>&gt;= 0 on success, or a negative AVERROR code on failure</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_is_initialized(FFmpeg.AutoGen.SwrContext*)">
            <summary>Check whether an swr context has been initialized or not.</summary>
            <param name="s">Swr context to check</param>
            <returns>positive if it has been initialized, 0 if not initialized</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_next_pts(FFmpeg.AutoGen.SwrContext*,System.Int64)">
            <summary>Convert the next timestamp from input to output timestamps are in 1/(in_sample_rate * out_sample_rate) units.</summary>
            <returns>the output timestamp for the next output sample</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_set_channel_mapping(FFmpeg.AutoGen.SwrContext*,System.Int32*)">
            <summary>Set a customized input channel mapping.</summary>
            <param name="s">allocated Swr context, not yet initialized</param>
            <param name="channel_map">customized input channel mapping (array of channel indexes, -1 for a muted channel)</param>
            <returns>&gt;= 0 on success, or AVERROR error code in case of failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_set_compensation(FFmpeg.AutoGen.SwrContext*,System.Int32,System.Int32)">
            <summary>Activate resampling compensation (&quot;soft&quot; compensation). This function is internally called when needed in swr_next_pts().</summary>
            <param name="s">allocated Swr context. If it is not initialized, or SWR_FLAG_RESAMPLE is not set, swr_init() is called with the flag set.</param>
            <param name="sample_delta">delta in PTS per sample</param>
            <param name="compensation_distance">number of samples to compensate for</param>
            <returns>&gt;= 0 on success, AVERROR error codes if:</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swr_set_matrix(FFmpeg.AutoGen.SwrContext*,System.Double*,System.Int32)">
            <summary>Set a customized remix matrix.</summary>
            <param name="s">allocated Swr context, not yet initialized</param>
            <param name="matrix">remix coefficients; matrix[i + stride * o] is the weight of input channel i in output channel o</param>
            <param name="stride">offset between lines of the matrix</param>
            <returns>&gt;= 0 on success, or AVERROR error code in case of failure.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swresample_configuration">
            <summary>Return the swr build-time configuration.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swresample_license">
            <summary>Return the swr license.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swresample_version">
            <summary>Return the</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_alloc_context">
            <summary>Allocate an empty SwsContext. This must be filled and passed to sws_init_context(). For filling see AVOptions, options.c and sws_setColorspaceDetails().</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_allocVec(System.Int32)">
            <summary>Allocate and return an uninitialized vector with length coefficients.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_convertPalette8ToPacked24(System.Byte*,System.Byte*,System.Int32,System.Byte*)">
            <summary>Convert an 8-bit paletted frame into a frame with a color depth of 24 bits.</summary>
            <param name="src">source frame buffer</param>
            <param name="dst">destination frame buffer</param>
            <param name="num_pixels">number of pixels to convert</param>
            <param name="palette">array with [256] entries, which must match color arrangement (RGB or BGR) of src</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_convertPalette8ToPacked32(System.Byte*,System.Byte*,System.Int32,System.Byte*)">
            <summary>Convert an 8-bit paletted frame into a frame with a color depth of 32 bits.</summary>
            <param name="src">source frame buffer</param>
            <param name="dst">destination frame buffer</param>
            <param name="num_pixels">number of pixels to convert</param>
            <param name="palette">array with [256] entries, which must match color arrangement (RGB or BGR) of src</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_freeContext(FFmpeg.AutoGen.SwsContext*)">
            <summary>Free the swscaler context swsContext. If swsContext is NULL, then does nothing.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_get_class">
            <summary>Get the AVClass for swsContext. It can be used in combination with AV_OPT_SEARCH_FAKE_OBJ for examining options.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_getCachedContext(FFmpeg.AutoGen.SwsContext*,System.Int32,System.Int32,FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Int32,FFmpeg.AutoGen.AVPixelFormat,System.Int32,FFmpeg.AutoGen.SwsFilter*,FFmpeg.AutoGen.SwsFilter*,System.Double*)">
            <summary>Check if context can be reused, otherwise reallocate a new one.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_getCoefficients(System.Int32)">
            <summary>Return a pointer to yuv&lt;-&gt;rgb coefficients for the given colorspace suitable for sws_setColorspaceDetails().</summary>
            <param name="colorspace">One of the SWS_CS_* macros. If invalid, SWS_CS_DEFAULT is used.</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_getColorspaceDetails(FFmpeg.AutoGen.SwsContext*,System.Int32**,System.Int32*,System.Int32**,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
            <summary>Returns -1 if not supported</summary>
            <returns>-1 if not supported</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_getContext(System.Int32,System.Int32,FFmpeg.AutoGen.AVPixelFormat,System.Int32,System.Int32,FFmpeg.AutoGen.AVPixelFormat,System.Int32,FFmpeg.AutoGen.SwsFilter*,FFmpeg.AutoGen.SwsFilter*,System.Double*)">
            <summary>Allocate and return an SwsContext. You need it to perform scaling/conversion operations using sws_scale().</summary>
            <param name="srcW">the width of the source image</param>
            <param name="srcH">the height of the source image</param>
            <param name="srcFormat">the source image format</param>
            <param name="dstW">the width of the destination image</param>
            <param name="dstH">the height of the destination image</param>
            <param name="dstFormat">the destination image format</param>
            <param name="flags">specify which algorithm and options to use for rescaling</param>
            <param name="param">extra parameters to tune the used scaler For SWS_BICUBIC param[0] and [1] tune the shape of the basis function, param[0] tunes f(1) and param[1] f´(1) For SWS_GAUSS param[0] tunes the exponent and thus cutoff frequency For SWS_LANCZOS param[0] tunes the width of the window function</param>
            <returns>a pointer to an allocated context, or NULL in case of error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_getGaussianVec(System.Double,System.Double)">
            <summary>Return a normalized Gaussian curve used to filter stuff quality = 3 is high quality, lower is lower quality.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_init_context(FFmpeg.AutoGen.SwsContext*,FFmpeg.AutoGen.SwsFilter*,FFmpeg.AutoGen.SwsFilter*)">
            <summary>Initialize the swscaler context sws_context.</summary>
            <returns>zero or positive value on success, a negative value on error</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_isSupportedEndiannessConversion(FFmpeg.AutoGen.AVPixelFormat)">
            <summary>Returns a positive value if an endianness conversion for pix_fmt is supported, 0 otherwise.</summary>
            <param name="pix_fmt">the pixel format</param>
            <returns>a positive value if an endianness conversion for pix_fmt is supported, 0 otherwise.</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_isSupportedInput(FFmpeg.AutoGen.AVPixelFormat)">
            <summary>Return a positive value if pix_fmt is a supported input format, 0 otherwise.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_isSupportedOutput(FFmpeg.AutoGen.AVPixelFormat)">
            <summary>Return a positive value if pix_fmt is a supported output format, 0 otherwise.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_normalizeVec(FFmpeg.AutoGen.SwsVector*,System.Double)">
            <summary>Scale all the coefficients of a so that their sum equals height.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_scale(FFmpeg.AutoGen.SwsContext*,System.Byte*[],System.Int32[],System.Int32,System.Int32,System.Byte*[],System.Int32[])">
            <summary>Scale the image slice in srcSlice and put the resulting scaled slice in the image in dst. A slice is a sequence of consecutive rows in an image.</summary>
            <param name="c">the scaling context previously created with sws_getContext()</param>
            <param name="srcSlice">the array containing the pointers to the planes of the source slice</param>
            <param name="srcStride">the array containing the strides for each plane of the source image</param>
            <param name="srcSliceY">the position in the source image of the slice to process, that is the number (counted starting from zero) in the image of the first row of the slice</param>
            <param name="srcSliceH">the height of the source slice, that is the number of rows in the slice</param>
            <param name="dst">the array containing the pointers to the planes of the destination image</param>
            <param name="dstStride">the array containing the strides for each plane of the destination image</param>
            <returns>the height of the output slice</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_scaleVec(FFmpeg.AutoGen.SwsVector*,System.Double)">
            <summary>Scale all the coefficients of a by the scalar value.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.sws_setColorspaceDetails(FFmpeg.AutoGen.SwsContext*,FFmpeg.AutoGen.int_array4,System.Int32,FFmpeg.AutoGen.int_array4,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>Returns -1 if not supported</summary>
            <param name="inv_table">the yuv2rgb coefficients describing the input yuv space, normally ff_yuv2rgb_coeffs[x]</param>
            <param name="srcRange">flag indicating the while-black range of the input (1=jpeg / 0=mpeg)</param>
            <param name="table">the yuv2rgb coefficients describing the output yuv space, normally ff_yuv2rgb_coeffs[x]</param>
            <param name="dstRange">flag indicating the while-black range of the output (1=jpeg / 0=mpeg)</param>
            <param name="brightness">16.16 fixed point brightness correction</param>
            <param name="contrast">16.16 fixed point contrast correction</param>
            <param name="saturation">16.16 fixed point saturation correction</param>
            <returns>-1 if not supported</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swscale_configuration">
            <summary>Return the libswscale build-time configuration.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swscale_license">
            <summary>Return the libswscale license.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.swscale_version">
            <summary>Color conversion and scaling library.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_ceil_log2_c(System.Int32)">
            <summary>Compute ceil(log2(x)).</summary>
            <param name="x">value used to compute ceil(log2(x))</param>
            <returns>computed ceiling of log2(x)</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clip_c(System.Int32,System.Int32,System.Int32)">
            <summary>Clip a signed integer value into the amin-amax range.</summary>
            <param name="a">value to clip</param>
            <param name="amin">minimum value of the clip range</param>
            <param name="amax">maximum value of the clip range</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clip_int16_c(System.Int32)">
            <summary>Clip a signed integer value into the -32768,32767 range.</summary>
            <param name="a">value to clip</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clip_int8_c(System.Int32)">
            <summary>Clip a signed integer value into the -128,127 range.</summary>
            <param name="a">value to clip</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clip_intp2_c(System.Int32,System.Int32)">
            <summary>Clip a signed integer into the -(2^p),(2^p-1) range.</summary>
            <param name="a">value to clip</param>
            <param name="p">bit position to clip at</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clip_uint16_c(System.Int32)">
            <summary>Clip a signed integer value into the 0-65535 range.</summary>
            <param name="a">value to clip</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clip_uint8_c(System.Int32)">
            <summary>Clip a signed integer value into the 0-255 range.</summary>
            <param name="a">value to clip</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clip_uintp2_c(System.Int32,System.Int32)">
            <summary>Clip a signed integer to an unsigned power of two range.</summary>
            <param name="a">value to clip</param>
            <param name="p">bit position to clip at</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clip64_c(System.Int64,System.Int64,System.Int64)">
            <summary>Clip a signed 64bit integer value into the amin-amax range.</summary>
            <param name="a">value to clip</param>
            <param name="amin">minimum value of the clip range</param>
            <param name="amax">maximum value of the clip range</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clipd_c(System.Double,System.Double,System.Double)">
            <summary>Clip a double value into the amin-amax range.</summary>
            <param name="a">value to clip</param>
            <param name="amin">minimum value of the clip range</param>
            <param name="amax">maximum value of the clip range</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clipf_c(System.Single,System.Single,System.Single)">
            <summary>Clip a float value into the amin-amax range.</summary>
            <param name="a">value to clip</param>
            <param name="amin">minimum value of the clip range</param>
            <param name="amax">maximum value of the clip range</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_clipl_int32_c(System.Int64)">
            <summary>Clip a signed 64-bit integer value into the -2147483648,2147483647 range.</summary>
            <param name="a">value to clip</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_cmp_q(FFmpeg.AutoGen.AVRational,FFmpeg.AutoGen.AVRational)">
            <summary>Compare two rationals.</summary>
            <param name="a">First rational</param>
            <param name="b">Second rational</param>
            <returns>One of the following values: - 0 if `a == b` - 1 if `a &gt; b` - -1 if `a &lt; b` - `INT_MIN` if one of the values is of the form `0 / 0`</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_double2int(System.Double)">
            <summary>Reinterpret a double as a 64-bit integer.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_fifo_peek2(FFmpeg.AutoGen.AVFifoBuffer*,System.Int32)">
            <summary>Return a pointer to the data stored in a FIFO buffer at a certain offset. The FIFO buffer is not modified.</summary>
            <param name="f">AVFifoBuffer to peek at, f must be non-NULL</param>
            <param name="offs">an offset in bytes, its absolute value must be less than the used buffer size or the returned pointer will point outside to the buffer data. The used buffer size can be checked with av_fifo_size().</param>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_float2int(System.Single)">
            <summary>Reinterpret a float as a 32-bit integer.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_int2double(System.UInt64)">
            <summary>Reinterpret a 64-bit integer as a double.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_int2float(System.UInt32)">
            <summary>Reinterpret a 32-bit integer as a float.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_inv_q(FFmpeg.AutoGen.AVRational)">
            <summary>Invert a rational.</summary>
            <param name="q">value</param>
            <returns>1 / q</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_make_error_string(System.Byte*,System.UInt64,System.Int32)">
            <summary>Fill the provided buffer with a string containing an error string corresponding to the AVERROR code errnum.</summary>
            <param name="errbuf">a buffer</param>
            <param name="errbuf_size">size in bytes of errbuf</param>
            <param name="errnum">error code to describe</param>
            <returns>the buffer in input, filled with the error description</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_make_q(System.Int32,System.Int32)">
            <summary>Create an AVRational.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_mod_uintp2_c(System.UInt32,System.UInt32)">
            <summary>Clear high bits from an unsigned integer starting with specific bit position</summary>
            <param name="a">value to clip</param>
            <param name="p">bit position to clip at</param>
            <returns>clipped value</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_popcount_c(System.UInt32)">
            <summary>Count number of bits set to one in x</summary>
            <param name="x">value to count bits of</param>
            <returns>the number of bits set to one in x</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_popcount64_c(System.UInt64)">
            <summary>Count number of bits set to one in x</summary>
            <param name="x">value to count bits of</param>
            <returns>the number of bits set to one in x</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_q2d(FFmpeg.AutoGen.AVRational)">
            <summary>Convert an AVRational to a `double`.</summary>
            <param name="a">AVRational to convert</param>
            <returns>`a` in floating-point form</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_sat_add32_c(System.Int32,System.Int32)">
            <summary>Add two signed 32-bit values with saturation.</summary>
            <param name="a">one value</param>
            <param name="b">another value</param>
            <returns>sum with signed saturation</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_sat_add64_c(System.Int64,System.Int64)">
            <summary>Add two signed 64-bit values with saturation.</summary>
            <param name="a">one value</param>
            <param name="b">another value</param>
            <returns>sum with signed saturation</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_sat_dadd32_c(System.Int32,System.Int32)">
            <summary>Add a doubled value to another value with saturation at both stages.</summary>
            <param name="a">first value</param>
            <param name="b">value doubled and added to a</param>
            <returns>sum sat(a + sat(2*b)) with signed saturation</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_sat_dsub32_c(System.Int32,System.Int32)">
            <summary>Subtract a doubled value from another value with saturation at both stages.</summary>
            <param name="a">first value</param>
            <param name="b">value doubled and subtracted from a</param>
            <returns>difference sat(a - sat(2*b)) with signed saturation</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_sat_sub32_c(System.Int32,System.Int32)">
            <summary>Subtract two signed 32-bit values with saturation.</summary>
            <param name="a">one value</param>
            <param name="b">another value</param>
            <returns>difference with signed saturation</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_sat_sub64_c(System.Int64,System.Int64)">
            <summary>Subtract two signed 64-bit values with saturation.</summary>
            <param name="a">one value</param>
            <param name="b">another value</param>
            <returns>difference with signed saturation</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_size_mult(System.UInt64,System.UInt64,System.UInt64*)">
            <summary>Multiply two `size_t` values checking for overflow.</summary>
            <param name="r">Pointer to the result of the operation</param>
            <returns>0 on success, AVERROR(EINVAL) on overflow</returns>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.av_x_if_null(System.Void*,System.Void*)">
            <summary>Return x default pointer in case p is NULL.</summary>
        </member>
        <member name="M:FFmpeg.AutoGen.ffmpeg.avio_tell(FFmpeg.AutoGen.AVIOContext*)">
            <summary>ftell() equivalent for AVIOContext.</summary>
            <returns>position or AVERROR.</returns>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg._WIN32_WINNT">
            <summary>_WIN32_WINNT = 0x602</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_BUFFER_FLAG_READONLY">
            <summary>AV_BUFFER_FLAG_READONLY = (1 &lt;&lt; 0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_BUFFERSINK_FLAG_NO_REQUEST">
            <summary>AV_BUFFERSINK_FLAG_NO_REQUEST = 0x2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_BUFFERSINK_FLAG_PEEK">
            <summary>AV_BUFFERSINK_FLAG_PEEK = 0x1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_BACK_CENTER">
            <summary>AV_CH_BACK_CENTER = 0x00000100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_BACK_LEFT">
            <summary>AV_CH_BACK_LEFT = 0x00000010</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_BACK_RIGHT">
            <summary>AV_CH_BACK_RIGHT = 0x00000020</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_FRONT_CENTER">
            <summary>AV_CH_FRONT_CENTER = 0x00000004</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_FRONT_LEFT">
            <summary>AV_CH_FRONT_LEFT = 0x00000001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_FRONT_LEFT_OF_CENTER">
            <summary>AV_CH_FRONT_LEFT_OF_CENTER = 0x00000040</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_FRONT_RIGHT">
            <summary>AV_CH_FRONT_RIGHT = 0x00000002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_FRONT_RIGHT_OF_CENTER">
            <summary>AV_CH_FRONT_RIGHT_OF_CENTER = 0x00000080</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_2_1">
            <summary>AV_CH_LAYOUT_2_1 = (AV_CH_LAYOUT_STEREO|AV_CH_BACK_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_2_2">
            <summary>AV_CH_LAYOUT_2_2 = (AV_CH_LAYOUT_STEREO|AV_CH_SIDE_LEFT|AV_CH_SIDE_RIGHT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_2POINT1">
            <summary>AV_CH_LAYOUT_2POINT1 = (AV_CH_LAYOUT_STEREO|AV_CH_LOW_FREQUENCY)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_3POINT1">
            <summary>AV_CH_LAYOUT_3POINT1 = (AV_CH_LAYOUT_SURROUND|AV_CH_LOW_FREQUENCY)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_4POINT0">
            <summary>AV_CH_LAYOUT_4POINT0 = (AV_CH_LAYOUT_SURROUND|AV_CH_BACK_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_4POINT1">
            <summary>AV_CH_LAYOUT_4POINT1 = (AV_CH_LAYOUT_4POINT0|AV_CH_LOW_FREQUENCY)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_5POINT0">
            <summary>AV_CH_LAYOUT_5POINT0 = (AV_CH_LAYOUT_SURROUND|AV_CH_SIDE_LEFT|AV_CH_SIDE_RIGHT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_5POINT0_BACK">
            <summary>AV_CH_LAYOUT_5POINT0_BACK = (AV_CH_LAYOUT_SURROUND|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_5POINT1">
            <summary>AV_CH_LAYOUT_5POINT1 = (AV_CH_LAYOUT_5POINT0|AV_CH_LOW_FREQUENCY)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_5POINT1_BACK">
            <summary>AV_CH_LAYOUT_5POINT1_BACK = (AV_CH_LAYOUT_5POINT0_BACK|AV_CH_LOW_FREQUENCY)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_6POINT0">
            <summary>AV_CH_LAYOUT_6POINT0 = (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_6POINT0_FRONT">
            <summary>AV_CH_LAYOUT_6POINT0_FRONT = (AV_CH_LAYOUT_2_2|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_6POINT1">
            <summary>AV_CH_LAYOUT_6POINT1 = (AV_CH_LAYOUT_5POINT1|AV_CH_BACK_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_6POINT1_BACK">
            <summary>AV_CH_LAYOUT_6POINT1_BACK = (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_BACK_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_6POINT1_FRONT">
            <summary>AV_CH_LAYOUT_6POINT1_FRONT = (AV_CH_LAYOUT_6POINT0_FRONT|AV_CH_LOW_FREQUENCY)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_7POINT0">
            <summary>AV_CH_LAYOUT_7POINT0 = (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_7POINT0_FRONT">
            <summary>AV_CH_LAYOUT_7POINT0_FRONT = (AV_CH_LAYOUT_5POINT0|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_7POINT1">
            <summary>AV_CH_LAYOUT_7POINT1 = (AV_CH_LAYOUT_5POINT1|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_7POINT1_WIDE">
            <summary>AV_CH_LAYOUT_7POINT1_WIDE = (AV_CH_LAYOUT_5POINT1|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_7POINT1_WIDE_BACK">
            <summary>AV_CH_LAYOUT_7POINT1_WIDE_BACK = (AV_CH_LAYOUT_5POINT1_BACK|AV_CH_FRONT_LEFT_OF_CENTER|AV_CH_FRONT_RIGHT_OF_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_HEXADECAGONAL">
            <summary>AV_CH_LAYOUT_HEXADECAGONAL = (AV_CH_LAYOUT_OCTAGONAL|AV_CH_WIDE_LEFT|AV_CH_WIDE_RIGHT|AV_CH_TOP_BACK_LEFT|AV_CH_TOP_BACK_RIGHT|AV_CH_TOP_BACK_CENTER|AV_CH_TOP_FRONT_CENTER|AV_CH_TOP_FRONT_LEFT|AV_CH_TOP_FRONT_RIGHT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_HEXAGONAL">
            <summary>AV_CH_LAYOUT_HEXAGONAL = (AV_CH_LAYOUT_5POINT0_BACK|AV_CH_BACK_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_MONO">
            <summary>AV_CH_LAYOUT_MONO = (AV_CH_FRONT_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_NATIVE">
            <summary>AV_CH_LAYOUT_NATIVE = 0x8000000000000000ULL</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_OCTAGONAL">
            <summary>AV_CH_LAYOUT_OCTAGONAL = (AV_CH_LAYOUT_5POINT0|AV_CH_BACK_LEFT|AV_CH_BACK_CENTER|AV_CH_BACK_RIGHT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_QUAD">
            <summary>AV_CH_LAYOUT_QUAD = (AV_CH_LAYOUT_STEREO|AV_CH_BACK_LEFT|AV_CH_BACK_RIGHT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_STEREO">
            <summary>AV_CH_LAYOUT_STEREO = (AV_CH_FRONT_LEFT|AV_CH_FRONT_RIGHT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_STEREO_DOWNMIX">
            <summary>AV_CH_LAYOUT_STEREO_DOWNMIX = (AV_CH_STEREO_LEFT|AV_CH_STEREO_RIGHT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LAYOUT_SURROUND">
            <summary>AV_CH_LAYOUT_SURROUND = (AV_CH_LAYOUT_STEREO|AV_CH_FRONT_CENTER)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LOW_FREQUENCY">
            <summary>AV_CH_LOW_FREQUENCY = 0x00000008</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_LOW_FREQUENCY_2">
            <summary>AV_CH_LOW_FREQUENCY_2 = 0x0000000800000000ULL</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_SIDE_LEFT">
            <summary>AV_CH_SIDE_LEFT = 0x00000200</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_SIDE_RIGHT">
            <summary>AV_CH_SIDE_RIGHT = 0x00000400</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_STEREO_LEFT">
            <summary>AV_CH_STEREO_LEFT = 0x20000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_STEREO_RIGHT">
            <summary>AV_CH_STEREO_RIGHT = 0x40000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_SURROUND_DIRECT_LEFT">
            <summary>AV_CH_SURROUND_DIRECT_LEFT = 0x0000000200000000ULL</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_SURROUND_DIRECT_RIGHT">
            <summary>AV_CH_SURROUND_DIRECT_RIGHT = 0x0000000400000000ULL</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_TOP_BACK_CENTER">
            <summary>AV_CH_TOP_BACK_CENTER = 0x00010000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_TOP_BACK_LEFT">
            <summary>AV_CH_TOP_BACK_LEFT = 0x00008000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_TOP_BACK_RIGHT">
            <summary>AV_CH_TOP_BACK_RIGHT = 0x00020000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_TOP_CENTER">
            <summary>AV_CH_TOP_CENTER = 0x00000800</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_TOP_FRONT_CENTER">
            <summary>AV_CH_TOP_FRONT_CENTER = 0x00002000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_TOP_FRONT_LEFT">
            <summary>AV_CH_TOP_FRONT_LEFT = 0x00001000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_TOP_FRONT_RIGHT">
            <summary>AV_CH_TOP_FRONT_RIGHT = 0x00004000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_WIDE_LEFT">
            <summary>AV_CH_WIDE_LEFT = 0x0000000080000000ULL</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CH_WIDE_RIGHT">
            <summary>AV_CH_WIDE_RIGHT = 0x0000000100000000ULL</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_AUTO_THREADS">
            <summary>AV_CODEC_CAP_AUTO_THREADS = (1 &lt;&lt; 15)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_AVOID_PROBING">
            <summary>AV_CODEC_CAP_AVOID_PROBING = (1 &lt;&lt; 17)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_CHANNEL_CONF">
            <summary>AV_CODEC_CAP_CHANNEL_CONF = (1 &lt;&lt; 10)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_DELAY">
            <summary>AV_CODEC_CAP_DELAY = (1 &lt;&lt;  5)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_DR1">
            <summary>AV_CODEC_CAP_DR1 = (1 &lt;&lt;  1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_DRAW_HORIZ_BAND">
            <summary>AV_CODEC_CAP_DRAW_HORIZ_BAND = (1 &lt;&lt;  0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_ENCODER_FLUSH">
            <summary>AV_CODEC_CAP_ENCODER_FLUSH = (1 &lt;&lt; 21)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE">
            <summary>AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE = (1 &lt;&lt; 20)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_EXPERIMENTAL">
            <summary>AV_CODEC_CAP_EXPERIMENTAL = (1 &lt;&lt;  9)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_FRAME_THREADS">
            <summary>AV_CODEC_CAP_FRAME_THREADS = (1 &lt;&lt; 12)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_HARDWARE">
            <summary>AV_CODEC_CAP_HARDWARE = (1 &lt;&lt; 18)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_HYBRID">
            <summary>AV_CODEC_CAP_HYBRID = (1 &lt;&lt; 19)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_INTRA_ONLY">
            <summary>AV_CODEC_CAP_INTRA_ONLY = 0x40000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_LOSSLESS">
            <summary>AV_CODEC_CAP_LOSSLESS = 0x80000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_PARAM_CHANGE">
            <summary>AV_CODEC_CAP_PARAM_CHANGE = (1 &lt;&lt; 14)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_SLICE_THREADS">
            <summary>AV_CODEC_CAP_SLICE_THREADS = (1 &lt;&lt; 13)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_SMALL_LAST_FRAME">
            <summary>AV_CODEC_CAP_SMALL_LAST_FRAME = (1 &lt;&lt;  6)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_SUBFRAMES">
            <summary>AV_CODEC_CAP_SUBFRAMES = (1 &lt;&lt;  8)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_TRUNCATED">
            <summary>AV_CODEC_CAP_TRUNCATED = (1 &lt;&lt;  3)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_CAP_VARIABLE_FRAME_SIZE">
            <summary>AV_CODEC_CAP_VARIABLE_FRAME_SIZE = (1 &lt;&lt; 16)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_EXPORT_DATA_MVS">
            <summary>AV_CODEC_EXPORT_DATA_MVS = (1 &lt;&lt; 0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_EXPORT_DATA_PRFT">
            <summary>AV_CODEC_EXPORT_DATA_PRFT = (1 &lt;&lt; 1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS">
            <summary>AV_CODEC_EXPORT_DATA_VIDEO_ENC_PARAMS = (1 &lt;&lt; 2)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_4MV">
            <summary>AV_CODEC_FLAG_4MV = (1 &lt;&lt;  2)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_AC_PRED">
            <summary>AV_CODEC_FLAG_AC_PRED = (1 &lt;&lt; 24)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_BITEXACT">
            <summary>AV_CODEC_FLAG_BITEXACT = (1 &lt;&lt; 23)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_CLOSED_GOP">
            <summary>AV_CODEC_FLAG_CLOSED_GOP = (1U &lt;&lt; 31)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_DROPCHANGED">
            <summary>AV_CODEC_FLAG_DROPCHANGED = (1 &lt;&lt;  5)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_GLOBAL_HEADER">
            <summary>AV_CODEC_FLAG_GLOBAL_HEADER = (1 &lt;&lt; 22)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_GRAY">
            <summary>AV_CODEC_FLAG_GRAY = (1 &lt;&lt; 13)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_INTERLACED_DCT">
            <summary>AV_CODEC_FLAG_INTERLACED_DCT = (1 &lt;&lt; 18)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_INTERLACED_ME">
            <summary>AV_CODEC_FLAG_INTERLACED_ME = (1 &lt;&lt; 29)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_LOOP_FILTER">
            <summary>AV_CODEC_FLAG_LOOP_FILTER = (1 &lt;&lt; 11)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_LOW_DELAY">
            <summary>AV_CODEC_FLAG_LOW_DELAY = (1 &lt;&lt; 19)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_OUTPUT_CORRUPT">
            <summary>AV_CODEC_FLAG_OUTPUT_CORRUPT = (1 &lt;&lt;  3)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_PASS1">
            <summary>AV_CODEC_FLAG_PASS1 = (1 &lt;&lt;  9)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_PASS2">
            <summary>AV_CODEC_FLAG_PASS2 = (1 &lt;&lt; 10)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_PSNR">
            <summary>AV_CODEC_FLAG_PSNR = (1 &lt;&lt; 15)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_QPEL">
            <summary>AV_CODEC_FLAG_QPEL = (1 &lt;&lt;  4)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_QSCALE">
            <summary>AV_CODEC_FLAG_QSCALE = (1 &lt;&lt;  1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_TRUNCATED">
            <summary>AV_CODEC_FLAG_TRUNCATED = (1 &lt;&lt; 16)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG_UNALIGNED">
            <summary>AV_CODEC_FLAG_UNALIGNED = (1 &lt;&lt;  0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG2_CHUNKS">
            <summary>AV_CODEC_FLAG2_CHUNKS = (1 &lt;&lt; 15)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG2_DROP_FRAME_TIMECODE">
            <summary>AV_CODEC_FLAG2_DROP_FRAME_TIMECODE = (1 &lt;&lt; 13)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG2_EXPORT_MVS">
            <summary>AV_CODEC_FLAG2_EXPORT_MVS = (1 &lt;&lt; 28)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG2_FAST">
            <summary>AV_CODEC_FLAG2_FAST = (1 &lt;&lt;  0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG2_IGNORE_CROP">
            <summary>AV_CODEC_FLAG2_IGNORE_CROP = (1 &lt;&lt; 16)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG2_LOCAL_HEADER">
            <summary>AV_CODEC_FLAG2_LOCAL_HEADER = (1 &lt;&lt;  3)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG2_NO_OUTPUT">
            <summary>AV_CODEC_FLAG2_NO_OUTPUT = (1 &lt;&lt;  2)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG2_RO_FLUSH_NOOP">
            <summary>AV_CODEC_FLAG2_RO_FLUSH_NOOP = (1 &lt;&lt; 30)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG2_SHOW_ALL">
            <summary>AV_CODEC_FLAG2_SHOW_ALL = (1 &lt;&lt; 22)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_FLAG2_SKIP_MANUAL">
            <summary>AV_CODEC_FLAG2_SKIP_MANUAL = (1 &lt;&lt; 29)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_PROP_BITMAP_SUB">
            <summary>AV_CODEC_PROP_BITMAP_SUB = (1 &lt;&lt; 16)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_PROP_INTRA_ONLY">
            <summary>AV_CODEC_PROP_INTRA_ONLY = (1 &lt;&lt; 0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_PROP_LOSSLESS">
            <summary>AV_CODEC_PROP_LOSSLESS = (1 &lt;&lt; 2)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_PROP_LOSSY">
            <summary>AV_CODEC_PROP_LOSSY = (1 &lt;&lt; 1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_PROP_REORDER">
            <summary>AV_CODEC_PROP_REORDER = (1 &lt;&lt; 3)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CODEC_PROP_TEXT_SUB">
            <summary>AV_CODEC_PROP_TEXT_SUB = (1 &lt;&lt; 17)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_3DNOW">
            <summary>AV_CPU_FLAG_3DNOW = 0x0004</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_3DNOWEXT">
            <summary>AV_CPU_FLAG_3DNOWEXT = 0x0020</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_AESNI">
            <summary>AV_CPU_FLAG_AESNI = 0x80000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_ALTIVEC">
            <summary>AV_CPU_FLAG_ALTIVEC = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_ARMV5TE">
            <summary>AV_CPU_FLAG_ARMV5TE = (1 &lt;&lt; 0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_ARMV6">
            <summary>AV_CPU_FLAG_ARMV6 = (1 &lt;&lt; 1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_ARMV6T2">
            <summary>AV_CPU_FLAG_ARMV6T2 = (1 &lt;&lt; 2)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_ARMV8">
            <summary>AV_CPU_FLAG_ARMV8 = (1 &lt;&lt; 6)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_ATOM">
            <summary>AV_CPU_FLAG_ATOM = 0x10000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_AVX">
            <summary>AV_CPU_FLAG_AVX = 0x4000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_AVX2">
            <summary>AV_CPU_FLAG_AVX2 = 0x8000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_AVX512">
            <summary>AV_CPU_FLAG_AVX512 = 0x100000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_AVXSLOW">
            <summary>AV_CPU_FLAG_AVXSLOW = 0x8000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_BMI1">
            <summary>AV_CPU_FLAG_BMI1 = 0x20000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_BMI2">
            <summary>AV_CPU_FLAG_BMI2 = 0x40000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_CMOV">
            <summary>AV_CPU_FLAG_CMOV = 0x1000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_FMA3">
            <summary>AV_CPU_FLAG_FMA3 = 0x10000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_FMA4">
            <summary>AV_CPU_FLAG_FMA4 = 0x0800</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_FORCE">
            <summary>AV_CPU_FLAG_FORCE = 0x80000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_MMX">
            <summary>AV_CPU_FLAG_MMX = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_MMX2">
            <summary>AV_CPU_FLAG_MMX2 = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_MMXEXT">
            <summary>AV_CPU_FLAG_MMXEXT = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_NEON">
            <summary>AV_CPU_FLAG_NEON = (1 &lt;&lt; 5)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_POWER8">
            <summary>AV_CPU_FLAG_POWER8 = 0x0004</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_SETEND">
            <summary>AV_CPU_FLAG_SETEND = (1 &lt;&lt;16)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_SSE">
            <summary>AV_CPU_FLAG_SSE = 0x0008</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_SSE2">
            <summary>AV_CPU_FLAG_SSE2 = 0x0010</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_SSE2SLOW">
            <summary>AV_CPU_FLAG_SSE2SLOW = 0x40000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_SSE3">
            <summary>AV_CPU_FLAG_SSE3 = 0x0040</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_SSE3SLOW">
            <summary>AV_CPU_FLAG_SSE3SLOW = 0x20000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_SSE4">
            <summary>AV_CPU_FLAG_SSE4 = 0x0100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_SSE42">
            <summary>AV_CPU_FLAG_SSE42 = 0x0200</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_SSSE3">
            <summary>AV_CPU_FLAG_SSSE3 = 0x0080</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_SSSE3SLOW">
            <summary>AV_CPU_FLAG_SSSE3SLOW = 0x4000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_VFP">
            <summary>AV_CPU_FLAG_VFP = (1 &lt;&lt; 3)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_VFP_VM">
            <summary>AV_CPU_FLAG_VFP_VM = (1 &lt;&lt; 7)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_VFPV3">
            <summary>AV_CPU_FLAG_VFPV3 = (1 &lt;&lt; 4)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_VSX">
            <summary>AV_CPU_FLAG_VSX = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_CPU_FLAG_XOP">
            <summary>AV_CPU_FLAG_XOP = 0x0400</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DICT_APPEND">
            <summary>AV_DICT_APPEND = 32</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DICT_DONT_OVERWRITE">
            <summary>AV_DICT_DONT_OVERWRITE = 16</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DICT_DONT_STRDUP_KEY">
            <summary>AV_DICT_DONT_STRDUP_KEY = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DICT_DONT_STRDUP_VAL">
            <summary>AV_DICT_DONT_STRDUP_VAL = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DICT_IGNORE_SUFFIX">
            <summary>AV_DICT_IGNORE_SUFFIX = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DICT_MATCH_CASE">
            <summary>AV_DICT_MATCH_CASE = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DICT_MULTIKEY">
            <summary>AV_DICT_MULTIKEY = 64</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_ATTACHED_PIC">
            <summary>AV_DISPOSITION_ATTACHED_PIC = 0x0400</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_CAPTIONS">
            <summary>AV_DISPOSITION_CAPTIONS = 0x10000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_CLEAN_EFFECTS">
            <summary>AV_DISPOSITION_CLEAN_EFFECTS = 0x0200</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_COMMENT">
            <summary>AV_DISPOSITION_COMMENT = 0x0008</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_DEFAULT">
            <summary>AV_DISPOSITION_DEFAULT = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_DEPENDENT">
            <summary>AV_DISPOSITION_DEPENDENT = 0x80000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_DESCRIPTIONS">
            <summary>AV_DISPOSITION_DESCRIPTIONS = 0x20000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_DUB">
            <summary>AV_DISPOSITION_DUB = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_FORCED">
            <summary>AV_DISPOSITION_FORCED = 0x0040</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_HEARING_IMPAIRED">
            <summary>AV_DISPOSITION_HEARING_IMPAIRED = 0x0080</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_KARAOKE">
            <summary>AV_DISPOSITION_KARAOKE = 0x0020</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_LYRICS">
            <summary>AV_DISPOSITION_LYRICS = 0x0010</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_METADATA">
            <summary>AV_DISPOSITION_METADATA = 0x40000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_ORIGINAL">
            <summary>AV_DISPOSITION_ORIGINAL = 0x0004</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_STILL_IMAGE">
            <summary>AV_DISPOSITION_STILL_IMAGE = 0x100000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_TIMED_THUMBNAILS">
            <summary>AV_DISPOSITION_TIMED_THUMBNAILS = 0x0800</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_DISPOSITION_VISUAL_IMPAIRED">
            <summary>AV_DISPOSITION_VISUAL_IMPAIRED = 0x0100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_EF_AGGRESSIVE">
            <summary>AV_EF_AGGRESSIVE = (1&lt;&lt;18)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_EF_BITSTREAM">
            <summary>AV_EF_BITSTREAM = (1&lt;&lt;1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_EF_BUFFER">
            <summary>AV_EF_BUFFER = (1&lt;&lt;2)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_EF_CAREFUL">
            <summary>AV_EF_CAREFUL = (1&lt;&lt;16)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_EF_COMPLIANT">
            <summary>AV_EF_COMPLIANT = (1&lt;&lt;17)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_EF_CRCCHECK">
            <summary>AV_EF_CRCCHECK = (1&lt;&lt;0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_EF_EXPLODE">
            <summary>AV_EF_EXPLODE = (1&lt;&lt;3)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_EF_IGNORE_ERR">
            <summary>AV_EF_IGNORE_ERR = (1&lt;&lt;15)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_ERROR_MAX_STRING_SIZE">
            <summary>AV_ERROR_MAX_STRING_SIZE = 64</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_FOURCC_MAX_STRING_SIZE">
            <summary>AV_FOURCC_MAX_STRING_SIZE = 32</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_FRAME_FILENAME_FLAGS_MULTIPLE">
            <summary>AV_FRAME_FILENAME_FLAGS_MULTIPLE = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_FRAME_FLAG_CORRUPT">
            <summary>AV_FRAME_FLAG_CORRUPT = (1 &lt;&lt; 0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_FRAME_FLAG_DISCARD">
            <summary>AV_FRAME_FLAG_DISCARD = (1 &lt;&lt; 2)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_GET_BUFFER_FLAG_REF">
            <summary>AV_GET_BUFFER_FLAG_REF = (1 &lt;&lt; 0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_HAVE_BIGENDIAN">
            <summary>AV_HAVE_BIGENDIAN = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_HAVE_FAST_UNALIGNED">
            <summary>AV_HAVE_FAST_UNALIGNED = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_HWACCEL_CODEC_CAP_EXPERIMENTAL">
            <summary>AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = 0x0200</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH">
            <summary>AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH = (1 &lt;&lt; 1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH">
            <summary>AV_HWACCEL_FLAG_ALLOW_PROFILE_MISMATCH = (1 &lt;&lt; 2)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_HWACCEL_FLAG_IGNORE_LEVEL">
            <summary>AV_HWACCEL_FLAG_IGNORE_LEVEL = (1 &lt;&lt; 0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_INPUT_BUFFER_MIN_SIZE">
            <summary>AV_INPUT_BUFFER_MIN_SIZE = 16384</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_INPUT_BUFFER_PADDING_SIZE">
            <summary>AV_INPUT_BUFFER_PADDING_SIZE = 64</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_DEBUG">
            <summary>AV_LOG_DEBUG = 48</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_ERROR">
            <summary>AV_LOG_ERROR = 16</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_FATAL">
            <summary>AV_LOG_FATAL = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_INFO">
            <summary>AV_LOG_INFO = 32</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_MAX_OFFSET">
            <summary>AV_LOG_MAX_OFFSET = (AV_LOG_TRACE - AV_LOG_QUIET)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_PANIC">
            <summary>AV_LOG_PANIC = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_PRINT_LEVEL">
            <summary>AV_LOG_PRINT_LEVEL = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_QUIET">
            <summary>AV_LOG_QUIET = -8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_SKIP_REPEATED">
            <summary>AV_LOG_SKIP_REPEATED = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_TRACE">
            <summary>AV_LOG_TRACE = 56</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_VERBOSE">
            <summary>AV_LOG_VERBOSE = 40</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_LOG_WARNING">
            <summary>AV_LOG_WARNING = 24</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_NOPTS_VALUE">
            <summary>AV_NOPTS_VALUE = ((int64_t)UINT64_C(0x8000000000000000))</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_NUM_DATA_POINTERS">
            <summary>AV_NUM_DATA_POINTERS = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_ALLOW_NULL">
            <summary>AV_OPT_ALLOW_NULL = (1 &lt;&lt; 2)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_AUDIO_PARAM">
            <summary>AV_OPT_FLAG_AUDIO_PARAM = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_BSF_PARAM">
            <summary>AV_OPT_FLAG_BSF_PARAM = (1&lt;&lt;8)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_CHILD_CONSTS">
            <summary>AV_OPT_FLAG_CHILD_CONSTS = (1&lt;&lt;18)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_DECODING_PARAM">
            <summary>AV_OPT_FLAG_DECODING_PARAM = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_DEPRECATED">
            <summary>AV_OPT_FLAG_DEPRECATED = (1&lt;&lt;17)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_ENCODING_PARAM">
            <summary>AV_OPT_FLAG_ENCODING_PARAM = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_EXPORT">
            <summary>AV_OPT_FLAG_EXPORT = 64</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_FILTERING_PARAM">
            <summary>AV_OPT_FLAG_FILTERING_PARAM = (1&lt;&lt;16)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_READONLY">
            <summary>AV_OPT_FLAG_READONLY = 128</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_RUNTIME_PARAM">
            <summary>AV_OPT_FLAG_RUNTIME_PARAM = (1&lt;&lt;15)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_SUBTITLE_PARAM">
            <summary>AV_OPT_FLAG_SUBTITLE_PARAM = 32</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_FLAG_VIDEO_PARAM">
            <summary>AV_OPT_FLAG_VIDEO_PARAM = 16</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_MULTI_COMPONENT_RANGE">
            <summary>AV_OPT_MULTI_COMPONENT_RANGE = (1 &lt;&lt; 12)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_SEARCH_CHILDREN">
            <summary>AV_OPT_SEARCH_CHILDREN = (1 &lt;&lt; 0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_SEARCH_FAKE_OBJ">
            <summary>AV_OPT_SEARCH_FAKE_OBJ = (1 &lt;&lt; 1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_SERIALIZE_OPT_FLAGS_EXACT">
            <summary>AV_OPT_SERIALIZE_OPT_FLAGS_EXACT = 0x00000002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_OPT_SERIALIZE_SKIP_DEFAULTS">
            <summary>AV_OPT_SERIALIZE_SKIP_DEFAULTS = 0x00000001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PARSER_PTS_NB">
            <summary>AV_PARSER_PTS_NB = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PIX_FMT_FLAG_ALPHA">
            <summary>AV_PIX_FMT_FLAG_ALPHA = 0x1 &lt;&lt; 0x7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PIX_FMT_FLAG_BAYER">
            <summary>AV_PIX_FMT_FLAG_BAYER = 0x1 &lt;&lt; 0x8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PIX_FMT_FLAG_BE">
            <summary>AV_PIX_FMT_FLAG_BE = 0x1 &lt;&lt; 0x0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PIX_FMT_FLAG_BITSTREAM">
            <summary>AV_PIX_FMT_FLAG_BITSTREAM = 0x1 &lt;&lt; 0x2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PIX_FMT_FLAG_FLOAT">
            <summary>AV_PIX_FMT_FLAG_FLOAT = 0x1 &lt;&lt; 0x9</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PIX_FMT_FLAG_HWACCEL">
            <summary>AV_PIX_FMT_FLAG_HWACCEL = 0x1 &lt;&lt; 0x3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PIX_FMT_FLAG_PAL">
            <summary>AV_PIX_FMT_FLAG_PAL = 0x1 &lt;&lt; 0x1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PIX_FMT_FLAG_PLANAR">
            <summary>AV_PIX_FMT_FLAG_PLANAR = 0x1 &lt;&lt; 0x4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PIX_FMT_FLAG_PSEUDOPAL">
            <summary>AV_PIX_FMT_FLAG_PSEUDOPAL = 0x1 &lt;&lt; 0x6</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PIX_FMT_FLAG_RGB">
            <summary>AV_PIX_FMT_FLAG_RGB = 0x1 &lt;&lt; 0x5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PKT_FLAG_CORRUPT">
            <summary>AV_PKT_FLAG_CORRUPT = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PKT_FLAG_DISCARD">
            <summary>AV_PKT_FLAG_DISCARD = 0x0004</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PKT_FLAG_DISPOSABLE">
            <summary>AV_PKT_FLAG_DISPOSABLE = 0x0010</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PKT_FLAG_KEY">
            <summary>AV_PKT_FLAG_KEY = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PKT_FLAG_TRUSTED">
            <summary>AV_PKT_FLAG_TRUSTED = 0x0008</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PROGRAM_RUNNING">
            <summary>AV_PROGRAM_RUNNING = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PTS_WRAP_ADD_OFFSET">
            <summary>AV_PTS_WRAP_ADD_OFFSET = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PTS_WRAP_IGNORE">
            <summary>AV_PTS_WRAP_IGNORE = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_PTS_WRAP_SUB_OFFSET">
            <summary>AV_PTS_WRAP_SUB_OFFSET = -1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_SUBTITLE_FLAG_FORCED">
            <summary>AV_SUBTITLE_FLAG_FORCED = 0x00000001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_TIME_BASE">
            <summary>AV_TIME_BASE = 1000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AV_TIMECODE_STR_SIZE">
            <summary>AV_TIMECODE_STR_SIZE = 0x17</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_BSF_NOT_FOUND">
            <summary>AVERROR_BSF_NOT_FOUND = FFERRTAG(0xF8,&apos;B&apos;,&apos;S&apos;,&apos;F&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_BUFFER_TOO_SMALL">
            <summary>AVERROR_BUFFER_TOO_SMALL = FFERRTAG( &apos;B&apos;,&apos;U&apos;,&apos;F&apos;,&apos;S&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_BUG">
            <summary>AVERROR_BUG = FFERRTAG( &apos;B&apos;,&apos;U&apos;,&apos;G&apos;,&apos;!&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_BUG2">
            <summary>AVERROR_BUG2 = FFERRTAG( &apos;B&apos;,&apos;U&apos;,&apos;G&apos;,&apos; &apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_DECODER_NOT_FOUND">
            <summary>AVERROR_DECODER_NOT_FOUND = FFERRTAG(0xF8,&apos;D&apos;,&apos;E&apos;,&apos;C&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_DEMUXER_NOT_FOUND">
            <summary>AVERROR_DEMUXER_NOT_FOUND = FFERRTAG(0xF8,&apos;D&apos;,&apos;E&apos;,&apos;M&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_ENCODER_NOT_FOUND">
            <summary>AVERROR_ENCODER_NOT_FOUND = FFERRTAG(0xF8,&apos;E&apos;,&apos;N&apos;,&apos;C&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_EOF">
            <summary>AVERROR_EOF = FFERRTAG( &apos;E&apos;,&apos;O&apos;,&apos;F&apos;,&apos; &apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_EXIT">
            <summary>AVERROR_EXIT = FFERRTAG( &apos;E&apos;,&apos;X&apos;,&apos;I&apos;,&apos;T&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_EXPERIMENTAL">
            <summary>AVERROR_EXPERIMENTAL = (-0x2bb2afa8)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_EXTERNAL">
            <summary>AVERROR_EXTERNAL = FFERRTAG( &apos;E&apos;,&apos;X&apos;,&apos;T&apos;,&apos; &apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_FILTER_NOT_FOUND">
            <summary>AVERROR_FILTER_NOT_FOUND = FFERRTAG(0xF8,&apos;F&apos;,&apos;I&apos;,&apos;L&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_HTTP_BAD_REQUEST">
            <summary>AVERROR_HTTP_BAD_REQUEST = FFERRTAG(0xF8,&apos;4&apos;,&apos;0&apos;,&apos;0&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_HTTP_FORBIDDEN">
            <summary>AVERROR_HTTP_FORBIDDEN = FFERRTAG(0xF8,&apos;4&apos;,&apos;0&apos;,&apos;3&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_HTTP_NOT_FOUND">
            <summary>AVERROR_HTTP_NOT_FOUND = FFERRTAG(0xF8,&apos;4&apos;,&apos;0&apos;,&apos;4&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_HTTP_OTHER_4XX">
            <summary>AVERROR_HTTP_OTHER_4XX = FFERRTAG(0xF8,&apos;4&apos;,&apos;X&apos;,&apos;X&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_HTTP_SERVER_ERROR">
            <summary>AVERROR_HTTP_SERVER_ERROR = FFERRTAG(0xF8,&apos;5&apos;,&apos;X&apos;,&apos;X&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_HTTP_UNAUTHORIZED">
            <summary>AVERROR_HTTP_UNAUTHORIZED = FFERRTAG(0xF8,&apos;4&apos;,&apos;0&apos;,&apos;1&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_INPUT_CHANGED">
            <summary>AVERROR_INPUT_CHANGED = (-0x636e6701)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_INVALIDDATA">
            <summary>AVERROR_INVALIDDATA = FFERRTAG( &apos;I&apos;,&apos;N&apos;,&apos;D&apos;,&apos;A&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_MUXER_NOT_FOUND">
            <summary>AVERROR_MUXER_NOT_FOUND = FFERRTAG(0xF8,&apos;M&apos;,&apos;U&apos;,&apos;X&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_OPTION_NOT_FOUND">
            <summary>AVERROR_OPTION_NOT_FOUND = FFERRTAG(0xF8,&apos;O&apos;,&apos;P&apos;,&apos;T&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_OUTPUT_CHANGED">
            <summary>AVERROR_OUTPUT_CHANGED = (-0x636e6702)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_PATCHWELCOME">
            <summary>AVERROR_PATCHWELCOME = FFERRTAG( &apos;P&apos;,&apos;A&apos;,&apos;W&apos;,&apos;E&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_PROTOCOL_NOT_FOUND">
            <summary>AVERROR_PROTOCOL_NOT_FOUND = FFERRTAG(0xF8,&apos;P&apos;,&apos;R&apos;,&apos;O&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_STREAM_NOT_FOUND">
            <summary>AVERROR_STREAM_NOT_FOUND = FFERRTAG(0xF8,&apos;S&apos;,&apos;T&apos;,&apos;R&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVERROR_UNKNOWN">
            <summary>AVERROR_UNKNOWN = FFERRTAG( &apos;U&apos;,&apos;N&apos;,&apos;K&apos;,&apos;N&apos;)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFILTER_CMD_FLAG_FAST">
            <summary>AVFILTER_CMD_FLAG_FAST = 0x2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFILTER_CMD_FLAG_ONE">
            <summary>AVFILTER_CMD_FLAG_ONE = 0x1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFILTER_FLAG_DYNAMIC_INPUTS">
            <summary>AVFILTER_FLAG_DYNAMIC_INPUTS = 0x1 &lt;&lt; 0x0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFILTER_FLAG_DYNAMIC_OUTPUTS">
            <summary>AVFILTER_FLAG_DYNAMIC_OUTPUTS = 0x1 &lt;&lt; 0x1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFILTER_FLAG_SLICE_THREADS">
            <summary>AVFILTER_FLAG_SLICE_THREADS = 0x1 &lt;&lt; 0x2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFILTER_FLAG_SUPPORT_TIMELINE">
            <summary>AVFILTER_FLAG_SUPPORT_TIMELINE = AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC | AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC">
            <summary>AVFILTER_FLAG_SUPPORT_TIMELINE_GENERIC = 0x1 &lt;&lt; 0x10</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL">
            <summary>AVFILTER_FLAG_SUPPORT_TIMELINE_INTERNAL = 0x1 &lt;&lt; 0x11</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFILTER_THREAD_SLICE">
            <summary>AVFILTER_THREAD_SLICE = 0x1 &lt;&lt; 0x0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_ALLOW_FLUSH">
            <summary>AVFMT_ALLOW_FLUSH = 0x10000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_AVOID_NEG_TS_AUTO">
            <summary>AVFMT_AVOID_NEG_TS_AUTO = -1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE">
            <summary>AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_AVOID_NEG_TS_MAKE_ZERO">
            <summary>AVFMT_AVOID_NEG_TS_MAKE_ZERO = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_EVENT_FLAG_METADATA_UPDATED">
            <summary>AVFMT_EVENT_FLAG_METADATA_UPDATED = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_AUTO_BSF">
            <summary>AVFMT_FLAG_AUTO_BSF = 0x200000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_BITEXACT">
            <summary>AVFMT_FLAG_BITEXACT = 0x0400</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_CUSTOM_IO">
            <summary>AVFMT_FLAG_CUSTOM_IO = 0x0080</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_DISCARD_CORRUPT">
            <summary>AVFMT_FLAG_DISCARD_CORRUPT = 0x0100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_FAST_SEEK">
            <summary>AVFMT_FLAG_FAST_SEEK = 0x80000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_FLUSH_PACKETS">
            <summary>AVFMT_FLAG_FLUSH_PACKETS = 0x0200</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_GENPTS">
            <summary>AVFMT_FLAG_GENPTS = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_IGNDTS">
            <summary>AVFMT_FLAG_IGNDTS = 0x0008</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_IGNIDX">
            <summary>AVFMT_FLAG_IGNIDX = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_KEEP_SIDE_DATA">
            <summary>AVFMT_FLAG_KEEP_SIDE_DATA = 0x40000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_MP4A_LATM">
            <summary>AVFMT_FLAG_MP4A_LATM = 0x8000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_NOBUFFER">
            <summary>AVFMT_FLAG_NOBUFFER = 0x0040</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_NOFILLIN">
            <summary>AVFMT_FLAG_NOFILLIN = 0x0010</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_NONBLOCK">
            <summary>AVFMT_FLAG_NONBLOCK = 0x0004</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_NOPARSE">
            <summary>AVFMT_FLAG_NOPARSE = 0x0020</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_PRIV_OPT">
            <summary>AVFMT_FLAG_PRIV_OPT = 0x20000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_SHORTEST">
            <summary>AVFMT_FLAG_SHORTEST = 0x100000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_FLAG_SORT_DTS">
            <summary>AVFMT_FLAG_SORT_DTS = 0x10000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_GENERIC_INDEX">
            <summary>AVFMT_GENERIC_INDEX = 0x0100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_GLOBALHEADER">
            <summary>AVFMT_GLOBALHEADER = 0x0040</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_NEEDNUMBER">
            <summary>AVFMT_NEEDNUMBER = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_NO_BYTE_SEEK">
            <summary>AVFMT_NO_BYTE_SEEK = 0x8000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_NOBINSEARCH">
            <summary>AVFMT_NOBINSEARCH = 0x2000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_NODIMENSIONS">
            <summary>AVFMT_NODIMENSIONS = 0x0800</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_NOFILE">
            <summary>AVFMT_NOFILE = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_NOGENSEARCH">
            <summary>AVFMT_NOGENSEARCH = 0x4000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_NOSTREAMS">
            <summary>AVFMT_NOSTREAMS = 0x1000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_NOTIMESTAMPS">
            <summary>AVFMT_NOTIMESTAMPS = 0x0080</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_SEEK_TO_PTS">
            <summary>AVFMT_SEEK_TO_PTS = 0x4000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_SHOW_IDS">
            <summary>AVFMT_SHOW_IDS = 0x0008</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_TS_DISCONT">
            <summary>AVFMT_TS_DISCONT = 0x0200</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_TS_NEGATIVE">
            <summary>AVFMT_TS_NEGATIVE = 0x40000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_TS_NONSTRICT">
            <summary>AVFMT_TS_NONSTRICT = 0x20000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMT_VARIABLE_FPS">
            <summary>AVFMT_VARIABLE_FPS = 0x0400</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMTCTX_NOHEADER">
            <summary>AVFMTCTX_NOHEADER = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVFMTCTX_UNSEEKABLE">
            <summary>AVFMTCTX_UNSEEKABLE = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVINDEX_DISCARD_FRAME">
            <summary>AVINDEX_DISCARD_FRAME = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVINDEX_KEYFRAME">
            <summary>AVINDEX_KEYFRAME = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVIO_FLAG_DIRECT">
            <summary>AVIO_FLAG_DIRECT = 0x8000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVIO_FLAG_NONBLOCK">
            <summary>AVIO_FLAG_NONBLOCK = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVIO_FLAG_READ">
            <summary>AVIO_FLAG_READ = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVIO_FLAG_READ_WRITE">
            <summary>AVIO_FLAG_READ_WRITE = (AVIO_FLAG_READ|AVIO_FLAG_WRITE)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVIO_FLAG_WRITE">
            <summary>AVIO_FLAG_WRITE = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVIO_SEEKABLE_NORMAL">
            <summary>AVIO_SEEKABLE_NORMAL = (1 &lt;&lt; 0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVIO_SEEKABLE_TIME">
            <summary>AVIO_SEEKABLE_TIME = (1 &lt;&lt; 1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVPALETTE_COUNT">
            <summary>AVPALETTE_COUNT = 256</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVPALETTE_SIZE">
            <summary>AVPALETTE_SIZE = 1024</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVPROBE_PADDING_SIZE">
            <summary>AVPROBE_PADDING_SIZE = 32</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVPROBE_SCORE_EXTENSION">
            <summary>AVPROBE_SCORE_EXTENSION = 50</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVPROBE_SCORE_MAX">
            <summary>AVPROBE_SCORE_MAX = 100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVPROBE_SCORE_MIME">
            <summary>AVPROBE_SCORE_MIME = 75</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVPROBE_SCORE_RETRY">
            <summary>AVPROBE_SCORE_RETRY = (AVPROBE_SCORE_MAX/4)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVPROBE_SCORE_STREAM_RETRY">
            <summary>AVPROBE_SCORE_STREAM_RETRY = (AVPROBE_SCORE_MAX/4-1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVSEEK_FLAG_ANY">
            <summary>AVSEEK_FLAG_ANY = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVSEEK_FLAG_BACKWARD">
            <summary>AVSEEK_FLAG_BACKWARD = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVSEEK_FLAG_BYTE">
            <summary>AVSEEK_FLAG_BYTE = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVSEEK_FLAG_FRAME">
            <summary>AVSEEK_FLAG_FRAME = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVSEEK_FORCE">
            <summary>AVSEEK_FORCE = 0x20000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVSEEK_SIZE">
            <summary>AVSEEK_SIZE = 0x10000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVSTREAM_EVENT_FLAG_METADATA_UPDATED">
            <summary>AVSTREAM_EVENT_FLAG_METADATA_UPDATED = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVSTREAM_INIT_IN_INIT_OUTPUT">
            <summary>AVSTREAM_INIT_IN_INIT_OUTPUT = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.AVSTREAM_INIT_IN_WRITE_HEADER">
            <summary>AVSTREAM_INIT_IN_WRITE_HEADER = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_ASS_TIMING">
            <summary>FF_API_ASS_TIMING = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_AVCTX_TIMEBASE">
            <summary>FF_API_AVCTX_TIMEBASE = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_AVIOFORMAT">
            <summary>FF_API_AVIOFORMAT = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_AVPACKET_OLD_API">
            <summary>FF_API_AVPACKET_OLD_API = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_AVPICTURE">
            <summary>FF_API_AVPICTURE = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_CODEC_GET_SET">
            <summary>FF_API_CODEC_GET_SET = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_CODED_FRAME">
            <summary>FF_API_CODED_FRAME = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_CODER_TYPE">
            <summary>FF_API_CODER_TYPE = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_COMPUTE_PKT_FIELDS2">
            <summary>FF_API_COMPUTE_PKT_FIELDS2 = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_CONVERGENCE_DURATION">
            <summary>FF_API_CONVERGENCE_DURATION = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_COPY_CONTEXT">
            <summary>FF_API_COPY_CONTEXT = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_CRYPTO_SIZE_T">
            <summary>FF_API_CRYPTO_SIZE_T = (LIBAVUTIL_VERSION_MAJOR &lt; 57)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_DASH_MIN_SEG_DURATION">
            <summary>FF_API_DASH_MIN_SEG_DURATION = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_DEBUG_MV">
            <summary>FF_API_DEBUG_MV = (LIBAVCODEC_VERSION_MAJOR &lt; 58)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_ERROR_FRAME">
            <summary>FF_API_ERROR_FRAME = (LIBAVUTIL_VERSION_MAJOR &lt; 57)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_FILTER_GET_SET">
            <summary>FF_API_FILTER_GET_SET = LIBAVFILTER_VERSION_MAJOR &lt; 0x8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_FORMAT_FILENAME">
            <summary>FF_API_FORMAT_FILENAME = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_FORMAT_GET_SET">
            <summary>FF_API_FORMAT_GET_SET = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_FRAME_GET_SET">
            <summary>FF_API_FRAME_GET_SET = (LIBAVUTIL_VERSION_MAJOR &lt; 57)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_FRAME_QP">
            <summary>FF_API_FRAME_QP = (LIBAVUTIL_VERSION_MAJOR &lt; 57)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_GET_CONTEXT_DEFAULTS">
            <summary>FF_API_GET_CONTEXT_DEFAULTS = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_GETCHROMA">
            <summary>FF_API_GETCHROMA = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_HLS_USE_LOCALTIME">
            <summary>FF_API_HLS_USE_LOCALTIME = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_HLS_WRAP">
            <summary>FF_API_HLS_WRAP = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_HTTP_USER_AGENT">
            <summary>FF_API_HTTP_USER_AGENT = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_LAVF_AVCTX">
            <summary>FF_API_LAVF_AVCTX = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_LAVF_FFSERVER">
            <summary>FF_API_LAVF_FFSERVER = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_LAVF_KEEPSIDE_FLAG">
            <summary>FF_API_LAVF_KEEPSIDE_FLAG = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_LAVF_MP4A_LATM">
            <summary>FF_API_LAVF_MP4A_LATM = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_LAVR_OPTS">
            <summary>FF_API_LAVR_OPTS = LIBAVFILTER_VERSION_MAJOR &lt; 0x8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_LOCKMGR">
            <summary>FF_API_LOCKMGR = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_LOWRES">
            <summary>FF_API_LOWRES = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_MERGE_SD_API">
            <summary>FF_API_MERGE_SD_API = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_NEXT">
            <summary>FF_API_NEXT = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_NVENC_OLD_NAME">
            <summary>FF_API_NVENC_OLD_NAME = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_OLD_AVIO_EOF_0">
            <summary>FF_API_OLD_AVIO_EOF_0 = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_OLD_BSF">
            <summary>FF_API_OLD_BSF = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_OLD_FILTER_OPTS_ERROR">
            <summary>FF_API_OLD_FILTER_OPTS_ERROR = LIBAVFILTER_VERSION_MAJOR &lt; 0x8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_OLD_OPEN_CALLBACKS">
            <summary>FF_API_OLD_OPEN_CALLBACKS = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_OLD_ROTATE_API">
            <summary>FF_API_OLD_ROTATE_API = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_OLD_RTSP_OPTIONS">
            <summary>FF_API_OLD_RTSP_OPTIONS = (LIBAVFORMAT_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_OPENH264_CABAC">
            <summary>FF_API_OPENH264_CABAC = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_OPENH264_SLICE_MODE">
            <summary>FF_API_OPENH264_SLICE_MODE = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_PKT_PTS">
            <summary>FF_API_PKT_PTS = (LIBAVUTIL_VERSION_MAJOR &lt; 57)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_PLUS1_MINUS1">
            <summary>FF_API_PLUS1_MINUS1 = (LIBAVUTIL_VERSION_MAJOR &lt; 57)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_PRIVATE_OPT">
            <summary>FF_API_PRIVATE_OPT = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_PSEUDOPAL">
            <summary>FF_API_PSEUDOPAL = (LIBAVUTIL_VERSION_MAJOR &lt; 57)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_R_FRAME_RATE">
            <summary>FF_API_R_FRAME_RATE = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_RTP_CALLBACK">
            <summary>FF_API_RTP_CALLBACK = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_SIDEDATA_ONLY_PKT">
            <summary>FF_API_SIDEDATA_ONLY_PKT = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_STAT_BITS">
            <summary>FF_API_STAT_BITS = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_STRUCT_VAAPI_CONTEXT">
            <summary>FF_API_STRUCT_VAAPI_CONTEXT = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_SWS_PARAM_OPTION">
            <summary>FF_API_SWS_PARAM_OPTION = LIBAVFILTER_VERSION_MAJOR &lt; 0x8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_SWS_VECTOR">
            <summary>FF_API_SWS_VECTOR = LIBSWSCALE_VERSION_MAJOR &lt; 0x6</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_TAG_STRING">
            <summary>FF_API_TAG_STRING = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_UNSANITIZED_BITRATES">
            <summary>FF_API_UNSANITIZED_BITRATES = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_UNUSED_CODEC_CAPS">
            <summary>FF_API_UNUSED_CODEC_CAPS = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_USER_VISIBLE_AVHWACCEL">
            <summary>FF_API_USER_VISIBLE_AVHWACCEL = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_VAAPI">
            <summary>FF_API_VAAPI = (LIBAVUTIL_VERSION_MAJOR &lt; 57)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_VBV_DELAY">
            <summary>FF_API_VBV_DELAY = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_API_VDPAU_PROFILE">
            <summary>FF_API_VDPAU_PROFILE = (LIBAVCODEC_VERSION_MAJOR &lt; 59)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_AMV">
            <summary>FF_BUG_AMV = 32</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_AUTODETECT">
            <summary>FF_BUG_AUTODETECT = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_DC_CLIP">
            <summary>FF_BUG_DC_CLIP = 4096</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_DIRECT_BLOCKSIZE">
            <summary>FF_BUG_DIRECT_BLOCKSIZE = 512</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_EDGE">
            <summary>FF_BUG_EDGE = 1024</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_HPEL_CHROMA">
            <summary>FF_BUG_HPEL_CHROMA = 2048</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_IEDGE">
            <summary>FF_BUG_IEDGE = 32768</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_MS">
            <summary>FF_BUG_MS = 8192</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_NO_PADDING">
            <summary>FF_BUG_NO_PADDING = 16</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_QPEL_CHROMA">
            <summary>FF_BUG_QPEL_CHROMA = 64</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_QPEL_CHROMA2">
            <summary>FF_BUG_QPEL_CHROMA2 = 256</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_STD_QPEL">
            <summary>FF_BUG_STD_QPEL = 128</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_TRUNCATED">
            <summary>FF_BUG_TRUNCATED = 16384</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_UMP4">
            <summary>FF_BUG_UMP4 = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_BUG_XVID_ILACE">
            <summary>FF_BUG_XVID_ILACE = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_BIT">
            <summary>FF_CMP_BIT = 5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_CHROMA">
            <summary>FF_CMP_CHROMA = 256</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_DCT">
            <summary>FF_CMP_DCT = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_DCT264">
            <summary>FF_CMP_DCT264 = 14</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_DCTMAX">
            <summary>FF_CMP_DCTMAX = 13</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_MEDIAN_SAD">
            <summary>FF_CMP_MEDIAN_SAD = 15</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_NSSE">
            <summary>FF_CMP_NSSE = 10</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_PSNR">
            <summary>FF_CMP_PSNR = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_RD">
            <summary>FF_CMP_RD = 6</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_SAD">
            <summary>FF_CMP_SAD = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_SATD">
            <summary>FF_CMP_SATD = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_SSE">
            <summary>FF_CMP_SSE = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_VSAD">
            <summary>FF_CMP_VSAD = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_VSSE">
            <summary>FF_CMP_VSSE = 9</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_W53">
            <summary>FF_CMP_W53 = 11</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_W97">
            <summary>FF_CMP_W97 = 12</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CMP_ZERO">
            <summary>FF_CMP_ZERO = 7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CODEC_PROPERTY_CLOSED_CAPTIONS">
            <summary>FF_CODEC_PROPERTY_CLOSED_CAPTIONS = 0x00000002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CODEC_PROPERTY_LOSSLESS">
            <summary>FF_CODEC_PROPERTY_LOSSLESS = 0x00000001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CODER_TYPE_AC">
            <summary>FF_CODER_TYPE_AC = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CODER_TYPE_RAW">
            <summary>FF_CODER_TYPE_RAW = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CODER_TYPE_RLE">
            <summary>FF_CODER_TYPE_RLE = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_CODER_TYPE_VLC">
            <summary>FF_CODER_TYPE_VLC = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_COMPLIANCE_EXPERIMENTAL">
            <summary>FF_COMPLIANCE_EXPERIMENTAL = -2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_COMPLIANCE_NORMAL">
            <summary>FF_COMPLIANCE_NORMAL = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_COMPLIANCE_STRICT">
            <summary>FF_COMPLIANCE_STRICT = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_COMPLIANCE_UNOFFICIAL">
            <summary>FF_COMPLIANCE_UNOFFICIAL = -1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_COMPLIANCE_VERY_STRICT">
            <summary>FF_COMPLIANCE_VERY_STRICT = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_COMPRESSION_DEFAULT">
            <summary>FF_COMPRESSION_DEFAULT = -1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DCT_ALTIVEC">
            <summary>FF_DCT_ALTIVEC = 5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DCT_AUTO">
            <summary>FF_DCT_AUTO = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DCT_FAAN">
            <summary>FF_DCT_FAAN = 6</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DCT_FASTINT">
            <summary>FF_DCT_FASTINT = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DCT_INT">
            <summary>FF_DCT_INT = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DCT_MMX">
            <summary>FF_DCT_MMX = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_BITSTREAM">
            <summary>FF_DEBUG_BITSTREAM = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_BUFFERS">
            <summary>FF_DEBUG_BUFFERS = 0x00008000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_BUGS">
            <summary>FF_DEBUG_BUGS = 0x00001000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_DCT_COEFF">
            <summary>FF_DEBUG_DCT_COEFF = 0x00000040</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_ER">
            <summary>FF_DEBUG_ER = 0x00000400</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_GREEN_MD">
            <summary>FF_DEBUG_GREEN_MD = 0x00800000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_MB_TYPE">
            <summary>FF_DEBUG_MB_TYPE = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_MMCO">
            <summary>FF_DEBUG_MMCO = 0x00000800</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_NOMC">
            <summary>FF_DEBUG_NOMC = 0x01000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_PICT_INFO">
            <summary>FF_DEBUG_PICT_INFO = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_QP">
            <summary>FF_DEBUG_QP = 16</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_RC">
            <summary>FF_DEBUG_RC = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_SKIP">
            <summary>FF_DEBUG_SKIP = 0x00000080</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_STARTCODE">
            <summary>FF_DEBUG_STARTCODE = 0x00000100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_THREADS">
            <summary>FF_DEBUG_THREADS = 0x00010000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_VIS_MV_B_BACK">
            <summary>FF_DEBUG_VIS_MV_B_BACK = 0x00000004</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_VIS_MV_B_FOR">
            <summary>FF_DEBUG_VIS_MV_B_FOR = 0x00000002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DEBUG_VIS_MV_P_FOR">
            <summary>FF_DEBUG_VIS_MV_P_FOR = 0x00000001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DECODE_ERROR_CONCEALMENT_ACTIVE">
            <summary>FF_DECODE_ERROR_CONCEALMENT_ACTIVE = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DECODE_ERROR_DECODE_SLICES">
            <summary>FF_DECODE_ERROR_DECODE_SLICES = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DECODE_ERROR_INVALID_BITSTREAM">
            <summary>FF_DECODE_ERROR_INVALID_BITSTREAM = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DECODE_ERROR_MISSING_REFERENCE">
            <summary>FF_DECODE_ERROR_MISSING_REFERENCE = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DXVA2_WORKAROUND_INTEL_CLEARVIDEO">
            <summary>FF_DXVA2_WORKAROUND_INTEL_CLEARVIDEO = 0x2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG">
            <summary>FF_DXVA2_WORKAROUND_SCALING_LIST_ZIGZAG = 0x1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_EC_DEBLOCK">
            <summary>FF_EC_DEBLOCK = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_EC_FAVOR_INTER">
            <summary>FF_EC_FAVOR_INTER = 256</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_EC_GUESS_MVS">
            <summary>FF_EC_GUESS_MVS = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_FDEBUG_TS">
            <summary>FF_FDEBUG_TS = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_ALTIVEC">
            <summary>FF_IDCT_ALTIVEC = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_ARM">
            <summary>FF_IDCT_ARM = 7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_AUTO">
            <summary>FF_IDCT_AUTO = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_FAAN">
            <summary>FF_IDCT_FAAN = 20</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_INT">
            <summary>FF_IDCT_INT = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_NONE">
            <summary>FF_IDCT_NONE = 24</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_SIMPLE">
            <summary>FF_IDCT_SIMPLE = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_SIMPLEARM">
            <summary>FF_IDCT_SIMPLEARM = 10</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_SIMPLEARMV5TE">
            <summary>FF_IDCT_SIMPLEARMV5TE = 16</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_SIMPLEARMV6">
            <summary>FF_IDCT_SIMPLEARMV6 = 17</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_SIMPLEAUTO">
            <summary>FF_IDCT_SIMPLEAUTO = 128</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_SIMPLEMMX">
            <summary>FF_IDCT_SIMPLEMMX = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_SIMPLENEON">
            <summary>FF_IDCT_SIMPLENEON = 22</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_IDCT_XVID">
            <summary>FF_IDCT_XVID = 14</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_LAMBDA_MAX">
            <summary>FF_LAMBDA_MAX = (256*128-1)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_LAMBDA_SCALE">
            <summary>FF_LAMBDA_SCALE = (1&lt;&lt;FF_LAMBDA_SHIFT)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_LAMBDA_SHIFT">
            <summary>FF_LAMBDA_SHIFT = 7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_LEVEL_UNKNOWN">
            <summary>FF_LEVEL_UNKNOWN = -99</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_LOSS_ALPHA">
            <summary>FF_LOSS_ALPHA = 0x8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_LOSS_CHROMA">
            <summary>FF_LOSS_CHROMA = 0x20</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_LOSS_COLORQUANT">
            <summary>FF_LOSS_COLORQUANT = 0x10</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_LOSS_COLORSPACE">
            <summary>FF_LOSS_COLORSPACE = 0x4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_LOSS_DEPTH">
            <summary>FF_LOSS_DEPTH = 0x2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_LOSS_RESOLUTION">
            <summary>FF_LOSS_RESOLUTION = 0x1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_MB_DECISION_BITS">
            <summary>FF_MB_DECISION_BITS = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_MB_DECISION_RD">
            <summary>FF_MB_DECISION_RD = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_MB_DECISION_SIMPLE">
            <summary>FF_MB_DECISION_SIMPLE = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PRED_LEFT">
            <summary>FF_PRED_LEFT = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PRED_MEDIAN">
            <summary>FF_PRED_MEDIAN = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PRED_PLANE">
            <summary>FF_PRED_PLANE = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AAC_ELD">
            <summary>FF_PROFILE_AAC_ELD = 38</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AAC_HE">
            <summary>FF_PROFILE_AAC_HE = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AAC_HE_V2">
            <summary>FF_PROFILE_AAC_HE_V2 = 28</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AAC_LD">
            <summary>FF_PROFILE_AAC_LD = 22</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AAC_LOW">
            <summary>FF_PROFILE_AAC_LOW = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AAC_LTP">
            <summary>FF_PROFILE_AAC_LTP = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AAC_MAIN">
            <summary>FF_PROFILE_AAC_MAIN = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AAC_SSR">
            <summary>FF_PROFILE_AAC_SSR = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_ARIB_PROFILE_A">
            <summary>FF_PROFILE_ARIB_PROFILE_A = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_ARIB_PROFILE_C">
            <summary>FF_PROFILE_ARIB_PROFILE_C = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AV1_HIGH">
            <summary>FF_PROFILE_AV1_HIGH = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AV1_MAIN">
            <summary>FF_PROFILE_AV1_MAIN = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_AV1_PROFESSIONAL">
            <summary>FF_PROFILE_AV1_PROFESSIONAL = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DNXHD">
            <summary>FF_PROFILE_DNXHD = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DNXHR_444">
            <summary>FF_PROFILE_DNXHR_444 = 5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DNXHR_HQ">
            <summary>FF_PROFILE_DNXHR_HQ = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DNXHR_HQX">
            <summary>FF_PROFILE_DNXHR_HQX = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DNXHR_LB">
            <summary>FF_PROFILE_DNXHR_LB = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DNXHR_SQ">
            <summary>FF_PROFILE_DNXHR_SQ = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DTS">
            <summary>FF_PROFILE_DTS = 20</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DTS_96_24">
            <summary>FF_PROFILE_DTS_96_24 = 40</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DTS_ES">
            <summary>FF_PROFILE_DTS_ES = 30</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DTS_EXPRESS">
            <summary>FF_PROFILE_DTS_EXPRESS = 70</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DTS_HD_HRA">
            <summary>FF_PROFILE_DTS_HD_HRA = 50</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_DTS_HD_MA">
            <summary>FF_PROFILE_DTS_HD_MA = 60</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_BASELINE">
            <summary>FF_PROFILE_H264_BASELINE = 66</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_CAVLC_444">
            <summary>FF_PROFILE_H264_CAVLC_444 = 44</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_CONSTRAINED">
            <summary>FF_PROFILE_H264_CONSTRAINED = (1&lt;&lt;9)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_CONSTRAINED_BASELINE">
            <summary>FF_PROFILE_H264_CONSTRAINED_BASELINE = (66|FF_PROFILE_H264_CONSTRAINED)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_EXTENDED">
            <summary>FF_PROFILE_H264_EXTENDED = 88</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_HIGH">
            <summary>FF_PROFILE_H264_HIGH = 100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_HIGH_10">
            <summary>FF_PROFILE_H264_HIGH_10 = 110</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_HIGH_10_INTRA">
            <summary>FF_PROFILE_H264_HIGH_10_INTRA = (110|FF_PROFILE_H264_INTRA)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_HIGH_422">
            <summary>FF_PROFILE_H264_HIGH_422 = 122</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_HIGH_422_INTRA">
            <summary>FF_PROFILE_H264_HIGH_422_INTRA = (122|FF_PROFILE_H264_INTRA)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_HIGH_444">
            <summary>FF_PROFILE_H264_HIGH_444 = 144</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_HIGH_444_INTRA">
            <summary>FF_PROFILE_H264_HIGH_444_INTRA = (244|FF_PROFILE_H264_INTRA)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_HIGH_444_PREDICTIVE">
            <summary>FF_PROFILE_H264_HIGH_444_PREDICTIVE = 244</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_INTRA">
            <summary>FF_PROFILE_H264_INTRA = (1&lt;&lt;11)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_MAIN">
            <summary>FF_PROFILE_H264_MAIN = 77</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_MULTIVIEW_HIGH">
            <summary>FF_PROFILE_H264_MULTIVIEW_HIGH = 118</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_H264_STEREO_HIGH">
            <summary>FF_PROFILE_H264_STEREO_HIGH = 128</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_HEVC_MAIN">
            <summary>FF_PROFILE_HEVC_MAIN = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_HEVC_MAIN_10">
            <summary>FF_PROFILE_HEVC_MAIN_10 = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_HEVC_MAIN_STILL_PICTURE">
            <summary>FF_PROFILE_HEVC_MAIN_STILL_PICTURE = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_HEVC_REXT">
            <summary>FF_PROFILE_HEVC_REXT = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION">
            <summary>FF_PROFILE_JPEG2000_CSTREAM_NO_RESTRICTION = 32768</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0">
            <summary>FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_0 = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1">
            <summary>FF_PROFILE_JPEG2000_CSTREAM_RESTRICTION_1 = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_JPEG2000_DCINEMA_2K">
            <summary>FF_PROFILE_JPEG2000_DCINEMA_2K = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_JPEG2000_DCINEMA_4K">
            <summary>FF_PROFILE_JPEG2000_DCINEMA_4K = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_KLVA_ASYNC">
            <summary>FF_PROFILE_KLVA_ASYNC = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_KLVA_SYNC">
            <summary>FF_PROFILE_KLVA_SYNC = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT">
            <summary>FF_PROFILE_MJPEG_HUFFMAN_BASELINE_DCT = 0xc0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT">
            <summary>FF_PROFILE_MJPEG_HUFFMAN_EXTENDED_SEQUENTIAL_DCT = 0xc1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS">
            <summary>FF_PROFILE_MJPEG_HUFFMAN_LOSSLESS = 0xc3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT">
            <summary>FF_PROFILE_MJPEG_HUFFMAN_PROGRESSIVE_DCT = 0xc2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MJPEG_JPEG_LS">
            <summary>FF_PROFILE_MJPEG_JPEG_LS = 0xf7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG2_422">
            <summary>FF_PROFILE_MPEG2_422 = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG2_AAC_HE">
            <summary>FF_PROFILE_MPEG2_AAC_HE = 131</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG2_AAC_LOW">
            <summary>FF_PROFILE_MPEG2_AAC_LOW = 128</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG2_HIGH">
            <summary>FF_PROFILE_MPEG2_HIGH = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG2_MAIN">
            <summary>FF_PROFILE_MPEG2_MAIN = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG2_SIMPLE">
            <summary>FF_PROFILE_MPEG2_SIMPLE = 5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG2_SNR_SCALABLE">
            <summary>FF_PROFILE_MPEG2_SNR_SCALABLE = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG2_SS">
            <summary>FF_PROFILE_MPEG2_SS = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_ADVANCED_CODING">
            <summary>FF_PROFILE_MPEG4_ADVANCED_CODING = 11</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_ADVANCED_CORE">
            <summary>FF_PROFILE_MPEG4_ADVANCED_CORE = 12</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_ADVANCED_REAL_TIME">
            <summary>FF_PROFILE_MPEG4_ADVANCED_REAL_TIME = 9</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE">
            <summary>FF_PROFILE_MPEG4_ADVANCED_SCALABLE_TEXTURE = 13</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_ADVANCED_SIMPLE">
            <summary>FF_PROFILE_MPEG4_ADVANCED_SIMPLE = 15</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE">
            <summary>FF_PROFILE_MPEG4_BASIC_ANIMATED_TEXTURE = 7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_CORE">
            <summary>FF_PROFILE_MPEG4_CORE = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_CORE_SCALABLE">
            <summary>FF_PROFILE_MPEG4_CORE_SCALABLE = 10</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_HYBRID">
            <summary>FF_PROFILE_MPEG4_HYBRID = 8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_MAIN">
            <summary>FF_PROFILE_MPEG4_MAIN = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_N_BIT">
            <summary>FF_PROFILE_MPEG4_N_BIT = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_SCALABLE_TEXTURE">
            <summary>FF_PROFILE_MPEG4_SCALABLE_TEXTURE = 5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_SIMPLE">
            <summary>FF_PROFILE_MPEG4_SIMPLE = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION">
            <summary>FF_PROFILE_MPEG4_SIMPLE_FACE_ANIMATION = 6</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_SIMPLE_SCALABLE">
            <summary>FF_PROFILE_MPEG4_SIMPLE_SCALABLE = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_MPEG4_SIMPLE_STUDIO">
            <summary>FF_PROFILE_MPEG4_SIMPLE_STUDIO = 14</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_PRORES_4444">
            <summary>FF_PROFILE_PRORES_4444 = 4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_PRORES_HQ">
            <summary>FF_PROFILE_PRORES_HQ = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_PRORES_LT">
            <summary>FF_PROFILE_PRORES_LT = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_PRORES_PROXY">
            <summary>FF_PROFILE_PRORES_PROXY = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_PRORES_STANDARD">
            <summary>FF_PROFILE_PRORES_STANDARD = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_PRORES_XQ">
            <summary>FF_PROFILE_PRORES_XQ = 5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_RESERVED">
            <summary>FF_PROFILE_RESERVED = -100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_SBC_MSBC">
            <summary>FF_PROFILE_SBC_MSBC = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_UNKNOWN">
            <summary>FF_PROFILE_UNKNOWN = -99</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_VC1_ADVANCED">
            <summary>FF_PROFILE_VC1_ADVANCED = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_VC1_COMPLEX">
            <summary>FF_PROFILE_VC1_COMPLEX = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_VC1_MAIN">
            <summary>FF_PROFILE_VC1_MAIN = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_VC1_SIMPLE">
            <summary>FF_PROFILE_VC1_SIMPLE = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_VP9_0">
            <summary>FF_PROFILE_VP9_0 = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_VP9_1">
            <summary>FF_PROFILE_VP9_1 = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_VP9_2">
            <summary>FF_PROFILE_VP9_2 = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_PROFILE_VP9_3">
            <summary>FF_PROFILE_VP9_3 = 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_QP2LAMBDA">
            <summary>FF_QP2LAMBDA = 118</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_QUALITY_SCALE">
            <summary>FF_QUALITY_SCALE = FF_LAMBDA_SCALE</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_SUB_CHARENC_MODE_AUTOMATIC">
            <summary>FF_SUB_CHARENC_MODE_AUTOMATIC = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_SUB_CHARENC_MODE_DO_NOTHING">
            <summary>FF_SUB_CHARENC_MODE_DO_NOTHING = -1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_SUB_CHARENC_MODE_IGNORE">
            <summary>FF_SUB_CHARENC_MODE_IGNORE = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_SUB_CHARENC_MODE_PRE_DECODER">
            <summary>FF_SUB_CHARENC_MODE_PRE_DECODER = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_SUB_TEXT_FMT_ASS">
            <summary>FF_SUB_TEXT_FMT_ASS = 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS">
            <summary>FF_SUB_TEXT_FMT_ASS_WITH_TIMINGS = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_THREAD_FRAME">
            <summary>FF_THREAD_FRAME = 1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.FF_THREAD_SLICE">
            <summary>FF_THREAD_SLICE = 2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVCODEC_BUILD">
            <summary>LIBAVCODEC_BUILD = LIBAVCODEC_VERSION_INT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVCODEC_IDENT">
            <summary>LIBAVCODEC_IDENT = &quot;Lavc&quot; AV_STRINGIFY(LIBAVCODEC_VERSION)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVCODEC_VERSION">
            <summary>LIBAVCODEC_VERSION = AV_VERSION(LIBAVCODEC_VERSION_MAJOR,    LIBAVCODEC_VERSION_MINOR,    LIBAVCODEC_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVCODEC_VERSION_INT">
            <summary>LIBAVCODEC_VERSION_INT = AV_VERSION_INT(LIBAVCODEC_VERSION_MAJOR, LIBAVCODEC_VERSION_MINOR, LIBAVCODEC_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVCODEC_VERSION_MAJOR">
            <summary>LIBAVCODEC_VERSION_MAJOR = 58</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVCODEC_VERSION_MICRO">
            <summary>LIBAVCODEC_VERSION_MICRO = 100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVCODEC_VERSION_MINOR">
            <summary>LIBAVCODEC_VERSION_MINOR = 91</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVDEVICE_BUILD">
            <summary>LIBAVDEVICE_BUILD = LIBAVDEVICE_VERSION_INT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVDEVICE_IDENT">
            <summary>LIBAVDEVICE_IDENT = &quot;Lavd&quot; AV_STRINGIFY(LIBAVDEVICE_VERSION)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVDEVICE_VERSION">
            <summary>LIBAVDEVICE_VERSION = AV_VERSION(LIBAVDEVICE_VERSION_MAJOR, LIBAVDEVICE_VERSION_MINOR, LIBAVDEVICE_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVDEVICE_VERSION_INT">
            <summary>LIBAVDEVICE_VERSION_INT = AV_VERSION_INT(LIBAVDEVICE_VERSION_MAJOR, LIBAVDEVICE_VERSION_MINOR, LIBAVDEVICE_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVDEVICE_VERSION_MAJOR">
            <summary>LIBAVDEVICE_VERSION_MAJOR = 58</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVDEVICE_VERSION_MICRO">
            <summary>LIBAVDEVICE_VERSION_MICRO = 100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVDEVICE_VERSION_MINOR">
            <summary>LIBAVDEVICE_VERSION_MINOR = 10</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFILTER_BUILD">
            <summary>LIBAVFILTER_BUILD = LIBAVFILTER_VERSION_INT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFILTER_IDENT">
            <summary>LIBAVFILTER_IDENT = &quot;Lavfi&quot;</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFILTER_VERSION">
            <summary>LIBAVFILTER_VERSION = AV_VERSION(LIBAVFILTER_VERSION_MAJOR, LIBAVFILTER_VERSION_MINOR, LIBAVFILTER_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFILTER_VERSION_INT">
            <summary>LIBAVFILTER_VERSION_INT = AV_VERSION_INT(LIBAVFILTER_VERSION_MAJOR, LIBAVFILTER_VERSION_MINOR, LIBAVFILTER_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFILTER_VERSION_MAJOR">
            <summary>LIBAVFILTER_VERSION_MAJOR = 0x7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFILTER_VERSION_MICRO">
            <summary>LIBAVFILTER_VERSION_MICRO = 0x64</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFILTER_VERSION_MINOR">
            <summary>LIBAVFILTER_VERSION_MINOR = 0x55</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFORMAT_BUILD">
            <summary>LIBAVFORMAT_BUILD = LIBAVFORMAT_VERSION_INT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFORMAT_IDENT">
            <summary>LIBAVFORMAT_IDENT = &quot;Lavf&quot; AV_STRINGIFY(LIBAVFORMAT_VERSION)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFORMAT_VERSION">
            <summary>LIBAVFORMAT_VERSION = AV_VERSION(LIBAVFORMAT_VERSION_MAJOR,   LIBAVFORMAT_VERSION_MINOR,   LIBAVFORMAT_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFORMAT_VERSION_INT">
            <summary>LIBAVFORMAT_VERSION_INT = AV_VERSION_INT(LIBAVFORMAT_VERSION_MAJOR, LIBAVFORMAT_VERSION_MINOR, LIBAVFORMAT_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFORMAT_VERSION_MAJOR">
            <summary>LIBAVFORMAT_VERSION_MAJOR = 58</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFORMAT_VERSION_MICRO">
            <summary>LIBAVFORMAT_VERSION_MICRO = 100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVFORMAT_VERSION_MINOR">
            <summary>LIBAVFORMAT_VERSION_MINOR = 45</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVUTIL_BUILD">
            <summary>LIBAVUTIL_BUILD = LIBAVUTIL_VERSION_INT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVUTIL_IDENT">
            <summary>LIBAVUTIL_IDENT = &quot;Lavu&quot; AV_STRINGIFY(LIBAVUTIL_VERSION)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVUTIL_VERSION">
            <summary>LIBAVUTIL_VERSION = AV_VERSION(LIBAVUTIL_VERSION_MAJOR,     LIBAVUTIL_VERSION_MINOR,     LIBAVUTIL_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVUTIL_VERSION_INT">
            <summary>LIBAVUTIL_VERSION_INT = AV_VERSION_INT(LIBAVUTIL_VERSION_MAJOR, LIBAVUTIL_VERSION_MINOR, LIBAVUTIL_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVUTIL_VERSION_MAJOR">
            <summary>LIBAVUTIL_VERSION_MAJOR = 56</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVUTIL_VERSION_MICRO">
            <summary>LIBAVUTIL_VERSION_MICRO = 100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBAVUTIL_VERSION_MINOR">
            <summary>LIBAVUTIL_VERSION_MINOR = 51</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBPOSTPROC_BUILD">
            <summary>LIBPOSTPROC_BUILD = LIBPOSTPROC_VERSION_INT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBPOSTPROC_IDENT">
            <summary>LIBPOSTPROC_IDENT = &quot;postproc&quot;</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBPOSTPROC_VERSION">
            <summary>LIBPOSTPROC_VERSION = AV_VERSION(LIBPOSTPROC_VERSION_MAJOR, LIBPOSTPROC_VERSION_MINOR, LIBPOSTPROC_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBPOSTPROC_VERSION_INT">
            <summary>LIBPOSTPROC_VERSION_INT = AV_VERSION_INT(LIBPOSTPROC_VERSION_MAJOR, LIBPOSTPROC_VERSION_MINOR, LIBPOSTPROC_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBPOSTPROC_VERSION_MAJOR">
            <summary>LIBPOSTPROC_VERSION_MAJOR = 0x37</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBPOSTPROC_VERSION_MICRO">
            <summary>LIBPOSTPROC_VERSION_MICRO = 0x64</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBPOSTPROC_VERSION_MINOR">
            <summary>LIBPOSTPROC_VERSION_MINOR = 0x7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWRESAMPLE_BUILD">
            <summary>LIBSWRESAMPLE_BUILD = LIBSWRESAMPLE_VERSION_INT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWRESAMPLE_IDENT">
            <summary>LIBSWRESAMPLE_IDENT = &quot;SwR&quot;</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWRESAMPLE_VERSION">
            <summary>LIBSWRESAMPLE_VERSION = AV_VERSION(LIBSWRESAMPLE_VERSION_MAJOR, LIBSWRESAMPLE_VERSION_MINOR, LIBSWRESAMPLE_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWRESAMPLE_VERSION_INT">
            <summary>LIBSWRESAMPLE_VERSION_INT = AV_VERSION_INT(LIBSWRESAMPLE_VERSION_MAJOR, LIBSWRESAMPLE_VERSION_MINOR, LIBSWRESAMPLE_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWRESAMPLE_VERSION_MAJOR">
            <summary>LIBSWRESAMPLE_VERSION_MAJOR = 0x3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWRESAMPLE_VERSION_MICRO">
            <summary>LIBSWRESAMPLE_VERSION_MICRO = 0x64</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWRESAMPLE_VERSION_MINOR">
            <summary>LIBSWRESAMPLE_VERSION_MINOR = 0x7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWSCALE_BUILD">
            <summary>LIBSWSCALE_BUILD = LIBSWSCALE_VERSION_INT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWSCALE_IDENT">
            <summary>LIBSWSCALE_IDENT = &quot;SwS&quot;</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWSCALE_VERSION">
            <summary>LIBSWSCALE_VERSION = AV_VERSION(LIBSWSCALE_VERSION_MAJOR, LIBSWSCALE_VERSION_MINOR, LIBSWSCALE_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWSCALE_VERSION_INT">
            <summary>LIBSWSCALE_VERSION_INT = AV_VERSION_INT(LIBSWSCALE_VERSION_MAJOR, LIBSWSCALE_VERSION_MINOR, LIBSWSCALE_VERSION_MICRO)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWSCALE_VERSION_MAJOR">
            <summary>LIBSWSCALE_VERSION_MAJOR = 0x5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWSCALE_VERSION_MICRO">
            <summary>LIBSWSCALE_VERSION_MICRO = 0x64</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.LIBSWSCALE_VERSION_MINOR">
            <summary>LIBSWSCALE_VERSION_MINOR = 0x7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.M_E">
            <summary>M_E = 2.7182818284590452354</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.M_LN10">
            <summary>M_LN10 = 2.30258509299404568402</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.M_LN2">
            <summary>M_LN2 = 0.69314718055994530942</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.M_LOG2_10">
            <summary>M_LOG2_10 = 3.32192809488736234787</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.M_PHI">
            <summary>M_PHI = 1.61803398874989484820</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.M_PI">
            <summary>M_PI = 3.14159265358979323846</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.M_PI_2">
            <summary>M_PI_2 = 1.57079632679489661923</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.M_SQRT1_2">
            <summary>M_SQRT1_2 = 0.70710678118654752440</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.M_SQRT2">
            <summary>M_SQRT2 = 1.41421356237309504880</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.MAX_REORDER_DELAY">
            <summary>MAX_REORDER_DELAY = 16</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.MAX_STD_TIMEBASES">
            <summary>MAX_STD_TIMEBASES = (30*12+30+3+6)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PARSER_FLAG_COMPLETE_FRAMES">
            <summary>PARSER_FLAG_COMPLETE_FRAMES = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PARSER_FLAG_FETCHED_OFFSET">
            <summary>PARSER_FLAG_FETCHED_OFFSET = 0x0004</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PARSER_FLAG_ONCE">
            <summary>PARSER_FLAG_ONCE = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PARSER_FLAG_USE_CODEC_TS">
            <summary>PARSER_FLAG_USE_CODEC_TS = 0x1000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_CPU_CAPS_3DNOW">
            <summary>PP_CPU_CAPS_3DNOW = 0x40000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_CPU_CAPS_ALTIVEC">
            <summary>PP_CPU_CAPS_ALTIVEC = 0x10000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_CPU_CAPS_AUTO">
            <summary>PP_CPU_CAPS_AUTO = 0x80000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_CPU_CAPS_MMX">
            <summary>PP_CPU_CAPS_MMX = 0x80000000U</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_CPU_CAPS_MMX2">
            <summary>PP_CPU_CAPS_MMX2 = 0x20000000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_FORMAT">
            <summary>PP_FORMAT = 0x8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_FORMAT_411">
            <summary>PP_FORMAT_411 = 0x2 | PP_FORMAT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_FORMAT_420">
            <summary>PP_FORMAT_420 = 0x11 | PP_FORMAT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_FORMAT_422">
            <summary>PP_FORMAT_422 = 0x1 | PP_FORMAT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_FORMAT_440">
            <summary>PP_FORMAT_440 = 0x10 | PP_FORMAT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_FORMAT_444">
            <summary>PP_FORMAT_444 = 0x0 | PP_FORMAT</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_PICT_TYPE_QP2">
            <summary>PP_PICT_TYPE_QP2 = 0x10</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.PP_QUALITY_MAX">
            <summary>PP_QUALITY_MAX = 0x6</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SLICE_FLAG_ALLOW_FIELD">
            <summary>SLICE_FLAG_ALLOW_FIELD = 0x0002</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SLICE_FLAG_ALLOW_PLANE">
            <summary>SLICE_FLAG_ALLOW_PLANE = 0x0004</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SLICE_FLAG_CODED_ORDER">
            <summary>SLICE_FLAG_CODED_ORDER = 0x0001</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWR_FLAG_RESAMPLE">
            <summary>SWR_FLAG_RESAMPLE = 0x1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_ACCURATE_RND">
            <summary>SWS_ACCURATE_RND = 0x40000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_AREA">
            <summary>SWS_AREA = 0x20</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_BICUBIC">
            <summary>SWS_BICUBIC = 0x4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_BICUBLIN">
            <summary>SWS_BICUBLIN = 0x40</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_BILINEAR">
            <summary>SWS_BILINEAR = 0x2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_BITEXACT">
            <summary>SWS_BITEXACT = 0x80000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_CS_BT2020">
            <summary>SWS_CS_BT2020 = 0x9</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_CS_DEFAULT">
            <summary>SWS_CS_DEFAULT = 0x5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_CS_FCC">
            <summary>SWS_CS_FCC = 0x4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_CS_ITU601">
            <summary>SWS_CS_ITU601 = 0x5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_CS_ITU624">
            <summary>SWS_CS_ITU624 = 0x5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_CS_ITU709">
            <summary>SWS_CS_ITU709 = 0x1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_CS_SMPTE170M">
            <summary>SWS_CS_SMPTE170M = 0x5</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_CS_SMPTE240M">
            <summary>SWS_CS_SMPTE240M = 0x7</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_DIRECT_BGR">
            <summary>SWS_DIRECT_BGR = 0x8000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_ERROR_DIFFUSION">
            <summary>SWS_ERROR_DIFFUSION = 0x800000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_FAST_BILINEAR">
            <summary>SWS_FAST_BILINEAR = 0x1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_FULL_CHR_H_INP">
            <summary>SWS_FULL_CHR_H_INP = 0x4000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_FULL_CHR_H_INT">
            <summary>SWS_FULL_CHR_H_INT = 0x2000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_GAUSS">
            <summary>SWS_GAUSS = 0x80</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_LANCZOS">
            <summary>SWS_LANCZOS = 0x200</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_MAX_REDUCE_CUTOFF">
            <summary>SWS_MAX_REDUCE_CUTOFF = 0.002D</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_PARAM_DEFAULT">
            <summary>SWS_PARAM_DEFAULT = 0x1e240</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_POINT">
            <summary>SWS_POINT = 0x10</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_PRINT_INFO">
            <summary>SWS_PRINT_INFO = 0x1000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_SINC">
            <summary>SWS_SINC = 0x100</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_SPLINE">
            <summary>SWS_SPLINE = 0x400</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_SRC_V_CHR_DROP_MASK">
            <summary>SWS_SRC_V_CHR_DROP_MASK = 0x30000</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_SRC_V_CHR_DROP_SHIFT">
            <summary>SWS_SRC_V_CHR_DROP_SHIFT = 0x10</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.ffmpeg.SWS_X">
            <summary>SWS_X = 0x8</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVAppToDevMessageType">
            <summary>Message types used by avdevice_app_to_dev_control_message().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_NONE">
            <summary>Dummy message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_WINDOW_SIZE">
            <summary>Window size change message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_WINDOW_REPAINT">
            <summary>Repaint request message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_PAUSE">
            <summary>Request pause/play.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_PLAY">
            <summary>Request pause/play.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_TOGGLE_PAUSE">
            <summary>Request pause/play.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_SET_VOLUME">
            <summary>Volume control message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_MUTE">
            <summary>Mute control messages.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_UNMUTE">
            <summary>Mute control messages.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_TOGGLE_MUTE">
            <summary>Mute control messages.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_GET_VOLUME">
            <summary>Get volume/mute messages.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAppToDevMessageType.AV_APP_TO_DEV_GET_MUTE">
            <summary>Get volume/mute messages.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVAudioServiceType.AV_AUDIO_SERVICE_TYPE_NB">
            <summary>Not part of ABI</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVChromaLocation">
            <summary>Location of chroma samples.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVChromaLocation.AVCHROMA_LOC_LEFT">
            <summary>MPEG-2/4 4:2:0, H.264 default for 4:2:0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVChromaLocation.AVCHROMA_LOC_CENTER">
            <summary>MPEG-1 4:2:0, JPEG 4:2:0, H.263 4:2:0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVChromaLocation.AVCHROMA_LOC_TOPLEFT">
            <summary>ITU-R 601, SMPTE 274M 296M S314M(DV 4:1:1), mpeg2 4:2:2</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVChromaLocation.AVCHROMA_LOC_NB">
            <summary>Not part of ABI</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClassCategory.AV_CLASS_CATEGORY_NB">
            <summary>not part of ABI/API</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVCodecID">
            <summary>Identify the syntax and semantics of the bitstream. The principle is roughly: Two decoders with the same ID can decode the same streams. Two encoders with the same ID can encode compatible streams. There may be slight deviations from the principle due to implementation details.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_MPEG2VIDEO">
            <summary>preferred ID for MPEG-1/2 video decoding</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_FIRST_AUDIO">
            <summary>A dummy id pointing at the start of audio codecs</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_MP3">
            <summary>preferred ID for decoding MPEG audio layer 1, 2 or 3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_GSM">
            <summary>as in Berlin toast format</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_FIRST_SUBTITLE">
            <summary>A dummy ID pointing at the start of subtitle codecs.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_TEXT">
            <summary>raw UTF-8 text</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_FIRST_UNKNOWN">
            <summary>A dummy ID pointing at the start of various fake codecs.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_SCTE_35">
            <summary>Contain timestamp estimated through PCR of program stream.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_PROBE">
            <summary>codec_id is not known (like AV_CODEC_ID_NONE) but lavf should attempt to identify it</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_MPEG2TS">
            <summary>_FAKE_ codec to indicate a raw MPEG-2 TS stream (only used by libavformat)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_MPEG4SYSTEMS">
            <summary>_FAKE_ codec to indicate a MPEG-4 Systems stream (only used by libavformat)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_FFMETADATA">
            <summary>Dummy codec for streams containing only metadata information.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecID.AV_CODEC_ID_WRAPPED_AVFRAME">
            <summary>Passthrough codec, AVFrames wrapped in AVPacket</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVColorPrimaries">
            <summary>Chromaticity coordinates of the source primaries. These values match the ones defined by ISO/IEC 23001-8_2013 § 7.1.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_BT709">
            <summary>also ITU-R BT1361 / IEC 61966-2-4 / SMPTE RP177 Annex B</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_BT470M">
            <summary>also FCC Title 47 Code of Federal Regulations 73.682 (a)(20)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_BT470BG">
            <summary>also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL &amp; SECAM</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_SMPTE170M">
            <summary>also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_SMPTE240M">
            <summary>functionally identical to above</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_FILM">
            <summary>colour filters using Illuminant C</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_BT2020">
            <summary>ITU-R BT2020</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_SMPTE428">
            <summary>SMPTE ST 428-1 (CIE 1931 XYZ)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_SMPTE431">
            <summary>SMPTE ST 431-2 (2011) / DCI P3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_SMPTE432">
            <summary>SMPTE ST 432-1 (2010) / P3 D65 / Display P3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_EBU3213">
            <summary>EBU Tech. 3213-E / JEDEC P22 phosphors</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorPrimaries.AVCOL_PRI_NB">
            <summary>Not part of ABI</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVColorRange">
            <summary>MPEG vs JPEG YUV range.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorRange.AVCOL_RANGE_MPEG">
            <summary>the normal 219*2^(n-8) &quot;MPEG&quot; YUV ranges</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorRange.AVCOL_RANGE_JPEG">
            <summary>the normal 2^n-1 &quot;JPEG&quot; YUV ranges</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorRange.AVCOL_RANGE_NB">
            <summary>Not part of ABI</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVColorSpace">
            <summary>YUV colorspace type. These values match the ones defined by ISO/IEC 23001-8_2013 § 7.3.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_RGB">
            <summary>order of coefficients is actually GBR, also IEC 61966-2-1 (sRGB)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_BT709">
            <summary>also ITU-R BT1361 / IEC 61966-2-4 xvYCC709 / SMPTE RP177 Annex B</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_FCC">
            <summary>FCC Title 47 Code of Federal Regulations 73.682 (a)(20)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_BT470BG">
            <summary>also ITU-R BT601-6 625 / ITU-R BT1358 625 / ITU-R BT1700 625 PAL &amp; SECAM / IEC 61966-2-4 xvYCC601</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_SMPTE170M">
            <summary>also ITU-R BT601-6 525 / ITU-R BT1358 525 / ITU-R BT1700 NTSC</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_SMPTE240M">
            <summary>functionally identical to above</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_YCGCO">
            <summary>Used by Dirac / VC-2 and H.264 FRext, see ITU-T SG16</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_BT2020_NCL">
            <summary>ITU-R BT2020 non-constant luminance system</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_BT2020_CL">
            <summary>ITU-R BT2020 constant luminance system</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_SMPTE2085">
            <summary>SMPTE 2085, Y&apos;D&apos;zD&apos;x</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_CHROMA_DERIVED_NCL">
            <summary>Chromaticity-derived non-constant luminance system</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_CHROMA_DERIVED_CL">
            <summary>Chromaticity-derived constant luminance system</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_ICTCP">
            <summary>ITU-R BT.2100-0, ICtCp</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorSpace.AVCOL_SPC_NB">
            <summary>Not part of ABI</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVColorTransferCharacteristic">
            <summary>Color Transfer Characteristic. These values match the ones defined by ISO/IEC 23001-8_2013 § 7.2.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_BT709">
            <summary>also ITU-R BT1361</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_GAMMA22">
            <summary>also ITU-R BT470M / ITU-R BT1700 625 PAL &amp; SECAM</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_GAMMA28">
            <summary>also ITU-R BT470BG</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_SMPTE170M">
            <summary>also ITU-R BT601-6 525 or 625 / ITU-R BT1358 525 or 625 / ITU-R BT1700 NTSC</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_LINEAR">
            <summary>&quot;Linear transfer characteristics&quot;</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_LOG">
            <summary>&quot;Logarithmic transfer characteristic (100:1 range)&quot;</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_LOG_SQRT">
            <summary>&quot;Logarithmic transfer characteristic (100 * Sqrt(10) : 1 range)&quot;</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_4">
            <summary>IEC 61966-2-4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_BT1361_ECG">
            <summary>ITU-R BT1361 Extended Colour Gamut</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_IEC61966_2_1">
            <summary>IEC 61966-2-1 (sRGB or sYCC)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_BT2020_10">
            <summary>ITU-R BT2020 for 10-bit system</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_BT2020_12">
            <summary>ITU-R BT2020 for 12-bit system</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_SMPTE2084">
            <summary>SMPTE ST 2084 for 10-, 12-, 14- and 16-bit systems</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_SMPTE428">
            <summary>SMPTE ST 428-1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_ARIB_STD_B67">
            <summary>ARIB STD-B67, known as &quot;Hybrid log-gamma&quot;</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVColorTransferCharacteristic.AVCOL_TRC_NB">
            <summary>Not part of ABI</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVDevToAppMessageType">
            <summary>Message types used by avdevice_dev_to_app_control_message().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_NONE">
            <summary>Dummy message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_CREATE_WINDOW_BUFFER">
            <summary>Create window buffer message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_PREPARE_WINDOW_BUFFER">
            <summary>Prepare window buffer message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_DISPLAY_WINDOW_BUFFER">
            <summary>Display window buffer message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_DESTROY_WINDOW_BUFFER">
            <summary>Destroy window buffer message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_BUFFER_OVERFLOW">
            <summary>Buffer fullness status messages.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_BUFFER_UNDERFLOW">
            <summary>Buffer fullness status messages.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_BUFFER_READABLE">
            <summary>Buffer readable/writable.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_BUFFER_WRITABLE">
            <summary>Buffer readable/writable.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_MUTE_STATE_CHANGED">
            <summary>Mute state change message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDevToAppMessageType.AV_DEV_TO_APP_VOLUME_LEVEL_CHANGED">
            <summary>Volume level change message.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDiscard.AVDISCARD_NONE">
            <summary>discard nothing</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDiscard.AVDISCARD_DEFAULT">
            <summary>discard useless packets like 0 size packets in avi</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDiscard.AVDISCARD_NONREF">
            <summary>discard all non reference</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDiscard.AVDISCARD_BIDIR">
            <summary>discard all bidirectional frames</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDiscard.AVDISCARD_NONINTRA">
            <summary>discard all non intra frames</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDiscard.AVDISCARD_NONKEY">
            <summary>discard all frames except keyframes</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDiscard.AVDISCARD_ALL">
            <summary>discard all</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVDurationEstimationMethod">
            <summary>The duration of a video can be estimated through various ways, and this enum can be used to know how the duration was estimated.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDurationEstimationMethod.AVFMT_DURATION_FROM_PTS">
            <summary>Duration accurately estimated from PTSes</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDurationEstimationMethod.AVFMT_DURATION_FROM_STREAM">
            <summary>Duration estimated from a stream with a known duration</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDurationEstimationMethod.AVFMT_DURATION_FROM_BITRATE">
            <summary>Duration estimated from bitrate (less accurate)</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilterLink_init_state">
            <summary>stage of the initialization of the link properties (dimensions, etc)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink_init_state.AVLINK_UNINIT">
            <summary>not started</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink_init_state.AVLINK_STARTINIT">
            <summary>started, but incomplete</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink_init_state.AVLINK_INIT">
            <summary>complete</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFrameSideDataType">
            <summary>@{ AVFrame is an abstraction for reference-counted raw multimedia data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_PANSCAN">
            <summary>The data is the AVPanScan struct defined in libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_A53_CC">
            <summary>ATSC A53 Part 4 Closed Captions. A53 CC bitstream is stored as uint8_t in AVFrameSideData.data. The number of bytes of CC data is AVFrameSideData.size.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_STEREO3D">
            <summary>Stereoscopic 3d metadata. The data is the AVStereo3D struct defined in libavutil/stereo3d.h.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_MATRIXENCODING">
            <summary>The data is the AVMatrixEncoding enum defined in libavutil/channel_layout.h.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_DOWNMIX_INFO">
            <summary>Metadata relevant to a downmix procedure. The data is the AVDownmixInfo struct defined in libavutil/downmix_info.h.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_REPLAYGAIN">
            <summary>ReplayGain information in the form of the AVReplayGain struct.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_DISPLAYMATRIX">
            <summary>This side data contains a 3x3 transformation matrix describing an affine transformation that needs to be applied to the frame for correct presentation.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_AFD">
            <summary>Active Format Description data consisting of a single byte as specified in ETSI TS 101 154 using AVActiveFormatDescription enum.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_MOTION_VECTORS">
            <summary>Motion vectors exported by some codecs (on demand through the export_mvs flag set in the libavcodec AVCodecContext flags2 option). The data is the AVMotionVector struct defined in libavutil/motion_vector.h.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_SKIP_SAMPLES">
            <summary>Recommmends skipping the specified number of samples. This is exported only if the &quot;skip_manual&quot; AVOption is set in libavcodec. This has the same format as AV_PKT_DATA_SKIP_SAMPLES.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_AUDIO_SERVICE_TYPE">
            <summary>This side data must be associated with an audio frame and corresponds to enum AVAudioServiceType defined in avcodec.h.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_MASTERING_DISPLAY_METADATA">
            <summary>Mastering display metadata associated with a video frame. The payload is an AVMasteringDisplayMetadata type and contains information about the mastering display color volume.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_GOP_TIMECODE">
            <summary>The GOP timecode in 25 bit timecode format. Data format is 64-bit integer. This is set on the first frame of a GOP that has a temporal reference of 0.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_SPHERICAL">
            <summary>The data represents the AVSphericalMapping structure defined in libavutil/spherical.h.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL">
            <summary>Content light level (based on CTA-861.3). This payload contains data in the form of the AVContentLightMetadata struct.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_ICC_PROFILE">
            <summary>The data contains an ICC profile as an opaque octet buffer following the format described by ISO 15076-1 with an optional name defined in the metadata key entry &quot;name&quot;.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_QP_TABLE_PROPERTIES">
            <summary>Implementation-specific description of the format of AV_FRAME_QP_TABLE_DATA. The contents of this side data are undocumented and internal; use av_frame_set_qp_table() and av_frame_get_qp_table() to access this in a meaningful way instead.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_QP_TABLE_DATA">
            <summary>Raw QP table data. Its format is described by AV_FRAME_DATA_QP_TABLE_PROPERTIES. Use av_frame_set_qp_table() and av_frame_get_qp_table() to access this instead.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_S12M_TIMECODE">
            <summary>Timecode which conforms to SMPTE ST 12-1. The data is an array of 4 uint32_t where the first uint32_t describes how many (1-3) of the other timecodes are used. The timecode format is described in the av_timecode_get_smpte_from_framenum() function in libavutil/timecode.c.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_DYNAMIC_HDR_PLUS">
            <summary>HDR dynamic metadata associated with a video frame. The payload is an AVDynamicHDRPlus type and contains information for color volume transform - application 4 of SMPTE 2094-40:2016 standard.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_REGIONS_OF_INTEREST">
            <summary>Regions Of Interest, the data is an array of AVRegionOfInterest type, the number of array element is implied by AVFrameSideData.size / AVRegionOfInterest.self_size.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrameSideDataType.AV_FRAME_DATA_VIDEO_ENC_PARAMS">
            <summary>Encoding parameters for a video frame, as described by AVVideoEncParams.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFrameTransferDirection.AV_HWFRAME_TRANSFER_DIRECTION_FROM">
            <summary>Transfer the data from the queried hw frame.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFrameTransferDirection.AV_HWFRAME_TRANSFER_DIRECTION_TO">
            <summary>Transfer the data to the queried hw frame.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVIODataMarkerType">
            <summary>Different data types that can be returned via the AVIO write_data_type callback.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODataMarkerType.AVIO_DATA_MARKER_HEADER">
            <summary>Header data; this needs to be present for the stream to be decodeable.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODataMarkerType.AVIO_DATA_MARKER_SYNC_POINT">
            <summary>A point in the output bytestream where a decoder can start decoding (i.e. a keyframe). A demuxer/decoder given the data flagged with AVIO_DATA_MARKER_HEADER, followed by any AVIO_DATA_MARKER_SYNC_POINT, should give decodeable results.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODataMarkerType.AVIO_DATA_MARKER_BOUNDARY_POINT">
            <summary>A point in the output bytestream where a demuxer can start parsing (for non self synchronizing bytestream formats). That is, any non-keyframe packet start point.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODataMarkerType.AVIO_DATA_MARKER_UNKNOWN">
            <summary>This is any, unlabelled data. It can either be a muxer not marking any positions at all, it can be an actual boundary/sync point that the muxer chooses not to mark, or a later part of a packet/fragment that is cut into multiple write callbacks due to limited IO buffer size.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODataMarkerType.AVIO_DATA_MARKER_TRAILER">
            <summary>Trailer data, which doesn&apos;t contain actual content, but only for finalizing the output file.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODataMarkerType.AVIO_DATA_MARKER_FLUSH_POINT">
            <summary>A point in the output bytestream where the underlying AVIOContext might flush the buffer depending on latency or buffering requirements. Typically means the end of a packet.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVIODirEntryType">
            <summary>Directory entry types.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVLockOp">
            <summary>Lock operation used by lockmgr</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVLockOp.AV_LOCK_CREATE">
            <summary>Create a mutex</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVLockOp.AV_LOCK_OBTAIN">
            <summary>Lock the mutex</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVLockOp.AV_LOCK_RELEASE">
            <summary>Unlock the mutex</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVLockOp.AV_LOCK_DESTROY">
            <summary>Free mutex resources</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVMediaType">
            <summary>Media Type</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVMediaType.AVMEDIA_TYPE_UNKNOWN">
            <summary>Usually treated as AVMEDIA_TYPE_DATA</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVMediaType.AVMEDIA_TYPE_DATA">
            <summary>Opaque data information usually continuous</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVMediaType.AVMEDIA_TYPE_ATTACHMENT">
            <summary>Opaque data information usually sparse</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVOptionType">
            <summary>@{ AVOptions provide a generic system to declare options on arbitrary structs (&quot;objects&quot;). An option can have a help text, a type and a range of possible values. Options may then be enumerated, read and written to.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionType.AV_OPT_TYPE_BINARY">
            <summary>offset must point to a pointer immediately followed by an int for the length</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionType.AV_OPT_TYPE_IMAGE_SIZE">
            <summary>offset must point to two consecutive integers</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionType.AV_OPT_TYPE_VIDEO_RATE">
            <summary>offset must point to AVRational</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVPacketSideDataType">
            <summary>Types and functions for working with AVPacket. @{</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_PALETTE">
            <summary>An AV_PKT_DATA_PALETTE side data packet contains exactly AVPALETTE_SIZE bytes worth of palette. This side data signals that a new palette is present.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_NEW_EXTRADATA">
            <summary>The AV_PKT_DATA_NEW_EXTRADATA is used to notify the codec or the format that the extradata buffer was changed and the receiving side should act upon it appropriately. The new extradata is embedded in the side data buffer and should be immediately used for processing the current frame or packet.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_PARAM_CHANGE">
            <summary>An AV_PKT_DATA_PARAM_CHANGE side data packet is laid out as follows:</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_H263_MB_INFO">
            <summary>An AV_PKT_DATA_H263_MB_INFO side data packet contains a number of structures with info about macroblocks relevant to splitting the packet into smaller packets on macroblock edges (e.g. as for RFC 2190). That is, it does not necessarily contain info about all macroblocks, as long as the distance between macroblocks in the info is smaller than the target payload size. Each MB info structure is 12 bytes, and is laid out as follows:</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_REPLAYGAIN">
            <summary>This side data should be associated with an audio stream and contains ReplayGain information in form of the AVReplayGain struct.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_DISPLAYMATRIX">
            <summary>This side data contains a 3x3 transformation matrix describing an affine transformation that needs to be applied to the decoded video frames for correct presentation.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_STEREO3D">
            <summary>This side data should be associated with a video stream and contains Stereoscopic 3D information in form of the AVStereo3D struct.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_AUDIO_SERVICE_TYPE">
            <summary>This side data should be associated with an audio stream and corresponds to enum AVAudioServiceType.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_QUALITY_STATS">
            <summary>This side data contains quality related information from the encoder.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_FALLBACK_TRACK">
            <summary>This side data contains an integer value representing the stream index of a &quot;fallback&quot; track. A fallback track indicates an alternate track to use when the current track can not be decoded for some reason. e.g. no decoder available for codec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_CPB_PROPERTIES">
            <summary>This side data corresponds to the AVCPBProperties struct.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_SKIP_SAMPLES">
            <summary>Recommmends skipping the specified number of samples</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_JP_DUALMONO">
            <summary>An AV_PKT_DATA_JP_DUALMONO side data packet indicates that the packet may contain &quot;dual mono&quot; audio specific to Japanese DTV and if it is true, recommends only the selected channel to be used.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_STRINGS_METADATA">
            <summary>A list of zero terminated key/value strings. There is no end marker for the list, so it is required to rely on the side data size to stop.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_SUBTITLE_POSITION">
            <summary>Subtitle event position</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_MATROSKA_BLOCKADDITIONAL">
            <summary>Data found in BlockAdditional element of matroska container. There is no end marker for the data, so it is required to rely on the side data size to recognize the end. 8 byte id (as found in BlockAddId) followed by data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_WEBVTT_IDENTIFIER">
            <summary>The optional first identifier line of a WebVTT cue.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_WEBVTT_SETTINGS">
            <summary>The optional settings (rendering instructions) that immediately follow the timestamp specifier of a WebVTT cue.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_METADATA_UPDATE">
            <summary>A list of zero terminated key/value strings. There is no end marker for the list, so it is required to rely on the side data size to stop. This side data includes updated metadata which appeared in the stream.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_MPEGTS_STREAM_ID">
            <summary>MPEGTS stream ID as uint8_t, this is required to pass the stream ID information from the demuxer to the corresponding muxer.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_MASTERING_DISPLAY_METADATA">
            <summary>Mastering display metadata (based on SMPTE-2086:2014). This metadata should be associated with a video stream and contains data in the form of the AVMasteringDisplayMetadata struct.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_SPHERICAL">
            <summary>This side data should be associated with a video stream and corresponds to the AVSphericalMapping structure.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_CONTENT_LIGHT_LEVEL">
            <summary>Content light level (based on CTA-861.3). This metadata should be associated with a video stream and contains data in the form of the AVContentLightMetadata struct.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_A53_CC">
            <summary>ATSC A53 Part 4 Closed Captions. This metadata should be associated with a video stream. A53 CC bitstream is stored as uint8_t in AVPacketSideData.data. The number of bytes of CC data is AVPacketSideData.size.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_ENCRYPTION_INIT_INFO">
            <summary>This side data is encryption initialization data. The format is not part of ABI, use av_encryption_init_info_* methods to access.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_ENCRYPTION_INFO">
            <summary>This side data contains encryption info for how to decrypt the packet. The format is not part of ABI, use av_encryption_info_* methods to access.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_AFD">
            <summary>Active Format Description data consisting of a single byte as specified in ETSI TS 101 154 using AVActiveFormatDescription enum.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_PRFT">
            <summary>Producer Reference Time data corresponding to the AVProducerReferenceTime struct, usually exported by some encoders (on demand through the prft flag set in the AVCodecContext export_side_data field).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_ICC_PROFILE">
            <summary>ICC profile data consisting of an opaque octet buffer following the format described by ISO 15076-1.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_DOVI_CONF">
            <summary>DOVI configuration ref: dolby-vision-bitstreams-within-the-iso-base-media-file-format-v2.1.2, section 2.2 dolby-vision-bitstreams-in-mpeg-2-transport-stream-multiplex-v1.2, section 3.3 Tags are stored in struct AVDOVIDecoderConfigurationRecord.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacketSideDataType.AV_PKT_DATA_NB">
            <summary>The number of side data types. This is not part of the public API/ABI in the sense that it may change when new side data types are added. This must stay the last enum value. If its value becomes huge, some code using it needs to be updated as it assumes it to be smaller than other limits.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVPictureStructure">
            <summary>@{</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVPictureType">
            <summary>@} @}</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPictureType.AV_PICTURE_TYPE_NONE">
            <summary>Undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPictureType.AV_PICTURE_TYPE_I">
            <summary>Intra</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPictureType.AV_PICTURE_TYPE_P">
            <summary>Predicted</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPictureType.AV_PICTURE_TYPE_B">
            <summary>Bi-dir predicted</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPictureType.AV_PICTURE_TYPE_S">
            <summary>S(GMC)-VOP MPEG-4</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPictureType.AV_PICTURE_TYPE_SI">
            <summary>Switching Intra</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPictureType.AV_PICTURE_TYPE_SP">
            <summary>Switching Predicted</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPictureType.AV_PICTURE_TYPE_BI">
            <summary>BI type</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVPixelFormat">
            <summary>Pixel format.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P">
            <summary>planar YUV 4:2:0, 12bpp, (1 Cr &amp; Cb sample per 2x2 Y samples)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUYV422">
            <summary>packed YUV 4:2:2, 16bpp, Y0 Cb Y1 Cr</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB24">
            <summary>packed RGB 8:8:8, 24bpp, RGBRGB...</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR24">
            <summary>packed RGB 8:8:8, 24bpp, BGRBGR...</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P">
            <summary>planar YUV 4:2:2, 16bpp, (1 Cr &amp; Cb sample per 2x1 Y samples)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P">
            <summary>planar YUV 4:4:4, 24bpp, (1 Cr &amp; Cb sample per 1x1 Y samples)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV410P">
            <summary>planar YUV 4:1:0, 9bpp, (1 Cr &amp; Cb sample per 4x4 Y samples)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV411P">
            <summary>planar YUV 4:1:1, 12bpp, (1 Cr &amp; Cb sample per 4x1 Y samples)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY8">
            <summary>Y , 8bpp</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_MONOWHITE">
            <summary>Y , 1bpp, 0 is white, 1 is black, in each byte pixels are ordered from the msb to the lsb</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_MONOBLACK">
            <summary>Y , 1bpp, 0 is black, 1 is white, in each byte pixels are ordered from the msb to the lsb</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_PAL8">
            <summary>8 bits with AV_PIX_FMT_RGB32 palette</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVJ420P">
            <summary>planar YUV 4:2:0, 12bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV420P and setting color_range</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVJ422P">
            <summary>planar YUV 4:2:2, 16bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV422P and setting color_range</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVJ444P">
            <summary>planar YUV 4:4:4, 24bpp, full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV444P and setting color_range</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_UYVY422">
            <summary>packed YUV 4:2:2, 16bpp, Cb Y0 Cr Y1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_UYYVYY411">
            <summary>packed YUV 4:1:1, 12bpp, Cb Y0 Y1 Cr Y2 Y3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR8">
            <summary>packed RGB 3:3:2, 8bpp, (msb)2B 3G 3R(lsb)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR4">
            <summary>packed RGB 1:2:1 bitstream, 4bpp, (msb)1B 2G 1R(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR4_BYTE">
            <summary>packed RGB 1:2:1, 8bpp, (msb)1B 2G 1R(lsb)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB8">
            <summary>packed RGB 3:3:2, 8bpp, (msb)2R 3G 3B(lsb)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB4">
            <summary>packed RGB 1:2:1 bitstream, 4bpp, (msb)1R 2G 1B(lsb), a byte contains two pixels, the first pixel in the byte is the one composed by the 4 msb bits</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB4_BYTE">
            <summary>packed RGB 1:2:1, 8bpp, (msb)1R 2G 1B(lsb)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_NV12">
            <summary>planar YUV 4:2:0, 12bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_NV21">
            <summary>as above, but U and V bytes are swapped</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_ARGB">
            <summary>packed ARGB 8:8:8:8, 32bpp, ARGBARGB...</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGBA">
            <summary>packed RGBA 8:8:8:8, 32bpp, RGBARGBA...</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_ABGR">
            <summary>packed ABGR 8:8:8:8, 32bpp, ABGRABGR...</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGRA">
            <summary>packed BGRA 8:8:8:8, 32bpp, BGRABGRA...</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY16BE">
            <summary>Y , 16bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY16LE">
            <summary>Y , 16bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV440P">
            <summary>planar YUV 4:4:0 (1 Cr &amp; Cb sample per 1x2 Y samples)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVJ440P">
            <summary>planar YUV 4:4:0 full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV440P and setting color_range</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA420P">
            <summary>planar YUV 4:2:0, 20bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB48BE">
            <summary>packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB48LE">
            <summary>packed RGB 16:16:16, 48bpp, 16R, 16G, 16B, the 2-byte value for each R/G/B component is stored as little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB565BE">
            <summary>packed RGB 5:6:5, 16bpp, (msb) 5R 6G 5B(lsb), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB565LE">
            <summary>packed RGB 5:6:5, 16bpp, (msb) 5R 6G 5B(lsb), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB555BE">
            <summary>packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), big-endian , X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB555LE">
            <summary>packed RGB 5:5:5, 16bpp, (msb)1X 5R 5G 5B(lsb), little-endian, X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR565BE">
            <summary>packed BGR 5:6:5, 16bpp, (msb) 5B 6G 5R(lsb), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR565LE">
            <summary>packed BGR 5:6:5, 16bpp, (msb) 5B 6G 5R(lsb), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR555BE">
            <summary>packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), big-endian , X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR555LE">
            <summary>packed BGR 5:5:5, 16bpp, (msb)1X 5B 5G 5R(lsb), little-endian, X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_VAAPI_MOCO">
            <summary>HW acceleration through VA API at motion compensation entry-point, Picture.data[3] contains a vaapi_render_state struct which contains macroblocks as well as various fields extracted from headers</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_VAAPI_IDCT">
            <summary>HW acceleration through VA API at IDCT entry-point, Picture.data[3] contains a vaapi_render_state struct which contains fields extracted from headers</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_VAAPI_VLD">
            <summary>HW decoding through VA API, Picture.data[3] contains a VASurfaceID</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_VAAPI">
            <summary>@}</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P16LE">
            <summary>planar YUV 4:2:0, 24bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P16BE">
            <summary>planar YUV 4:2:0, 24bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P16LE">
            <summary>planar YUV 4:2:2, 32bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P16BE">
            <summary>planar YUV 4:2:2, 32bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P16LE">
            <summary>planar YUV 4:4:4, 48bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P16BE">
            <summary>planar YUV 4:4:4, 48bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_DXVA2_VLD">
            <summary>HW decoding through DXVA2, Picture.data[3] contains a LPDIRECT3DSURFACE9 pointer</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB444LE">
            <summary>packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), little-endian, X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB444BE">
            <summary>packed RGB 4:4:4, 16bpp, (msb)4X 4R 4G 4B(lsb), big-endian, X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR444LE">
            <summary>packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), little-endian, X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR444BE">
            <summary>packed BGR 4:4:4, 16bpp, (msb)4X 4B 4G 4R(lsb), big-endian, X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YA8">
            <summary>8 bits gray, 8 bits alpha</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_Y400A">
            <summary>alias for AV_PIX_FMT_YA8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY8A">
            <summary>alias for AV_PIX_FMT_YA8</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR48BE">
            <summary>packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR48LE">
            <summary>packed RGB 16:16:16, 48bpp, 16B, 16G, 16R, the 2-byte value for each R/G/B component is stored as little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P9BE">
            <summary>planar YUV 4:2:0, 13.5bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P9LE">
            <summary>planar YUV 4:2:0, 13.5bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P10BE">
            <summary>planar YUV 4:2:0, 15bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P10LE">
            <summary>planar YUV 4:2:0, 15bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P10BE">
            <summary>planar YUV 4:2:2, 20bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P10LE">
            <summary>planar YUV 4:2:2, 20bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P9BE">
            <summary>planar YUV 4:4:4, 27bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P9LE">
            <summary>planar YUV 4:4:4, 27bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P10BE">
            <summary>planar YUV 4:4:4, 30bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P10LE">
            <summary>planar YUV 4:4:4, 30bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P9BE">
            <summary>planar YUV 4:2:2, 18bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P9LE">
            <summary>planar YUV 4:2:2, 18bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP">
            <summary>planar GBR 4:4:4 24bpp</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP9BE">
            <summary>planar GBR 4:4:4 27bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP9LE">
            <summary>planar GBR 4:4:4 27bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP10BE">
            <summary>planar GBR 4:4:4 30bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP10LE">
            <summary>planar GBR 4:4:4 30bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP16BE">
            <summary>planar GBR 4:4:4 48bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP16LE">
            <summary>planar GBR 4:4:4 48bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA422P">
            <summary>planar YUV 4:2:2 24bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA444P">
            <summary>planar YUV 4:4:4 32bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA420P9BE">
            <summary>planar YUV 4:2:0 22.5bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA420P9LE">
            <summary>planar YUV 4:2:0 22.5bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA422P9BE">
            <summary>planar YUV 4:2:2 27bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA422P9LE">
            <summary>planar YUV 4:2:2 27bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA444P9BE">
            <summary>planar YUV 4:4:4 36bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA444P9LE">
            <summary>planar YUV 4:4:4 36bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA420P10BE">
            <summary>planar YUV 4:2:0 25bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples, big-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA420P10LE">
            <summary>planar YUV 4:2:0 25bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples, little-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA422P10BE">
            <summary>planar YUV 4:2:2 30bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples, big-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA422P10LE">
            <summary>planar YUV 4:2:2 30bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples, little-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA444P10BE">
            <summary>planar YUV 4:4:4 40bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples, big-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA444P10LE">
            <summary>planar YUV 4:4:4 40bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples, little-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA420P16BE">
            <summary>planar YUV 4:2:0 40bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples, big-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA420P16LE">
            <summary>planar YUV 4:2:0 40bpp, (1 Cr &amp; Cb sample per 2x2 Y &amp; A samples, little-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA422P16BE">
            <summary>planar YUV 4:2:2 48bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples, big-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA422P16LE">
            <summary>planar YUV 4:2:2 48bpp, (1 Cr &amp; Cb sample per 2x1 Y &amp; A samples, little-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA444P16BE">
            <summary>planar YUV 4:4:4 64bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples, big-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA444P16LE">
            <summary>planar YUV 4:4:4 64bpp, (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples, little-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_VDPAU">
            <summary>HW acceleration through VDPAU, Picture.data[3] contains a VdpVideoSurface</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_XYZ12LE">
            <summary>packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as little-endian, the 4 lower bits are set to 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_XYZ12BE">
            <summary>packed XYZ 4:4:4, 36 bpp, (msb) 12X, 12Y, 12Z (lsb), the 2-byte value for each X/Y/Z is stored as big-endian, the 4 lower bits are set to 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_NV16">
            <summary>interleaved chroma YUV 4:2:2, 16bpp, (1 Cr &amp; Cb sample per 2x1 Y samples)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_NV20LE">
            <summary>interleaved chroma YUV 4:2:2, 20bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_NV20BE">
            <summary>interleaved chroma YUV 4:2:2, 20bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGBA64BE">
            <summary>packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGBA64LE">
            <summary>packed RGBA 16:16:16:16, 64bpp, 16R, 16G, 16B, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGRA64BE">
            <summary>packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGRA64LE">
            <summary>packed RGBA 16:16:16:16, 64bpp, 16B, 16G, 16R, 16A, the 2-byte value for each R/G/B/A component is stored as little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YVYU422">
            <summary>packed YUV 4:2:2, 16bpp, Y0 Cr Y1 Cb</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YA16BE">
            <summary>16 bits gray, 16 bits alpha (big-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YA16LE">
            <summary>16 bits gray, 16 bits alpha (little-endian)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRAP">
            <summary>planar GBRA 4:4:4:4 32bpp</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRAP16BE">
            <summary>planar GBRA 4:4:4:4 64bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRAP16LE">
            <summary>planar GBRA 4:4:4:4 64bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_QSV">
            <summary>HW acceleration through QSV, data[3] contains a pointer to the mfxFrameSurface1 structure.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_MMAL">
            <summary>HW acceleration though MMAL, data[3] contains a pointer to the MMAL_BUFFER_HEADER_T structure.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_D3D11VA_VLD">
            <summary>HW decoding through Direct3D11 via old API, Picture.data[3] contains a ID3D11VideoDecoderOutputView pointer</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_CUDA">
            <summary>HW acceleration through CUDA. data[i] contain CUdeviceptr pointers exactly as for system memory frames.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_0RGB">
            <summary>packed RGB 8:8:8, 32bpp, XRGBXRGB... X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_RGB0">
            <summary>packed RGB 8:8:8, 32bpp, RGBXRGBX... X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_0BGR">
            <summary>packed BGR 8:8:8, 32bpp, XBGRXBGR... X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BGR0">
            <summary>packed BGR 8:8:8, 32bpp, BGRXBGRX... X=unused/undefined</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P12BE">
            <summary>planar YUV 4:2:0,18bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P12LE">
            <summary>planar YUV 4:2:0,18bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P14BE">
            <summary>planar YUV 4:2:0,21bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV420P14LE">
            <summary>planar YUV 4:2:0,21bpp, (1 Cr &amp; Cb sample per 2x2 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P12BE">
            <summary>planar YUV 4:2:2,24bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P12LE">
            <summary>planar YUV 4:2:2,24bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P14BE">
            <summary>planar YUV 4:2:2,28bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV422P14LE">
            <summary>planar YUV 4:2:2,28bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P12BE">
            <summary>planar YUV 4:4:4,36bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P12LE">
            <summary>planar YUV 4:4:4,36bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P14BE">
            <summary>planar YUV 4:4:4,42bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV444P14LE">
            <summary>planar YUV 4:4:4,42bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP12BE">
            <summary>planar GBR 4:4:4 36bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP12LE">
            <summary>planar GBR 4:4:4 36bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP14BE">
            <summary>planar GBR 4:4:4 42bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRP14LE">
            <summary>planar GBR 4:4:4 42bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVJ411P">
            <summary>planar YUV 4:1:1, 12bpp, (1 Cr &amp; Cb sample per 4x1 Y samples) full scale (JPEG), deprecated in favor of AV_PIX_FMT_YUV411P and setting color_range</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_BGGR8">
            <summary>bayer, BGBG..(odd line), GRGR..(even line), 8-bit samples</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_RGGB8">
            <summary>bayer, RGRG..(odd line), GBGB..(even line), 8-bit samples</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_GBRG8">
            <summary>bayer, GBGB..(odd line), RGRG..(even line), 8-bit samples</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_GRBG8">
            <summary>bayer, GRGR..(odd line), BGBG..(even line), 8-bit samples</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_BGGR16LE">
            <summary>bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_BGGR16BE">
            <summary>bayer, BGBG..(odd line), GRGR..(even line), 16-bit samples, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_RGGB16LE">
            <summary>bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_RGGB16BE">
            <summary>bayer, RGRG..(odd line), GBGB..(even line), 16-bit samples, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_GBRG16LE">
            <summary>bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_GBRG16BE">
            <summary>bayer, GBGB..(odd line), RGRG..(even line), 16-bit samples, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_GRBG16LE">
            <summary>bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_BAYER_GRBG16BE">
            <summary>bayer, GRGR..(odd line), BGBG..(even line), 16-bit samples, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_XVMC">
            <summary>XVideo Motion Acceleration via common packet passing</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV440P10LE">
            <summary>planar YUV 4:4:0,20bpp, (1 Cr &amp; Cb sample per 1x2 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV440P10BE">
            <summary>planar YUV 4:4:0,20bpp, (1 Cr &amp; Cb sample per 1x2 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV440P12LE">
            <summary>planar YUV 4:4:0,24bpp, (1 Cr &amp; Cb sample per 1x2 Y samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUV440P12BE">
            <summary>planar YUV 4:4:0,24bpp, (1 Cr &amp; Cb sample per 1x2 Y samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_AYUV64LE">
            <summary>packed AYUV 4:4:4,64bpp (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples), little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_AYUV64BE">
            <summary>packed AYUV 4:4:4,64bpp (1 Cr &amp; Cb sample per 1x1 Y &amp; A samples), big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_VIDEOTOOLBOX">
            <summary>hardware decoding through Videotoolbox</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_P010LE">
            <summary>like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_P010BE">
            <summary>like NV12, with 10bpp per component, data in the high bits, zeros in the low bits, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRAP12BE">
            <summary>planar GBR 4:4:4:4 48bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRAP12LE">
            <summary>planar GBR 4:4:4:4 48bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRAP10BE">
            <summary>planar GBR 4:4:4:4 40bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRAP10LE">
            <summary>planar GBR 4:4:4:4 40bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_MEDIACODEC">
            <summary>hardware decoding through MediaCodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY12BE">
            <summary>Y , 12bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY12LE">
            <summary>Y , 12bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY10BE">
            <summary>Y , 10bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY10LE">
            <summary>Y , 10bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_P016LE">
            <summary>like NV12, with 16bpp per component, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_P016BE">
            <summary>like NV12, with 16bpp per component, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_D3D11">
            <summary>Hardware surfaces for Direct3D11.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY9BE">
            <summary>Y , 9bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY9LE">
            <summary>Y , 9bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRPF32BE">
            <summary>IEEE-754 single precision planar GBR 4:4:4, 96bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRPF32LE">
            <summary>IEEE-754 single precision planar GBR 4:4:4, 96bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRAPF32BE">
            <summary>IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GBRAPF32LE">
            <summary>IEEE-754 single precision planar GBRA 4:4:4:4, 128bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_DRM_PRIME">
            <summary>DRM-managed buffers exposed through PRIME buffer sharing.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_OPENCL">
            <summary>Hardware surfaces for OpenCL.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY14BE">
            <summary>Y , 14bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAY14LE">
            <summary>Y , 14bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAYF32BE">
            <summary>IEEE-754 single precision Y, 32bpp, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_GRAYF32LE">
            <summary>IEEE-754 single precision Y, 32bpp, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA422P12BE">
            <summary>planar YUV 4:2:2,24bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), 12b alpha, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA422P12LE">
            <summary>planar YUV 4:2:2,24bpp, (1 Cr &amp; Cb sample per 2x1 Y samples), 12b alpha, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA444P12BE">
            <summary>planar YUV 4:4:4,36bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), 12b alpha, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_YUVA444P12LE">
            <summary>planar YUV 4:4:4,36bpp, (1 Cr &amp; Cb sample per 1x1 Y samples), 12b alpha, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_NV24">
            <summary>planar YUV 4:4:4, 24bpp, 1 plane for Y and 1 plane for the UV components, which are interleaved (first byte U and the following byte V)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_NV42">
            <summary>as above, but U and V bytes are swapped</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_VULKAN">
            <summary>Vulkan hardware images.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_Y210BE">
            <summary>packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, big-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_Y210LE">
            <summary>packed YUV 4:2:2 like YUYV422, 20bpp, data in the high bits, little-endian</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixelFormat.AV_PIX_FMT_NB">
            <summary>number of pixel formats, DO NOT USE THIS if you want to link with shared libav* because the number of formats might differ between versions</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVRounding">
            <summary>Rounding methods.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRounding.AV_ROUND_ZERO">
            <summary>Round toward zero.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRounding.AV_ROUND_INF">
            <summary>Round away from zero.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRounding.AV_ROUND_DOWN">
            <summary>Round toward -infinity.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRounding.AV_ROUND_UP">
            <summary>Round toward +infinity.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRounding.AV_ROUND_NEAR_INF">
            <summary>Round to nearest and halfway cases away from zero.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRounding.AV_ROUND_PASS_MINMAX">
            <summary>Flag telling rescaling functions to pass `INT64_MIN`/`MAX` through unchanged, avoiding special cases for #AV_NOPTS_VALUE.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVSampleFormat">
            <summary>Audio sample formats</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_U8">
            <summary>unsigned 8 bits</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_S16">
            <summary>signed 16 bits</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_S32">
            <summary>signed 32 bits</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_FLT">
            <summary>float</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_DBL">
            <summary>double</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_U8P">
            <summary>unsigned 8 bits, planar</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_S16P">
            <summary>signed 16 bits, planar</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_S32P">
            <summary>signed 32 bits, planar</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_FLTP">
            <summary>float, planar</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_DBLP">
            <summary>double, planar</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_S64">
            <summary>signed 64 bits</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_S64P">
            <summary>signed 64 bits, planar</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSampleFormat.AV_SAMPLE_FMT_NB">
            <summary>Number of sample formats. DO NOT USE if linking dynamically</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVStreamParseType">
            <summary>@}</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStreamParseType.AVSTREAM_PARSE_FULL">
            <summary>full parsing and repack</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStreamParseType.AVSTREAM_PARSE_HEADERS">
            <summary>Only parse headers, do not repack.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStreamParseType.AVSTREAM_PARSE_TIMESTAMPS">
            <summary>full parsing and interpolation of timestamps for frames not starting on a packet boundary</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStreamParseType.AVSTREAM_PARSE_FULL_ONCE">
            <summary>full parsing and repack of the first frame only, only implemented for H.264 currently</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStreamParseType.AVSTREAM_PARSE_FULL_RAW">
            <summary>full parsing and repack with timestamp and position generation by parser for raw this assumes that each packet in the file contains no demuxer level headers and just codec level data, otherwise position generation would fail</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleType.SUBTITLE_BITMAP">
            <summary>A bitmap, pict will be set</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleType.SUBTITLE_TEXT">
            <summary>Plain text, the text field must be set by the decoder and is authoritative. ass and pict fields may contain approximations.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleType.SUBTITLE_ASS">
            <summary>Formatted text, the ass field must be set by the decoder and is authoritative. pict and text fields may contain approximations.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVTimecodeFlag.AV_TIMECODE_FLAG_DROPFRAME">
            <summary>timecode is drop frame</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVTimecodeFlag.AV_TIMECODE_FLAG_24HOURSMAX">
            <summary>timecode wraps after 24 hours</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVTimecodeFlag.AV_TIMECODE_FLAG_ALLOWNEGATIVE">
            <summary>negative time values are allowed</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.SwrDitherType">
            <summary>Dithering algorithms</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.SwrDitherType.SWR_DITHER_NS">
            <summary>not part of API/ABI</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.SwrDitherType.SWR_DITHER_NB">
            <summary>not part of API/ABI</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.SwrEngine">
            <summary>Resampling Engines</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.SwrEngine.SWR_ENGINE_SWR">
            <summary>SW Resampler</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.SwrEngine.SWR_ENGINE_SOXR">
            <summary>SoX Resampler</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.SwrEngine.SWR_ENGINE_NB">
            <summary>not part of API/ABI</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.SwrFilterType">
            <summary>Resampling Filter Types</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.SwrFilterType.SWR_FILTER_TYPE_CUBIC">
            <summary>Cubic</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.SwrFilterType.SWR_FILTER_TYPE_BLACKMAN_NUTTALL">
            <summary>Blackman Nuttall windowed sinc</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.SwrFilterType.SWR_FILTER_TYPE_KAISER">
            <summary>Kaiser windowed sinc</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVRational">
            <summary>Rational number (pair of numerator and denominator).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRational.num">
            <summary>Numerator</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRational.den">
            <summary>Denominator</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVClass">
            <summary>Describe the class of an AVClass context structure. That is an arbitrary struct of which the first field is a pointer to an AVClass struct (e.g. AVCodecContext, AVFormatContext etc.).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.class_name">
            <summary>The name of the class; usually it is the same name as the context structure type to which the AVClass is associated.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.item_name">
            <summary>A pointer to a function which returns the name of a context instance ctx associated with the class.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.option">
            <summary>a pointer to the first option specified in the class if any or NULL</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.version">
            <summary>LIBAVUTIL_VERSION with which this structure was created. This is used to allow fields to be added without requiring major version bumps everywhere.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.log_level_offset_offset">
            <summary>Offset in the structure where log_level_offset is stored. 0 means there is no such variable</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.parent_log_context_offset">
            <summary>Offset in the structure where a pointer to the parent context for logging is stored. For example a decoder could pass its AVCodecContext to eval as such a parent context, which an av_log() implementation could then leverage to display the parent context. The offset can be NULL.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.child_next">
            <summary>Return next AVOptions-enabled child or NULL</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.child_class_next">
            <summary>Return an AVClass corresponding to the next potential AVOptions-enabled child.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.category">
            <summary>Category used for visualization (like color) This is only set if the category is equal for all objects using this class. available since version (51 &lt;&lt; 16 | 56 &lt;&lt; 8 | 100)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.get_category">
            <summary>Callback to return the category. available since version (51 &lt;&lt; 16 | 59 &lt;&lt; 8 | 100)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVClass.query_ranges">
            <summary>Callback to return the supported/allowed ranges. available since version (52.12)</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVOption">
            <summary>AVOption</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOption.help">
            <summary>short English help text</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOption.offset">
            <summary>The offset relative to the context structure where the option value is stored. It should be 0 for named constants.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOption.min">
            <summary>minimum valid value for the option</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOption.max">
            <summary>maximum valid value for the option</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOption.unit">
            <summary>The logical unit to which the option belongs. Non-constant options and corresponding named constants share the same unit. May be NULL.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVOptionRanges">
            <summary>List of AVOptionRange structs.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionRanges.range">
            <summary>Array of option ranges.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionRanges.nb_ranges">
            <summary>Number of ranges per component.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionRanges.nb_components">
            <summary>Number of componentes.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFrameSideData">
            <summary>Structure to hold side data for an AVFrame.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVBufferRef">
            <summary>A reference to a data buffer.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferRef.data">
            <summary>The data buffer. It is considered writable if and only if this is the only reference to the buffer, in which case av_buffer_is_writable() returns 1.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferRef.size">
            <summary>Size of data in bytes.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVRegionOfInterest">
            <summary>Structure describing a single Region Of Interest.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRegionOfInterest.self_size">
            <summary>Must be set to the size of this data structure (that is, sizeof(AVRegionOfInterest)).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRegionOfInterest.top">
            <summary>Distance in pixels from the top edge of the frame to the top and bottom edges and from the left edge of the frame to the left and right edges of the rectangle defining this region of interest.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVRegionOfInterest.qoffset">
            <summary>Quantisation offset.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFrame">
            <summary>This structure describes decoded (raw) audio or video data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.data">
            <summary>pointer to the picture/channel planes. This might be different from the first allocated byte</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.linesize">
            <summary>For video, size in bytes of each picture line. For audio, size in bytes of each plane.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.extended_data">
            <summary>pointers to the data planes/channels.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.width">
            <summary>Video frames only. The coded dimensions (in pixels) of the video frame, i.e. the size of the rectangle that contains some well-defined values.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.height">
            <summary>Video frames only. The coded dimensions (in pixels) of the video frame, i.e. the size of the rectangle that contains some well-defined values.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.nb_samples">
            <summary>number of audio samples (per channel) described by this frame</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.format">
            <summary>format of the frame, -1 if unknown or unset Values correspond to enum AVPixelFormat for video frames, enum AVSampleFormat for audio)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.key_frame">
            <summary>1 -&gt; keyframe, 0-&gt; not</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.pict_type">
            <summary>Picture type of the frame.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.sample_aspect_ratio">
            <summary>Sample aspect ratio for the video frame, 0/1 if unknown/unspecified.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.pts">
            <summary>Presentation timestamp in time_base units (time when frame should be shown to user).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.pkt_pts">
            <summary>PTS copied from the AVPacket that was decoded to produce this frame.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.pkt_dts">
            <summary>DTS copied from the AVPacket that triggered returning this frame. (if frame threading isn&apos;t used) This is also the Presentation time of this AVFrame calculated from only AVPacket.dts values without pts values.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.coded_picture_number">
            <summary>picture number in bitstream order</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.display_picture_number">
            <summary>picture number in display order</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.quality">
            <summary>quality (between 1 (good) and FF_LAMBDA_MAX (bad))</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.opaque">
            <summary>for some private data of the user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.repeat_pict">
            <summary>When decoding, this signals how much the picture must be delayed. extra_delay = repeat_pict / (2*fps)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.interlaced_frame">
            <summary>The content of the picture is interlaced.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.top_field_first">
            <summary>If the content is interlaced, is top field displayed first.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.palette_has_changed">
            <summary>Tell user application that palette has changed from previous frame.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.reordered_opaque">
            <summary>reordered opaque 64 bits (generally an integer or a double precision float PTS but can be anything). The user sets AVCodecContext.reordered_opaque to represent the input at that time, the decoder reorders values as needed and sets AVFrame.reordered_opaque to exactly one of the values provided by the user through AVCodecContext.reordered_opaque</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.sample_rate">
            <summary>Sample rate of the audio data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.channel_layout">
            <summary>Channel layout of the audio data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.buf">
            <summary>AVBuffer references backing the data for this frame. If all elements of this array are NULL, then this frame is not reference counted. This array must be filled contiguously -- if buf[i] is non-NULL then buf[j] must also be non-NULL for all j &lt; i.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.extended_buf">
            <summary>For planar audio which requires more than AV_NUM_DATA_POINTERS AVBufferRef pointers, this array will hold all the references which cannot fit into AVFrame.buf.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.nb_extended_buf">
            <summary>Number of elements in extended_buf.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.flags">
            <summary>Frame flags, a combination of</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.color_range">
            <summary>MPEG vs JPEG YUV range. - encoding: Set by user - decoding: Set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.colorspace">
            <summary>YUV colorspace type. - encoding: Set by user - decoding: Set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.best_effort_timestamp">
            <summary>frame timestamp estimated using various heuristics, in stream time base - encoding: unused - decoding: set by libavcodec, read by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.pkt_pos">
            <summary>reordered pos from the last AVPacket that has been input into the decoder - encoding: unused - decoding: Read by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.pkt_duration">
            <summary>duration of the corresponding packet, expressed in AVStream-&gt;time_base units, 0 if unknown. - encoding: unused - decoding: Read by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.metadata">
            <summary>metadata. - encoding: Set by user. - decoding: Set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.decode_error_flags">
            <summary>decode error flags of the frame, set to a combination of FF_DECODE_ERROR_xxx flags if the decoder produced a frame, but there were errors during the decoding. - encoding: unused - decoding: set by libavcodec, read by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.channels">
            <summary>number of audio channels, only used for audio. - encoding: unused - decoding: Read by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.pkt_size">
            <summary>size of the corresponding packet containing the compressed frame. It is set to a negative value if unknown. - encoding: unused - decoding: set by libavcodec, read by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.qscale_table">
            <summary>QP table</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.qstride">
            <summary>QP store stride</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.hw_frames_ctx">
            <summary>For hwaccel-format frames, this should be a reference to the AVHWFramesContext describing the frame.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.opaque_ref">
            <summary>AVBufferRef for free use by the API user. FFmpeg will never check the contents of the buffer ref. FFmpeg calls av_buffer_unref() on it when the frame is unreferenced. av_frame_copy_props() calls create a new reference with av_buffer_ref() for the target frame&apos;s opaque_ref field.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.crop_top">
            <summary>cropping Video frames only. The number of pixels to discard from the the top/bottom/left/right border of the frame to obtain the sub-rectangle of the frame intended for presentation. @{</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFrame.private_ref">
            <summary>AVBufferRef for internal use by a single libav* library. Must not be used to transfer data between libraries. Has to be NULL when ownership of the frame leaves the respective library.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVOptionRange">
            <summary>A single allowed range of values, or a single allowed value.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionRange.value_min">
            <summary>Value range. For string ranges this represents the min/max length. For dimensions this represents the min/max pixel count or width/height in multi-component case.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionRange.value_max">
            <summary>Value range. For string ranges this represents the min/max length. For dimensions this represents the min/max pixel count or width/height in multi-component case.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionRange.component_min">
            <summary>Value&apos;s component range. For string this represents the unicode range for chars, 0-127 limits to ASCII.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionRange.component_max">
            <summary>Value&apos;s component range. For string this represents the unicode range for chars, 0-127 limits to ASCII.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOptionRange.is_range">
            <summary>Range flag. If set to 1 the struct encodes a range, if set to 0 a single value.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVOption_default_val">
            <summary>the default value for scalar options</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVPixFmtDescriptor">
            <summary>Descriptor that unambiguously describes how the bits of a pixel are stored in the up to 4 data planes of an image. It also stores the subsampling factors and number of components.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixFmtDescriptor.nb_components">
            <summary>The number of components each pixel has, (1-4)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixFmtDescriptor.log2_chroma_w">
            <summary>Amount to shift the luma width right to find the chroma width. For YV12 this is 1 for example. chroma_width = AV_CEIL_RSHIFT(luma_width, log2_chroma_w) The note above is needed to ensure rounding up. This value only refers to the chroma components.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixFmtDescriptor.log2_chroma_h">
            <summary>Amount to shift the luma height right to find the chroma height. For YV12 this is 1 for example. chroma_height= AV_CEIL_RSHIFT(luma_height, log2_chroma_h) The note above is needed to ensure rounding up. This value only refers to the chroma components.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixFmtDescriptor.flags">
            <summary>Combination of AV_PIX_FMT_FLAG_... flags.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixFmtDescriptor.comp">
            <summary>Parameters that describe how pixels are packed. If the format has 1 or 2 components, then luma is 0. If the format has 3 or 4 components: if the RGB flag is set then 0 is red, 1 is green and 2 is blue; otherwise 0 is luma, 1 is chroma-U and 2 is chroma-V.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPixFmtDescriptor.alias">
            <summary>Alternative comma-separated names.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVComponentDescriptor.plane">
            <summary>Which of the 4 planes contains the component.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVComponentDescriptor.step">
            <summary>Number of elements between 2 horizontally consecutive pixels. Elements are bits for bitstream formats, bytes otherwise.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVComponentDescriptor.offset">
            <summary>Number of elements before the component of the first pixel. Elements are bits for bitstream formats, bytes otherwise.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVComponentDescriptor.shift">
            <summary>Number of least significant bits that must be shifted away to get the value.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVComponentDescriptor.depth">
            <summary>Number of bits in the component.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVComponentDescriptor.step_minus1">
            <summary>deprecated, use step instead</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVComponentDescriptor.depth_minus1">
            <summary>deprecated, use depth instead</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVComponentDescriptor.offset_plus1">
            <summary>deprecated, use offset instead</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVTimecode.start">
            <summary>timecode frame start (first base frame number)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVTimecode.flags">
            <summary>flags such as drop frame, +24 hours support, ...</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVTimecode.rate">
            <summary>frame rate in rational form</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVTimecode.fps">
            <summary>frame per second; must be consistent with the rate field</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVHWDeviceContext">
            <summary>This struct aggregates all the (hardware/vendor-specific) &quot;high-level&quot; state, i.e. state that is not tied to a concrete processing configuration. E.g., in an API that supports hardware-accelerated encoding and decoding, this struct will (if possible) wrap the state that is common to both encoding and decoding and from which specific instances of encoders or decoders can be derived.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWDeviceContext.av_class">
            <summary>A class for logging. Set by av_hwdevice_ctx_alloc().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWDeviceContext.internal">
            <summary>Private data used internally by libavutil. Must not be accessed in any way by the caller.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWDeviceContext.type">
            <summary>This field identifies the underlying API used for hardware access.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWDeviceContext.hwctx">
            <summary>The format-specific data, allocated and freed by libavutil along with this context.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWDeviceContext.free">
            <summary>This field may be set by the caller before calling av_hwdevice_ctx_init().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWDeviceContext.user_opaque">
            <summary>Arbitrary user data, to be used e.g. by the free() callback.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVHWFramesContext">
            <summary>This struct describes a set or pool of &quot;hardware&quot; frames (i.e. those with data not located in normal system memory). All the frames in the pool are assumed to be allocated in the same way and interchangeable.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.av_class">
            <summary>A class for logging.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.internal">
            <summary>Private data used internally by libavutil. Must not be accessed in any way by the caller.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.device_ref">
            <summary>A reference to the parent AVHWDeviceContext. This reference is owned and managed by the enclosing AVHWFramesContext, but the caller may derive additional references from it.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.device_ctx">
            <summary>The parent AVHWDeviceContext. This is simply a pointer to device_ref-&gt;data provided for convenience.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.hwctx">
            <summary>The format-specific data, allocated and freed automatically along with this context.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.free">
            <summary>This field may be set by the caller before calling av_hwframe_ctx_init().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.user_opaque">
            <summary>Arbitrary user data, to be used e.g. by the free() callback.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.pool">
            <summary>A pool from which the frames are allocated by av_hwframe_get_buffer(). This field may be set by the caller before calling av_hwframe_ctx_init(). The buffers returned by calling av_buffer_pool_get() on this pool must have the properties described in the documentation in the corresponding hw type&apos;s header (hwcontext_*.h). The pool will be freed strictly before this struct&apos;s free() callback is invoked.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.initial_pool_size">
            <summary>Initial size of the frame pool. If a device type does not support dynamically resizing the pool, then this is also the maximum pool size.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.format">
            <summary>The pixel format identifying the underlying HW surface type.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.sw_format">
            <summary>The pixel format identifying the actual data layout of the hardware frames.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.width">
            <summary>The allocated dimensions of the frames in this pool.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesContext.height">
            <summary>The allocated dimensions of the frames in this pool.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVHWFramesConstraints">
            <summary>This struct describes the constraints on hardware frames attached to a given device with a hardware-specific configuration. This is returned by av_hwdevice_get_hwframe_constraints() and must be freed by av_hwframe_constraints_free() after use.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesConstraints.valid_hw_formats">
            <summary>A list of possible values for format in the hw_frames_ctx, terminated by AV_PIX_FMT_NONE. This member will always be filled.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesConstraints.valid_sw_formats">
            <summary>A list of possible values for sw_format in the hw_frames_ctx, terminated by AV_PIX_FMT_NONE. Can be NULL if this information is not known.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesConstraints.min_width">
            <summary>The minimum size of frames in this hw_frames_ctx. (Zero if not known.)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWFramesConstraints.max_width">
            <summary>The maximum size of frames in this hw_frames_ctx. (INT_MAX if not known / no limit.)</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVDXVA2DeviceContext">
            <summary>This struct is allocated as AVHWDeviceContext.hwctx</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVDXVA2FramesContext">
            <summary>This struct is allocated as AVHWFramesContext.hwctx</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDXVA2FramesContext.surface_type">
            <summary>The surface type (e.g. DXVA2_VideoProcessorRenderTarget or DXVA2_VideoDecoderRenderTarget). Must be set by the caller.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDXVA2FramesContext.surfaces">
            <summary>The surface pool. When an external pool is not provided by the caller, this will be managed (allocated and filled on init, freed on uninit) by libavutil.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDXVA2FramesContext.decoder_to_release">
            <summary>Certain drivers require the decoder to be destroyed before the surfaces. To allow internally managed pools to work properly in such cases, this field is provided.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVD3D11VADeviceContext">
            <summary>This struct is allocated as AVHWDeviceContext.hwctx</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VADeviceContext.device">
            <summary>Device used for texture creation and access. This can also be used to set the libavcodec decoding device.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VADeviceContext.device_context">
            <summary>If unset, this will be set from the device field on init.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VADeviceContext.video_device">
            <summary>If unset, this will be set from the device field on init.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VADeviceContext.video_context">
            <summary>If unset, this will be set from the device_context field on init.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VADeviceContext.lock">
            <summary>Callbacks for locking. They protect accesses to device_context and video_context calls. They also protect access to the internal staging texture (for av_hwframe_transfer_data() calls). They do NOT protect access to hwcontext or decoder state in general.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVD3D11FrameDescriptor">
            <summary>D3D11 frame descriptor for pool allocation.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11FrameDescriptor.texture">
            <summary>The texture in which the frame is located. The reference count is managed by the AVBufferRef, and destroying the reference will release the interface.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11FrameDescriptor.index">
            <summary>The index into the array texture element representing the frame, or 0 if the texture is not an array texture.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVD3D11VAFramesContext">
            <summary>This struct is allocated as AVHWFramesContext.hwctx</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAFramesContext.texture">
            <summary>The canonical texture used for pool allocation. If this is set to NULL on init, the hwframes implementation will allocate and set an array texture if initial_pool_size &gt; 0.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAFramesContext.BindFlags">
            <summary>D3D11_TEXTURE2D_DESC.BindFlags used for texture creation. The user must at least set D3D11_BIND_DECODER if the frames context is to be used for video decoding. This field is ignored/invalid if a user-allocated texture is provided.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAFramesContext.MiscFlags">
            <summary>D3D11_TEXTURE2D_DESC.MiscFlags used for texture creation. This field is ignored/invalid if a user-allocated texture is provided.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.SwsVector.coeff">
            <summary>pointer to the list of coefficients</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.SwsVector.length">
            <summary>number of coefficients in the vector</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVPicture">
            <summary>Picture data structure.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPicture.data">
            <summary>pointers to the image data planes</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPicture.linesize">
            <summary>number of bytes per line</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleRect.x">
            <summary>top left corner of pict, undefined when pict is not set</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleRect.y">
            <summary>top left corner of pict, undefined when pict is not set</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleRect.w">
            <summary>width of pict, undefined when pict is not set</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleRect.h">
            <summary>height of pict, undefined when pict is not set</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleRect.nb_colors">
            <summary>number of colors in pict, undefined when pict is not set</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleRect.data">
            <summary>data+linesize for the bitmap of this subtitle. Can be set for text/ass as well once they are rendered.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleRect.text">
            <summary>0 terminated plain UTF-8 text</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitleRect.ass">
            <summary>0 terminated ASS/SSA compatible event line. The presentation of this is unaffected by the other values in this struct.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVCodecContext">
            <summary>main external API structure. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. You can use AVOptions (av_opt* / av_set/get*()) to access these fields from user applications. The name string for AVOptions options matches the associated command line parameter name and can be found in libavcodec/options_table.h The AVOption/command line parameter names differ in some cases from the C structure field names for historic reasons or brevity. sizeof(AVCodecContext) must not be used outside libav*.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.av_class">
            <summary>information on struct for av_log - set by avcodec_alloc_context3</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.codec_tag">
            <summary>fourcc (LSB first, so &quot;ABCD&quot; -&gt; (&apos;D&apos;&lt;&lt;24) + (&apos;C&apos;&lt;&lt;16) + (&apos;B&apos;&lt;&lt;8) + &apos;A&apos;). This is used to work around some encoder bugs. A demuxer should set this to what is stored in the field used to identify the codec. If there are multiple such fields in a container then the demuxer should choose the one which maximizes the information about the used codec. If the codec tag field in a container is larger than 32 bits then the demuxer should remap the longer ID to 32 bits with a table or other structure. Alternatively a new extra_codec_tag + size could be added but for this a clear advantage must be demonstrated first. - encoding: Set by user, if not then the default based on codec_id will be used. - decoding: Set by user, will be converted to uppercase by libavcodec during init.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.internal">
            <summary>Private context used for internal data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.opaque">
            <summary>Private data of the user, can be used to carry app specific stuff. - encoding: Set by user. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.bit_rate">
            <summary>the average bitrate - encoding: Set by user; unused for constant quantizer encoding. - decoding: Set by user, may be overwritten by libavcodec if this info is available in the stream</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.bit_rate_tolerance">
            <summary>number of bits the bitstream is allowed to diverge from the reference. the reference can be CBR (for CBR pass1) or VBR (for pass2) - encoding: Set by user; unused for constant quantizer encoding. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.global_quality">
            <summary>Global quality for codecs which cannot change it per frame. This should be proportional to MPEG-1/2/4 qscale. - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.compression_level">
            <summary>- encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.flags">
            <summary>AV_CODEC_FLAG_*. - encoding: Set by user. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.flags2">
            <summary>AV_CODEC_FLAG2_* - encoding: Set by user. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.extradata">
            <summary>some codecs need / can use extradata like Huffman tables. MJPEG: Huffman tables rv10: additional flags MPEG-4: global headers (they can be in the bitstream or here) The allocated memory should be AV_INPUT_BUFFER_PADDING_SIZE bytes larger than extradata_size to avoid problems if it is read with the bitstream reader. The bytewise contents of extradata must not depend on the architecture or CPU endianness. Must be allocated with the av_malloc() family of functions. - encoding: Set/allocated/freed by libavcodec. - decoding: Set/allocated/freed by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.time_base">
            <summary>This is the fundamental unit of time (in seconds) in terms of which frame timestamps are represented. For fixed-fps content, timebase should be 1/framerate and timestamp increments should be identically 1. This often, but not always is the inverse of the frame rate or field rate for video. 1/time_base is not the average frame rate if the frame rate is not constant.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.ticks_per_frame">
            <summary>For some codecs, the time base is closer to the field rate than the frame rate. Most notably, H.264 and MPEG-2 specify time_base as half of frame duration if no telecine is used ...</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.delay">
            <summary>Codec delay.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.width">
            <summary>picture width / height.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.height">
            <summary>picture width / height.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.coded_width">
            <summary>Bitstream width / height, may be different from width/height e.g. when the decoded frame is cropped before being output or lowres is enabled.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.coded_height">
            <summary>Bitstream width / height, may be different from width/height e.g. when the decoded frame is cropped before being output or lowres is enabled.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.gop_size">
            <summary>the number of pictures in a group of pictures, or 0 for intra_only - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.pix_fmt">
            <summary>Pixel format, see AV_PIX_FMT_xxx. May be set by the demuxer if known from headers. May be overridden by the decoder if it knows better.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.draw_horiz_band">
            <summary>If non NULL, &apos;draw_horiz_band&apos; is called by the libavcodec decoder to draw a horizontal band. It improves cache usage. Not all codecs can do that. You must check the codec capabilities beforehand. When multithreading is used, it may be called from multiple threads at the same time; threads might draw different parts of the same AVFrame, or multiple AVFrames, and there is no guarantee that slices will be drawn in order. The function is also used by hardware acceleration APIs. It is called at least once during frame decoding to pass the data needed for hardware render. In that mode instead of pixel data, AVFrame points to a structure specific to the acceleration API. The application reads the structure and can change some fields to indicate progress or mark state. - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.get_format">
            <summary>callback to negotiate the pixelFormat</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.max_b_frames">
            <summary>maximum number of B-frames between non-B-frames Note: The output will be delayed by max_b_frames+1 relative to the input. - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.b_quant_factor">
            <summary>qscale factor between IP and B-frames If &gt; 0 then the last P-frame quantizer will be used (q= lastp_q*factor+offset). If &lt; 0 then normal ratecontrol will be done (q= -normal_q*factor+offset). - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.b_quant_offset">
            <summary>qscale offset between IP and B-frames - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.has_b_frames">
            <summary>Size of the frame reordering buffer in the decoder. For MPEG-2 it is 1 IPB or 0 low delay IP. - encoding: Set by libavcodec. - decoding: Set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.i_quant_factor">
            <summary>qscale factor between P- and I-frames If &gt; 0 then the last P-frame quantizer will be used (q = lastp_q * factor + offset). If &lt; 0 then normal ratecontrol will be done (q= -normal_q*factor+offset). - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.i_quant_offset">
            <summary>qscale offset between P and I-frames - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.lumi_masking">
            <summary>luminance masking (0-&gt; disabled) - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.temporal_cplx_masking">
            <summary>temporary complexity masking (0-&gt; disabled) - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.spatial_cplx_masking">
            <summary>spatial complexity masking (0-&gt; disabled) - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.p_masking">
            <summary>p block masking (0-&gt; disabled) - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.dark_masking">
            <summary>darkness masking (0-&gt; disabled) - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.slice_count">
            <summary>slice count - encoding: Set by libavcodec. - decoding: Set by user (or 0).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.slice_offset">
            <summary>slice offsets in the frame in bytes - encoding: Set/allocated by libavcodec. - decoding: Set/allocated by user (or NULL).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.sample_aspect_ratio">
            <summary>sample aspect ratio (0 if unknown) That is the width of a pixel divided by the height of the pixel. Numerator and denominator must be relatively prime and smaller than 256 for some video standards. - encoding: Set by user. - decoding: Set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.me_cmp">
            <summary>motion estimation comparison function - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.me_sub_cmp">
            <summary>subpixel motion estimation comparison function - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.mb_cmp">
            <summary>macroblock comparison function (not supported yet) - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.ildct_cmp">
            <summary>interlaced DCT comparison function - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.dia_size">
            <summary>ME diamond size &amp; shape - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.last_predictor_count">
            <summary>amount of previous MV predictors (2a+1 x 2a+1 square) - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.me_pre_cmp">
            <summary>motion estimation prepass comparison function - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.pre_dia_size">
            <summary>ME prepass diamond size &amp; shape - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.me_subpel_quality">
            <summary>subpel ME quality - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.me_range">
            <summary>maximum motion estimation search range in subpel units If 0 then no limit.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.slice_flags">
            <summary>slice flags - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.mb_decision">
            <summary>macroblock decision mode - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.intra_matrix">
            <summary>custom intra quantization matrix Must be allocated with the av_malloc() family of functions, and will be freed in avcodec_free_context(). - encoding: Set/allocated by user, freed by libavcodec. Can be NULL. - decoding: Set/allocated/freed by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.inter_matrix">
            <summary>custom inter quantization matrix Must be allocated with the av_malloc() family of functions, and will be freed in avcodec_free_context(). - encoding: Set/allocated by user, freed by libavcodec. Can be NULL. - decoding: Set/allocated/freed by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.intra_dc_precision">
            <summary>precision of the intra DC coefficient - 8 - encoding: Set by user. - decoding: Set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.skip_top">
            <summary>Number of macroblock rows at the top which are skipped. - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.skip_bottom">
            <summary>Number of macroblock rows at the bottom which are skipped. - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.mb_lmin">
            <summary>minimum MB Lagrange multiplier - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.mb_lmax">
            <summary>maximum MB Lagrange multiplier - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.bidir_refine">
            <summary>- encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.keyint_min">
            <summary>minimum GOP size - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.refs">
            <summary>number of reference frames - encoding: Set by user. - decoding: Set by lavc.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.mv0_threshold">
            <summary>Note: Value depends upon the compare function used for fullpel ME. - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.color_primaries">
            <summary>Chromaticity coordinates of the source primaries. - encoding: Set by user - decoding: Set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.color_trc">
            <summary>Color Transfer Characteristic. - encoding: Set by user - decoding: Set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.colorspace">
            <summary>YUV colorspace type. - encoding: Set by user - decoding: Set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.color_range">
            <summary>MPEG vs JPEG YUV range. - encoding: Set by user - decoding: Set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.chroma_sample_location">
            <summary>This defines the location of chroma samples. - encoding: Set by user - decoding: Set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.slices">
            <summary>Number of slices. Indicates number of picture subdivisions. Used for parallelized decoding. - encoding: Set by user - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.field_order">
            <summary>Field order - encoding: set by libavcodec - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.sample_rate">
            <summary>samples per second</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.channels">
            <summary>number of audio channels</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.sample_fmt">
            <summary>sample format</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.frame_size">
            <summary>Number of samples per channel in an audio frame.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.frame_number">
            <summary>Frame counter, set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.block_align">
            <summary>number of bytes per packet if constant and known or 0 Used by some WAV based audio codecs.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.cutoff">
            <summary>Audio cutoff bandwidth (0 means &quot;automatic&quot;) - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.channel_layout">
            <summary>Audio channel layout. - encoding: set by user. - decoding: set by user, may be overwritten by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.request_channel_layout">
            <summary>Request decoder to use this channel layout if it can (0 for default) - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.audio_service_type">
            <summary>Type of service that the audio stream conveys. - encoding: Set by user. - decoding: Set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.request_sample_fmt">
            <summary>desired sample format - encoding: Not used. - decoding: Set by user. Decoder will decode to this format if it can.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.get_buffer2">
            <summary>This callback is called at the beginning of each frame to get data buffer(s) for it. There may be one contiguous buffer for all the data or there may be a buffer per each data plane or anything in between. What this means is, you may set however many entries in buf[] you feel necessary. Each buffer must be reference-counted using the AVBuffer API (see description of buf[] below).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.refcounted_frames">
            <summary>If non-zero, the decoded audio and video frames returned from avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted and are valid indefinitely. The caller must free them with av_frame_unref() when they are not needed anymore. Otherwise, the decoded frames must not be freed by the caller and are only valid until the next decode call.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.qcompress">
            <summary>amount of qscale change between easy &amp; hard scenes (0.0-1.0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.qblur">
            <summary>amount of qscale smoothing over time (0.0-1.0)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.qmin">
            <summary>minimum quantizer - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.qmax">
            <summary>maximum quantizer - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.max_qdiff">
            <summary>maximum quantizer difference between frames - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.rc_buffer_size">
            <summary>decoder bitstream buffer size - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.rc_override_count">
            <summary>ratecontrol override, see RcOverride - encoding: Allocated/set/freed by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.rc_max_rate">
            <summary>maximum bitrate - encoding: Set by user. - decoding: Set by user, may be overwritten by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.rc_min_rate">
            <summary>minimum bitrate - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.rc_max_available_vbv_use">
            <summary>Ratecontrol attempt to use, at maximum, &lt;value&gt; of what can be used without an underflow. - encoding: Set by user. - decoding: unused.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.rc_min_vbv_overflow_use">
            <summary>Ratecontrol attempt to use, at least, &lt;value&gt; times the amount needed to prevent a vbv overflow. - encoding: Set by user. - decoding: unused.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.rc_initial_buffer_occupancy">
            <summary>Number of bits which should be loaded into the rc buffer before decoding starts. - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.trellis">
            <summary>trellis RD quantization - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.stats_out">
            <summary>pass1 encoding statistics output buffer - encoding: Set by libavcodec. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.stats_in">
            <summary>pass2 encoding statistics input buffer Concatenated stuff from stats_out of pass1 should be placed here. - encoding: Allocated/set/freed by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.workaround_bugs">
            <summary>Work around bugs in encoders which sometimes cannot be detected automatically. - encoding: Set by user - decoding: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.strict_std_compliance">
            <summary>strictly follow the standard (MPEG-4, ...). - encoding: Set by user. - decoding: Set by user. Setting this to STRICT or higher means the encoder and decoder will generally do stupid things, whereas setting it to unofficial or lower will mean the encoder might produce output that is not supported by all spec-compliant decoders. Decoders don&apos;t differentiate between normal, unofficial and experimental (that is, they always try to decode things when they can) unless they are explicitly asked to behave stupidly (=strictly conform to the specs)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.error_concealment">
            <summary>error concealment flags - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.debug">
            <summary>debug - encoding: Set by user. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.err_recognition">
            <summary>Error recognition; may misdetect some more or less valid parts as errors. - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.reordered_opaque">
            <summary>opaque 64-bit number (generally a PTS) that will be reordered and output in AVFrame.reordered_opaque - encoding: Set by libavcodec to the reordered_opaque of the input frame corresponding to the last returned packet. Only supported by encoders with the AV_CODEC_CAP_ENCODER_REORDERED_OPAQUE capability. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.hwaccel">
            <summary>Hardware accelerator in use - encoding: unused. - decoding: Set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.hwaccel_context">
            <summary>Hardware accelerator context. For some hardware accelerators, a global context needs to be provided by the user. In that case, this holds display-dependent data FFmpeg cannot instantiate itself. Please refer to the FFmpeg HW accelerator documentation to know how to fill this is. e.g. for VA API, this is a struct vaapi_context. - encoding: unused - decoding: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.error">
            <summary>error - encoding: Set by libavcodec if flags &amp; AV_CODEC_FLAG_PSNR. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.dct_algo">
            <summary>DCT algorithm, see FF_DCT_* below - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.idct_algo">
            <summary>IDCT algorithm, see FF_IDCT_* below. - encoding: Set by user. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.bits_per_coded_sample">
            <summary>bits per sample/pixel from the demuxer (needed for huffyuv). - encoding: Set by libavcodec. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.bits_per_raw_sample">
            <summary>Bits per sample/pixel of internal libavcodec pixel/sample format. - encoding: set by user. - decoding: set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.lowres">
            <summary>low resolution decoding, 1-&gt; 1/2 size, 2-&gt;1/4 size - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.coded_frame">
            <summary>the picture in the bitstream - encoding: Set by libavcodec. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.thread_count">
            <summary>thread count is used to decide how many independent tasks should be passed to execute() - encoding: Set by user. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.thread_type">
            <summary>Which multithreading methods to use. Use of FF_THREAD_FRAME will increase decoding delay by one frame per thread, so clients which cannot provide future frames should not use it.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.active_thread_type">
            <summary>Which multithreading methods are in use by the codec. - encoding: Set by libavcodec. - decoding: Set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.thread_safe_callbacks">
            <summary>Set by the client if its custom get_buffer() callback can be called synchronously from another thread, which allows faster multithreaded decoding. draw_horiz_band() will be called from other threads regardless of this setting. Ignored if the default get_buffer() is used. - encoding: Set by user. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.execute">
            <summary>The codec may call this to execute several independent things. It will return only after finishing all tasks. The user may replace this with some multithreaded implementation, the default implementation will execute the parts serially.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.execute2">
            <summary>The codec may call this to execute several independent things. It will return only after finishing all tasks. The user may replace this with some multithreaded implementation, the default implementation will execute the parts serially. Also see avcodec_thread_init and e.g. the --enable-pthread configure option.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.nsse_weight">
            <summary>noise vs. sse weight for the nsse comparison function - encoding: Set by user. - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.profile">
            <summary>profile - encoding: Set by user. - decoding: Set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.level">
            <summary>level - encoding: Set by user. - decoding: Set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.skip_loop_filter">
            <summary>Skip loop filtering for selected frames. - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.skip_idct">
            <summary>Skip IDCT/dequantization for selected frames. - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.skip_frame">
            <summary>Skip decoding for selected frames. - encoding: unused - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.subtitle_header">
            <summary>Header containing style information for text subtitles. For SUBTITLE_ASS subtitle type, it should contain the whole ASS [Script Info] and [V4+ Styles] section, plus the [Events] line and the Format line following. It shouldn&apos;t include any Dialogue line. - encoding: Set/allocated/freed by user (before avcodec_open2()) - decoding: Set/allocated/freed by libavcodec (by avcodec_open2())</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.vbv_delay">
            <summary>VBV delay coded in the last frame (in periods of a 27 MHz clock). Used for compliant TS muxing. - encoding: Set by libavcodec. - decoding: unused.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.side_data_only_packets">
            <summary>Encoding only and set by default. Allow encoders to output packets that do not contain any encoded data, only side data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.initial_padding">
            <summary>Audio only. The number of &quot;priming&quot; samples (padding) inserted by the encoder at the beginning of the audio. I.e. this number of leading decoded samples must be discarded by the caller to get the original audio without leading padding.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.framerate">
            <summary>- decoding: For codecs that store a framerate value in the compressed bitstream, the decoder may export it here. { 0, 1} when unknown. - encoding: May be used to signal the framerate of CFR content to an encoder.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.sw_pix_fmt">
            <summary>Nominal unaccelerated pixel format, see AV_PIX_FMT_xxx. - encoding: unused. - decoding: Set by libavcodec before calling get_format()</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.pkt_timebase">
            <summary>Timebase in which pkt_dts/pts and AVPacket.dts/pts are. - encoding unused. - decoding set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.codec_descriptor">
            <summary>AVCodecDescriptor - encoding: unused. - decoding: set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.pts_correction_num_faulty_pts">
            <summary>Current statistics for PTS correction. - decoding: maintained and used by libavcodec, not intended to be used by user apps - encoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.pts_correction_num_faulty_dts">
            <summary>Number of incorrect PTS values so far</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.pts_correction_last_pts">
            <summary>Number of incorrect DTS values so far</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.pts_correction_last_dts">
            <summary>PTS of the last frame</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.sub_charenc">
            <summary>Character encoding of the input subtitles file. - decoding: set by user - encoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.sub_charenc_mode">
            <summary>Subtitles character encoding mode. Formats or codecs might be adjusting this setting (if they are doing the conversion themselves for instance). - decoding: set by libavcodec - encoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.skip_alpha">
            <summary>Skip processing alpha if supported by codec. Note that if the format uses pre-multiplied alpha (common with VP6, and recommended due to better video quality/compression) the image will look as if alpha-blended onto a black background. However for formats that do not use pre-multiplied alpha there might be serious artefacts (though e.g. libswscale currently assumes pre-multiplied alpha anyway).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.seek_preroll">
            <summary>Number of samples to skip after a discontinuity - decoding: unused - encoding: set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.debug_mv">
            <summary>debug motion vectors - encoding: Set by user. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.chroma_intra_matrix">
            <summary>custom intra quantization matrix - encoding: Set by user, can be NULL. - decoding: unused.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.dump_separator">
            <summary>dump format separator. can be &quot;, &quot; or &quot; &quot; or anything else - encoding: Set by user. - decoding: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.codec_whitelist">
            <summary>&apos;,&apos; separated list of allowed decoders. If NULL then all are allowed - encoding: unused - decoding: set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.properties">
            <summary>Properties of the stream that gets decoded - encoding: unused - decoding: set by libavcodec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.coded_side_data">
            <summary>Additional data associated with the entire coded stream.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.hw_frames_ctx">
            <summary>A reference to the AVHWFramesContext describing the input (for encoding) or output (decoding) frames. The reference is set by the caller and afterwards owned (and freed) by libavcodec - it should never be read by the caller after being set.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.sub_text_format">
            <summary>Control the form of AVSubtitle.rects[N]-&gt;ass - decoding: set by user - encoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.trailing_padding">
            <summary>Audio only. The amount of padding (in samples) appended by the encoder to the end of the audio. I.e. this number of decoded samples must be discarded by the caller from the end of the stream to get the original audio without any trailing padding.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.max_pixels">
            <summary>The number of pixels per image to maximally accept.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.hw_device_ctx">
            <summary>A reference to the AVHWDeviceContext describing the device which will be used by a hardware encoder/decoder. The reference is set by the caller and afterwards owned (and freed) by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.hwaccel_flags">
            <summary>Bit set of AV_HWACCEL_FLAG_* flags, which affect hardware accelerated decoding (if active). - encoding: unused - decoding: Set by user (either before avcodec_open2(), or in the AVCodecContext.get_format callback)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.apply_cropping">
            <summary>Video decoding only. Certain video codecs support cropping, meaning that only a sub-rectangle of the decoded frame is intended for display. This option controls how cropping is handled by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.discard_damaged_percentage">
            <summary>The percentage of damaged samples to discard a frame.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.max_samples">
            <summary>The number of samples per frame to maximally accept.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecContext.export_side_data">
            <summary>Bit set of AV_CODEC_EXPORT_DATA_* flags, which affects the kind of metadata exported in frame, packet, or coded stream side data by decoders and encoders.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVCodec">
            <summary>AVCodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.name">
            <summary>Name of the codec implementation. The name is globally unique among encoders and among decoders (but an encoder and a decoder can share the same name). This is the primary way to find a codec from the user perspective.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.long_name">
            <summary>Descriptive name for the codec, meant to be more human readable than name. You should use the NULL_IF_CONFIG_SMALL() macro to define it.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.capabilities">
            <summary>Codec capabilities. see AV_CODEC_CAP_*</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.supported_framerates">
            <summary>array of supported framerates, or NULL if any, array is terminated by {0,0}</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.pix_fmts">
            <summary>array of supported pixel formats, or NULL if unknown, array is terminated by -1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.supported_samplerates">
            <summary>array of supported audio samplerates, or NULL if unknown, array is terminated by 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.sample_fmts">
            <summary>array of supported sample formats, or NULL if unknown, array is terminated by -1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.channel_layouts">
            <summary>array of support channel layouts, or NULL if unknown. array is terminated by 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.max_lowres">
            <summary>maximum value for lowres supported by the decoder</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.priv_class">
            <summary>AVClass for the private context</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.profiles">
            <summary>array of recognized profiles, or NULL if unknown, array is terminated by {FF_PROFILE_UNKNOWN}</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.wrapper_name">
            <summary>Group name of the codec implementation. This is a short symbolic name of the wrapper backing this codec. A wrapper uses some kind of external implementation for the codec, such as an external library, or a codec implementation provided by the OS or the hardware. If this field is NULL, this is a builtin, libavcodec native codec. If non-NULL, this will be the suffix in AVCodec.name in most cases (usually AVCodec.name will be of the form &quot;&lt;codec_name&gt;_&lt;wrapper_name&gt;&quot;).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.priv_data_size">
            <summary>*************************************************************** No fields below this line are part of the public API. They may not be used outside of libavcodec and can be changed and removed at will. New public fields should be added right above. ****************************************************************</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.update_thread_context">
            <summary>@{</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.defaults">
            <summary>Private codec-specific defaults.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.init_static_data">
            <summary>Initialize codec static data, called from avcodec_register().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.encode2">
            <summary>Encode data to an AVPacket.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.send_frame">
            <summary>Encode API with decoupled packet/frame dataflow. The API is the same as the avcodec_ prefixed APIs (avcodec_send_frame() etc.), except that: - never called if the codec is closed or the wrong type, - if AV_CODEC_CAP_DELAY is not set, drain frames are never sent, - only one drain frame is ever passed down,</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.receive_frame">
            <summary>Decode API with decoupled packet/frame dataflow. This function is called to get one output frame. It should call ff_decode_get_packet() to obtain input data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.flush">
            <summary>Flush buffers. Will be called when seeking</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.caps_internal">
            <summary>Internal codec capabilities. See FF_CODEC_CAP_* in internal.h</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.bsfs">
            <summary>Decoding only, a comma-separated list of bitstream filters to apply to packets before decoding.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.hw_configs">
            <summary>Array of pointers to hardware configurations supported by the codec, or NULL if no hardware supported. The array is terminated by a NULL pointer.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodec.codec_tags">
            <summary>List of supported codec_tags, terminated by FF_CODEC_TAGS_END.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVProfile">
            <summary>AVProfile.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVProfile.name">
            <summary>short name for the profile</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVSubtitle.pts">
            <summary>Same as packet pts, in AV_TIME_BASE</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVPacket">
            <summary>This structure stores compressed data. It is typically exported by demuxers and then passed as input to decoders, or received as output from encoders and then passed to muxers.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacket.buf">
            <summary>A reference to the reference-counted buffer where the packet data is stored. May be NULL, then the packet data is not reference-counted.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacket.pts">
            <summary>Presentation timestamp in AVStream-&gt;time_base units; the time at which the decompressed packet will be presented to the user. Can be AV_NOPTS_VALUE if it is not stored in the file. pts MUST be larger or equal to dts as presentation cannot happen before decompression, unless one wants to view hex dumps. Some formats misuse the terms dts and pts/cts to mean something different. Such timestamps must be converted to true pts/dts before they are stored in AVPacket.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacket.dts">
            <summary>Decompression timestamp in AVStream-&gt;time_base units; the time at which the packet is decompressed. Can be AV_NOPTS_VALUE if it is not stored in the file.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacket.flags">
            <summary>A combination of AV_PKT_FLAG values</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacket.side_data">
            <summary>Additional packet data that can be provided by the container. Packet can contain several types of side information.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacket.duration">
            <summary>Duration of this packet in AVStream-&gt;time_base units, 0 if unknown. Equals next_pts - this_pts in presentation order.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPacket.pos">
            <summary>byte position in stream, -1 if unknown</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.name">
            <summary>Name of the hardware accelerated codec. The name is globally unique among encoders and among decoders (but an encoder and a decoder can share the same name).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.type">
            <summary>Type of codec implemented by the hardware accelerator.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.id">
            <summary>Codec implemented by the hardware accelerator.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.pix_fmt">
            <summary>Supported pixel format.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.capabilities">
            <summary>Hardware accelerated codec capabilities. see AV_HWACCEL_CODEC_CAP_*</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.alloc_frame">
            <summary>Allocate a custom buffer</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.start_frame">
            <summary>Called at the beginning of each frame or field picture.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.decode_params">
            <summary>Callback for parameter data (SPS/PPS/VPS etc).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.decode_slice">
            <summary>Callback for each slice.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.end_frame">
            <summary>Called at the end of each frame or field picture.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.frame_priv_data_size">
            <summary>Size of per-frame hardware accelerator private data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.decode_mb">
            <summary>Called for every Macroblock in a slice.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.init">
            <summary>Initialize the hwaccel private data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.uninit">
            <summary>Uninitialize the hwaccel private data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.priv_data_size">
            <summary>Size of the private data to allocate in AVCodecInternal.hwaccel_priv_data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.caps_internal">
            <summary>Internal hwaccel capabilities.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVHWAccel.frame_params">
            <summary>Fill the given hw_frames context with current codec parameters. Called from get_format. Refer to avcodec_get_hw_frames_parameters() for details.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVCodecDescriptor">
            <summary>This struct describes the properties of a single codec described by an AVCodecID.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecDescriptor.name">
            <summary>Name of the codec described by this descriptor. It is non-empty and unique for each codec descriptor. It should contain alphanumeric characters and &apos;_&apos; only.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecDescriptor.long_name">
            <summary>A more descriptive name for this codec. May be NULL.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecDescriptor.props">
            <summary>Codec properties, a combination of AV_CODEC_PROP_* flags.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecDescriptor.mime_types">
            <summary>MIME type(s) associated with the codec. May be NULL; if not, a NULL-terminated array of MIME types. The first item is always non-NULL and is the preferred MIME type.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecDescriptor.profiles">
            <summary>If non-NULL, an array of profiles recognized for this codec. Terminated with FF_PROFILE_UNKNOWN.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVPanScan">
            <summary>Pan Scan area. This specifies the area which should be displayed. Note there may be multiple such areas for one frame.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPanScan.id">
            <summary>id - encoding: Set by user. - decoding: Set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPanScan.width">
            <summary>width and height in 1/16 pel - encoding: Set by user. - decoding: Set by libavcodec.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVPanScan.position">
            <summary>position of the top left corner in 1/16 pel for up to 3 fields/frames - encoding: Set by user. - decoding: Set by libavcodec.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVCPBProperties">
            <summary>This structure describes the bitrate properties of an encoded bitstream. It roughly corresponds to a subset the VBV parameters for MPEG-2 or HRD parameters for H.264/HEVC.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCPBProperties.buffer_size">
            <summary>The size of the buffer to which the ratecontrol is applied, in bits. Zero if unknown or unspecified.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCPBProperties.vbv_delay">
            <summary>The delay between the time the packet this structure is associated with is received and the time when it should be decoded, in periods of a 27MHz clock.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVProducerReferenceTime">
            <summary>This structure supplies correlation between a packet timestamp and a wall clock production time. The definition follows the Producer Reference Time (&apos;prft&apos;) as defined in ISO/IEC 14496-12</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVProducerReferenceTime.wallclock">
            <summary>A UTC timestamp, in microseconds, since Unix epoch (e.g, av_gettime()).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.repeat_pict">
            <summary>This field is used for proper frame duration computation in lavf. It signals, how much longer the frame duration of the current frame is compared to normal frame duration.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.offset">
            <summary>byte offset from starting packet start</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.key_frame">
            <summary>Set by parser to 1 for key frames and 0 for non-key frames. It is initialized to -1, so if the parser doesn&apos;t set this flag, old-style fallback using AV_PICTURE_TYPE_I picture type as key frames will be used.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.dts_sync_point">
            <summary>Synchronization point for start of timestamp generation.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.dts_ref_dts_delta">
            <summary>Offset of the current timestamp against last timestamp sync point in units of AVCodecContext.time_base.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.pts_dts_delta">
            <summary>Presentation delay of current frame in units of AVCodecContext.time_base.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.cur_frame_pos">
            <summary>Position of the packet in file.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.pos">
            <summary>Byte position of currently parsed frame in stream.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.last_pos">
            <summary>Previous frame byte position.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.duration">
            <summary>Duration of the current frame. For audio, this is in units of 1 / AVCodecContext.sample_rate. For all other types, this is in units of AVCodecContext.time_base.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.picture_structure">
            <summary>Indicate whether a picture is coded as a frame, top field or bottom field.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.output_picture_number">
            <summary>Picture number incremented in presentation or output order. This field may be reinitialized at the first picture of a new sequence.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.width">
            <summary>Dimensions of the decoded video intended for presentation.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.coded_width">
            <summary>Dimensions of the coded video.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParserContext.format">
            <summary>The format of the coded data, corresponds to enum AVPixelFormat for video and for enum AVSampleFormat for audio.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBitStreamFilterContext.args">
            <summary>Internal default arguments, used if NULL is passed to av_bitstream_filter_filter(). Not for access by library users.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBitStreamFilter.codec_ids">
            <summary>A list of codec ids supported by the filter, terminated by AV_CODEC_ID_NONE. May be NULL, in that case the bitstream filter works with any codec id.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBitStreamFilter.priv_class">
            <summary>A class for the private data, used to declare bitstream filter private AVOptions. This field is NULL for bitstream filters that do not declare any options.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBitStreamFilter.priv_data_size">
            <summary>*************************************************************** No fields below this line are part of the public API. They may not be used outside of libavcodec and can be changed and removed at will. New public fields should be added right above. ****************************************************************</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVBSFContext">
            <summary>The bitstream filter state.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBSFContext.av_class">
            <summary>A class for logging and AVOptions</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBSFContext.filter">
            <summary>The bitstream filter this context is an instance of.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBSFContext.internal">
            <summary>Opaque libavcodec internal data. Must not be touched by the caller in any way.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBSFContext.priv_data">
            <summary>Opaque filter-specific private data. If filter-&gt;priv_class is non-NULL, this is an AVOptions-enabled struct.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBSFContext.par_in">
            <summary>Parameters of the input stream. This field is allocated in av_bsf_alloc(), it needs to be filled by the caller before av_bsf_init().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBSFContext.par_out">
            <summary>Parameters of the output stream. This field is allocated in av_bsf_alloc(), it is set by the filter in av_bsf_init().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBSFContext.time_base_in">
            <summary>The timebase used for the timestamps of the input packets. Set by the caller before av_bsf_init().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBSFContext.time_base_out">
            <summary>The timebase used for the timestamps of the output packets. Set by the filter in av_bsf_init().</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVCodecParameters">
            <summary>This struct describes the properties of an encoded stream.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.codec_type">
            <summary>General type of the encoded data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.codec_id">
            <summary>Specific type of the encoded data (the codec used).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.codec_tag">
            <summary>Additional information about the codec (corresponds to the AVI FOURCC).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.extradata">
            <summary>Extra binary data needed for initializing the decoder, codec-dependent.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.extradata_size">
            <summary>Size of the extradata content in bytes.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.format">
            <summary>- video: the pixel format, the value corresponds to enum AVPixelFormat. - audio: the sample format, the value corresponds to enum AVSampleFormat.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.bit_rate">
            <summary>The average bitrate of the encoded data (in bits per second).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.bits_per_coded_sample">
            <summary>The number of bits per sample in the codedwords.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.bits_per_raw_sample">
            <summary>This is the number of valid bits in each output sample. If the sample format has more bits, the least significant bits are additional padding bits, which are always 0. Use right shifts to reduce the sample to its actual size. For example, audio formats with 24 bit samples will have bits_per_raw_sample set to 24, and format set to AV_SAMPLE_FMT_S32. To get the original sample use &quot;(int32_t)sample &gt;&gt; 8&quot;.&quot;</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.profile">
            <summary>Codec-specific bitstream restrictions that the stream conforms to.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.width">
            <summary>Video only. The dimensions of the video frame in pixels.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.sample_aspect_ratio">
            <summary>Video only. The aspect ratio (width / height) which a single pixel should have when displayed.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.field_order">
            <summary>Video only. The order of the fields in interlaced video.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.color_range">
            <summary>Video only. Additional colorspace characteristics.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.video_delay">
            <summary>Video only. Number of delayed frames.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.channel_layout">
            <summary>Audio only. The channel layout bitmask. May be 0 if the channel layout is unknown or unspecified, otherwise the number of bits set must be equal to the channels field.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.channels">
            <summary>Audio only. The number of audio channels.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.sample_rate">
            <summary>Audio only. The number of audio samples per second.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.block_align">
            <summary>Audio only. The number of bytes per coded audio frame, required by some formats.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.frame_size">
            <summary>Audio only. Audio frame size, if known. Required by some formats to be static.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.initial_padding">
            <summary>Audio only. The amount of padding (in samples) inserted by the encoder at the beginning of the audio. I.e. this number of leading decoded samples must be discarded by the caller to get the original audio without leading padding.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.trailing_padding">
            <summary>Audio only. The amount of padding (in samples) appended by the encoder to the end of the audio. I.e. this number of decoded samples must be discarded by the caller from the end of the stream to get the original audio without any trailing padding.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecParameters.seek_preroll">
            <summary>Audio only. Number of samples to skip after a discontinuity.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecHWConfig.pix_fmt">
            <summary>For decoders, a hardware pixel format which that decoder may be able to decode to if suitable hardware is available.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecHWConfig.methods">
            <summary>Bit set of AV_CODEC_HW_CONFIG_METHOD_* flags, describing the possible setup methods which can be used with this configuration.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVCodecHWConfig.device_type">
            <summary>The device type associated with the configuration.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVD3D11VAContext">
            <summary>This structure is used to provides the necessary configurations and data to the Direct3D11 FFmpeg HWAccel implementation.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAContext.decoder">
            <summary>D3D11 decoder object</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAContext.video_context">
            <summary>D3D11 VideoContext</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAContext.cfg">
            <summary>D3D11 configuration used to create the decoder</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAContext.surface_count">
            <summary>The number of surface in the surface array</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAContext.surface">
            <summary>The array of Direct3D surfaces used to create the decoder</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAContext.workaround">
            <summary>A bit field configuring the workarounds needed for using the decoder</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAContext.report_id">
            <summary>Private to the FFmpeg AVHWAccel implementation</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVD3D11VAContext.context_mutex">
            <summary>Mutex to access video_context</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVProbeData">
            <summary>This structure contains the data a format has to probe a file.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVProbeData.buf">
            <summary>Buffer must have AVPROBE_PADDING_SIZE of extra allocated bytes filled with zero.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVProbeData.buf_size">
            <summary>Size of buf except extra allocated bytes</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVProbeData.mime_type">
            <summary>mime_type, when known.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIndexEntry.timestamp">
            <summary>Timestamp in AVStream.time_base units, preferably the time from which on correctly decoded frames are available when seeking to this entry. That means preferable PTS on keyframe based formats. But demuxers can choose to store a different timestamp, if it is more convenient for the implementation or nothing better is known</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIndexEntry.flags2_size30">
            <summary>Flag is used to indicate which frame should be discarded after decoding.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIndexEntry.min_distance">
            <summary>Minimum distance between this and the previous keyframe, used to avoid unneeded searching.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVStream">
            <summary>Stream structure. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof(AVStream) must not be used outside libav*.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.index">
            <summary>stream index in AVFormatContext</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.id">
            <summary>Format-specific stream ID. decoding: set by libavformat encoding: set by the user, replaced by libavformat if left unset</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.time_base">
            <summary>This is the fundamental unit of time (in seconds) in terms of which frame timestamps are represented.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.start_time">
            <summary>Decoding: pts of the first frame of the stream in presentation order, in stream time base. Only set this if you are absolutely 100% sure that the value you set it to really is the pts of the first frame. This may be undefined (AV_NOPTS_VALUE).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.duration">
            <summary>Decoding: duration of the stream, in stream time base. If a source file does not specify a duration, but does specify a bitrate, this value will be estimated from bitrate and file size.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.nb_frames">
            <summary>number of frames in this stream if known or 0</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.disposition">
            <summary>AV_DISPOSITION_* bit field</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.discard">
            <summary>Selects which packets can be discarded at will and do not need to be demuxed.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.sample_aspect_ratio">
            <summary>sample aspect ratio (0 if unknown) - encoding: Set by user. - decoding: Set by libavformat.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.avg_frame_rate">
            <summary>Average framerate</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.attached_pic">
            <summary>For streams with AV_DISPOSITION_ATTACHED_PIC disposition, this packet will contain the attached picture.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.side_data">
            <summary>An array of side data that applies to the whole stream (i.e. the container does not allow it to change between packets).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.nb_side_data">
            <summary>The number of elements in the AVStream.side_data array.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.event_flags">
            <summary>Flags for the user to detect events happening on the stream. Flags must be cleared by the user once the event has been handled. A combination of AVSTREAM_EVENT_FLAG_*.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.r_frame_rate">
            <summary>Real base framerate of the stream. This is the lowest framerate with which all timestamps can be represented accurately (it is the least common multiple of all framerates in the stream). Note, this value is just a guess! For example, if the time base is 1/90000 and all frames have either approximately 3600 or 1800 timer ticks, then r_frame_rate will be 50/1.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.recommended_encoder_configuration">
            <summary>String containing pairs of key and values describing recommended encoder configuration. Pairs are separated by &apos;,&apos;. Keys are separated from values by &apos;=&apos;.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.codecpar">
            <summary>Codec parameters associated with this stream. Allocated and freed by libavformat in avformat_new_stream() and avformat_free_context() respectively.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.pts_wrap_bits">
            <summary>number of bits in pts (used for wrapping control)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.first_dts">
            <summary>Timestamp corresponding to the last dts sync point.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.probe_packets">
            <summary>Number of packets to buffer for codec probing</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.codec_info_nb_frames">
            <summary>Number of frames that have been demuxed during avformat_find_stream_info()</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.last_in_packet_buffer">
            <summary>last packet in packet_buffer for this stream when muxing.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.index_entries">
            <summary>Only used if the format does not support seeking natively.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.stream_identifier">
            <summary>Stream Identifier This is the MPEG-TS stream identifier +1 0 means unknown</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.program_num">
            <summary>Details of the MPEG-TS program which created this stream.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.request_probe">
            <summary>stream probing state -1 -&gt; probing finished 0 -&gt; no probing requested rest -&gt; perform probing with request_probe being the minimum score to accept.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.skip_to_keyframe">
            <summary>Indicates that everything up to the next keyframe should be discarded.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.skip_samples">
            <summary>Number of samples to skip at the start of the frame decoded from the next packet.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.start_skip_samples">
            <summary>If not 0, the number of samples that should be skipped from the start of the stream (the samples are removed from packets with pts==0, which also assumes negative timestamps do not happen). Intended for use with formats such as mp3 with ad-hoc gapless audio support.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.first_discard_sample">
            <summary>If not 0, the first audio sample that should be discarded from the stream. This is broken by design (needs global sample count), but can&apos;t be avoided for broken by design formats such as mp3 with ad-hoc gapless audio support.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.last_discard_sample">
            <summary>The sample after last sample that is intended to be discarded after first_discard_sample. Works on frame boundaries only. Used to prevent early EOF if the gapless info is broken (considered concatenated mp3s).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.nb_decoded_frames">
            <summary>Number of internally decoded frames, used internally in libavformat, do not access its lifetime differs from info which is why it is not in that structure.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.mux_ts_offset">
            <summary>Timestamp offset added to timestamps before muxing</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.pts_wrap_reference">
            <summary>Internal data to check for wrapping of the time stamp</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.pts_wrap_behavior">
            <summary>Options for behavior, when a wrap is detected.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.update_initial_durations_done">
            <summary>Internal data to prevent doing update_initial_durations() twice</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.pts_reorder_error">
            <summary>Internal data to generate dts from pts</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.last_dts_for_order_check">
            <summary>Internal data to analyze DTS and detect faulty mpeg streams</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.inject_global_side_data">
            <summary>Internal data to inject global side data</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.display_aspect_ratio">
            <summary>display aspect ratio (0 if unknown) - encoding: unused - decoding: Set by libavformat to calculate sample_aspect_ratio internally</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream.internal">
            <summary>An opaque field for libavformat internal usage. Must not be accessed in any way by callers.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVStream_info">
            <summary>Stream information used internally by avformat_find_stream_info()</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream_info.found_decoder">
            <summary>0 -&gt; decoder has not been searched for yet. &gt;0 -&gt; decoder found &lt;0 -&gt; decoder with codec_id == -found_decoder has not been found</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVStream_info.fps_first_dts">
            <summary>Those are used for average framerate estimation.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVProgram">
            <summary>New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof(AVProgram) must not be used outside libav*.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVProgram.discard">
            <summary>selects which program to discard and which to feed to the caller</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVProgram.start_time">
            <summary>*************************************************************** All fields below this line are not part of the public API. They may not be used outside of libavformat and can be changed and removed at will. New public fields should be added right above. ****************************************************************</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVProgram.pts_wrap_reference">
            <summary>reference dts for wrap detection</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVProgram.pts_wrap_behavior">
            <summary>behavior on wrap detection</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVChapter.id">
            <summary>unique ID to identify the chapter</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVChapter.time_base">
            <summary>time base in which the start/end timestamps are specified</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVChapter.start">
            <summary>chapter start/end time in time_base units</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVChapter.end">
            <summary>chapter start/end time in time_base units</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVOutputFormat">
            <summary>@{</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.long_name">
            <summary>Descriptive name for the format, meant to be more human-readable than name. You should use the NULL_IF_CONFIG_SMALL() macro to define it.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.extensions">
            <summary>comma-separated filename extensions</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.audio_codec">
            <summary>default audio codec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.video_codec">
            <summary>default video codec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.subtitle_codec">
            <summary>default subtitle codec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.flags">
            <summary>can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_GLOBALHEADER, AVFMT_NOTIMESTAMPS, AVFMT_VARIABLE_FPS, AVFMT_NODIMENSIONS, AVFMT_NOSTREAMS, AVFMT_ALLOW_FLUSH, AVFMT_TS_NONSTRICT, AVFMT_TS_NEGATIVE</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.codec_tag">
            <summary>List of supported codec_id-codec_tag pairs, ordered by &quot;better choice first&quot;. The arrays are all terminated by AV_CODEC_ID_NONE.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.priv_class">
            <summary>AVClass for the private context</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.priv_data_size">
            <summary>size of private data so that it can be allocated in the wrapper</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.write_packet">
            <summary>Write a packet. If AVFMT_ALLOW_FLUSH is set in flags, pkt can be NULL in order to flush data buffered in the muxer. When flushing, return 0 if there still is more data to flush, or 1 if everything was flushed and there is no more buffered data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.interleave_packet">
            <summary>A format-specific function for interleavement. If unset, packets will be interleaved by dts.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.query_codec">
            <summary>Test if the given codec can be stored in this container.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.control_message">
            <summary>Allows sending messages from application to device.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.write_uncoded_frame">
            <summary>Write an uncoded AVFrame.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.get_device_list">
            <summary>Returns device list with it properties.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.create_device_capabilities">
            <summary>Initialize device capabilities submodule.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.free_device_capabilities">
            <summary>Free device capabilities submodule.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.data_codec">
            <summary>default data codec</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.init">
            <summary>Initialize format. May allocate data here, and set any AVFormatContext or AVStream parameters that need to be set before packets are sent. This method must not write output.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.deinit">
            <summary>Deinitialize format. If present, this is called whenever the muxer is being destroyed, regardless of whether or not the header has been written.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVOutputFormat.check_bitstream">
            <summary>Set up any necessary bitstream filtering and extract any extra data needed for the global header. Return 0 if more packets from this stream must be checked; 1 if not.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFormatContext">
            <summary>Format I/O context. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof(AVFormatContext) must not be used outside libav*, use avformat_alloc_context() to create an AVFormatContext.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.av_class">
            <summary>A class for logging and Exports (de)muxer private options if they exist.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.iformat">
            <summary>The input container format.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.oformat">
            <summary>The output container format.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.priv_data">
            <summary>Format private data. This is an AVOptions-enabled struct if and only if iformat/oformat.priv_class is not NULL.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.pb">
            <summary>I/O context.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.ctx_flags">
            <summary>Flags signalling stream properties. A combination of AVFMTCTX_*. Set by libavformat.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.nb_streams">
            <summary>Number of elements in AVFormatContext.streams.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.streams">
            <summary>A list of all streams in the file. New streams are created with avformat_new_stream().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.filename">
            <summary>input or output filename</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.url">
            <summary>input or output URL. Unlike the old filename field, this field has no length restriction.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.start_time">
            <summary>Position of the first frame of the component, in AV_TIME_BASE fractional seconds. NEVER set this value directly: It is deduced from the AVStream values.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.duration">
            <summary>Duration of the stream, in AV_TIME_BASE fractional seconds. Only set this value if you know none of the individual stream durations and also do not set any of them. This is deduced from the AVStream values if not set.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.bit_rate">
            <summary>Total stream bitrate in bit/s, 0 if not available. Never set it directly if the file_size and the duration are known as FFmpeg can compute it automatically.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.flags">
            <summary>Flags modifying the (de)muxer behaviour. A combination of AVFMT_FLAG_*. Set by the user before avformat_open_input() / avformat_write_header().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.probesize">
            <summary>Maximum size of the data read from input for determining the input container format. Demuxing only, set by the caller before avformat_open_input().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.max_analyze_duration">
            <summary>Maximum duration (in AV_TIME_BASE units) of the data read from input in avformat_find_stream_info(). Demuxing only, set by the caller before avformat_find_stream_info(). Can be set to 0 to let avformat choose using a heuristic.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.video_codec_id">
            <summary>Forced video codec_id. Demuxing: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.audio_codec_id">
            <summary>Forced audio codec_id. Demuxing: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.subtitle_codec_id">
            <summary>Forced subtitle codec_id. Demuxing: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.max_index_size">
            <summary>Maximum amount of memory in bytes to use for the index of each stream. If the index exceeds this size, entries will be discarded as needed to maintain a smaller size. This can lead to slower or less accurate seeking (depends on demuxer). Demuxers for which a full in-memory index is mandatory will ignore this. - muxing: unused - demuxing: set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.max_picture_buffer">
            <summary>Maximum amount of memory in bytes to use for buffering frames obtained from realtime capture devices.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.nb_chapters">
            <summary>Number of chapters in AVChapter array. When muxing, chapters are normally written in the file header, so nb_chapters should normally be initialized before write_header is called. Some muxers (e.g. mov and mkv) can also write chapters in the trailer. To write chapters in the trailer, nb_chapters must be zero when write_header is called and non-zero when write_trailer is called. - muxing: set by user - demuxing: set by libavformat</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.metadata">
            <summary>Metadata that applies to the whole file.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.start_time_realtime">
            <summary>Start time of the stream in real world time, in microseconds since the Unix epoch (00:00 1st January 1970). That is, pts=0 in the stream was captured at this real world time. - muxing: Set by the caller before avformat_write_header(). If set to either 0 or AV_NOPTS_VALUE, then the current wall-time will be used. - demuxing: Set by libavformat. AV_NOPTS_VALUE if unknown. Note that the value may become known after some number of frames have been received.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.fps_probe_size">
            <summary>The number of frames used for determining the framerate in avformat_find_stream_info(). Demuxing only, set by the caller before avformat_find_stream_info().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.error_recognition">
            <summary>Error recognition; higher values will detect more errors but may misdetect some more or less valid parts as errors. Demuxing only, set by the caller before avformat_open_input().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.interrupt_callback">
            <summary>Custom interrupt callbacks for the I/O layer.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.debug">
            <summary>Flags to enable debugging.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.max_interleave_delta">
            <summary>Maximum buffering duration for interleaving.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.strict_std_compliance">
            <summary>Allow non-standard and experimental extension</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.event_flags">
            <summary>Flags for the user to detect events happening on the file. Flags must be cleared by the user once the event has been handled. A combination of AVFMT_EVENT_FLAG_*.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.max_ts_probe">
            <summary>Maximum number of packets to read while waiting for the first timestamp. Decoding only.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.avoid_negative_ts">
            <summary>Avoid negative timestamps during muxing. Any value of the AVFMT_AVOID_NEG_TS_* constants. Note, this only works when using av_interleaved_write_frame. (interleave_packet_per_dts is in use) - muxing: Set by user - demuxing: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.ts_id">
            <summary>Transport stream id. This will be moved into demuxer private options. Thus no API/ABI compatibility</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.audio_preload">
            <summary>Audio preload in microseconds. Note, not all formats support this and unpredictable things may happen if it is used when not supported. - encoding: Set by user - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.max_chunk_duration">
            <summary>Max chunk time in microseconds. Note, not all formats support this and unpredictable things may happen if it is used when not supported. - encoding: Set by user - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.max_chunk_size">
            <summary>Max chunk size in bytes Note, not all formats support this and unpredictable things may happen if it is used when not supported. - encoding: Set by user - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.use_wallclock_as_timestamps">
            <summary>forces the use of wallclock timestamps as pts/dts of packets This has undefined results in the presence of B frames. - encoding: unused - decoding: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.avio_flags">
            <summary>avio flags, used to force AVIO_FLAG_DIRECT. - encoding: unused - decoding: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.duration_estimation_method">
            <summary>The duration field can be estimated through various ways, and this field can be used to know how the duration was estimated. - encoding: unused - decoding: Read by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.skip_initial_bytes">
            <summary>Skip initial bytes when opening stream - encoding: unused - decoding: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.correct_ts_overflow">
            <summary>Correct single timestamp overflows - encoding: unused - decoding: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.seek2any">
            <summary>Force seeking to any (also non key) frames. - encoding: unused - decoding: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.flush_packets">
            <summary>Flush the I/O context after each packet. - encoding: Set by user - decoding: unused</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.probe_score">
            <summary>format probing score. The maximal score is AVPROBE_SCORE_MAX, its set when the demuxer probes the format. - encoding: unused - decoding: set by avformat, read by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.format_probesize">
            <summary>number of bytes to read maximally to identify format. - encoding: unused - decoding: set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.codec_whitelist">
            <summary>&apos;,&apos; separated list of allowed decoders. If NULL then all are allowed - encoding: unused - decoding: set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.format_whitelist">
            <summary>&apos;,&apos; separated list of allowed demuxers. If NULL then all are allowed - encoding: unused - decoding: set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.internal">
            <summary>An opaque field for libavformat internal usage. Must not be accessed in any way by callers.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.io_repositioned">
            <summary>IO repositioned flag. This is set by avformat when the underlaying IO context read pointer is repositioned, for example when doing byte based seeking. Demuxers can use the flag to detect such changes.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.video_codec">
            <summary>Forced video codec. This allows forcing a specific decoder, even when there are multiple with the same codec_id. Demuxing: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.audio_codec">
            <summary>Forced audio codec. This allows forcing a specific decoder, even when there are multiple with the same codec_id. Demuxing: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.subtitle_codec">
            <summary>Forced subtitle codec. This allows forcing a specific decoder, even when there are multiple with the same codec_id. Demuxing: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.data_codec">
            <summary>Forced data codec. This allows forcing a specific decoder, even when there are multiple with the same codec_id. Demuxing: Set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.metadata_header_padding">
            <summary>Number of bytes to be written as padding in a metadata header. Demuxing: Unused. Muxing: Set by user via av_format_set_metadata_header_padding.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.opaque">
            <summary>User data. This is a place for some private data of the user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.control_message_cb">
            <summary>Callback used by devices to communicate with application.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.output_ts_offset">
            <summary>Output timestamp offset, in microseconds. Muxing: set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.dump_separator">
            <summary>dump format separator. can be &quot;, &quot; or &quot; &quot; or anything else - muxing: Set by user. - demuxing: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.data_codec_id">
            <summary>Forced Data codec_id. Demuxing: Set by user.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.open_cb">
            <summary>Called to open further IO contexts when needed for demuxing.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.protocol_whitelist">
            <summary>&apos;,&apos; separated list of allowed protocols. - encoding: unused - decoding: set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.io_open">
            <summary>A callback for opening new IO streams.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.io_close">
            <summary>A callback for closing the streams opened with AVFormatContext.io_open().</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.protocol_blacklist">
            <summary>&apos;,&apos; separated list of disallowed protocols. - encoding: unused - decoding: set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.max_streams">
            <summary>The maximum number of streams. - encoding: unused - decoding: set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.skip_estimate_duration_from_pts">
            <summary>Skip duration calcuation in estimate_timings_from_pts. - encoding: unused - decoding: set by user</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFormatContext.max_probe_packets">
            <summary>Maximum number of packets that can be probed - encoding: unused - decoding: set by user</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVInputFormat">
            <summary>@{</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.name">
            <summary>A comma separated list of short names for the format. New names may be appended with a minor bump.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.long_name">
            <summary>Descriptive name for the format, meant to be more human-readable than name. You should use the NULL_IF_CONFIG_SMALL() macro to define it.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.flags">
            <summary>Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER, AVFMT_SHOW_IDS, AVFMT_NOTIMESTAMPS, AVFMT_GENERIC_INDEX, AVFMT_TS_DISCONT, AVFMT_NOBINSEARCH, AVFMT_NOGENSEARCH, AVFMT_NO_BYTE_SEEK, AVFMT_SEEK_TO_PTS.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.extensions">
            <summary>If extensions are defined, then no probe is done. You should usually not use extension format guessing because it is not reliable enough</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.priv_class">
            <summary>AVClass for the private context</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.mime_type">
            <summary>Comma-separated list of mime types. It is used check for matching mime types while probing.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.next">
            <summary>*************************************************************** No fields below this line are part of the public API. They may not be used outside of libavformat and can be changed and removed at will. New public fields should be added right above. ****************************************************************</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.raw_codec_id">
            <summary>Raw demuxers store their codec ID here.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.priv_data_size">
            <summary>Size of private data so that it can be allocated in the wrapper.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.read_probe">
            <summary>Tell if a given file has a chance of being parsed as this format. The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes big so you do not have to check for that unless you need more.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.read_header">
            <summary>Read the format header and initialize the AVFormatContext structure. Return 0 if OK. &apos;avformat_new_stream&apos; should be called to create new streams.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.read_packet">
            <summary>Read one packet and put it in &apos;pkt&apos;. pts and flags are also set. &apos;avformat_new_stream&apos; can be called only if the flag AVFMTCTX_NOHEADER is used and only in the calling thread (not in a background thread).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.read_close">
            <summary>Close the stream. The AVFormatContext and AVStreams are not freed by this function</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.read_seek">
            <summary>Seek to a given timestamp relative to the frames in stream component stream_index.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.read_timestamp">
            <summary>Get the next timestamp in stream[stream_index].time_base units.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.read_play">
            <summary>Start/resume playing - only meaningful if using a network-based format (RTSP).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.read_pause">
            <summary>Pause playing - only meaningful if using a network-based format (RTSP).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.read_seek2">
            <summary>Seek to timestamp ts. Seeking will be done so that the point from which all active streams can be presented successfully will be closest to ts and within min/max_ts. Active streams are all streams that have AVStream.discard &lt; AVDISCARD_ALL.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.get_device_list">
            <summary>Returns device list with it properties.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.create_device_capabilities">
            <summary>Initialize device capabilities submodule.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVInputFormat.free_device_capabilities">
            <summary>Free device capabilities submodule.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVDeviceInfoList">
            <summary>List of devices.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDeviceInfoList.devices">
            <summary>list of autodetected devices</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDeviceInfoList.nb_devices">
            <summary>number of autodetected devices</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDeviceInfoList.default_device">
            <summary>index of default device or -1 if no default</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVDeviceCapabilitiesQuery">
            <summary>Structure describes device capabilities.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVIOContext">
            <summary>Bytestream IO Context. New fields can be added to the end with minor version bumps. Removal, reordering and changes to existing fields require a major version bump. sizeof(AVIOContext) must not be used outside libav*.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.av_class">
            <summary>A class for private options.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.buffer">
            <summary>Start of the buffer.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.buffer_size">
            <summary>Maximum buffer size</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.buf_ptr">
            <summary>Current position in the buffer</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.buf_end">
            <summary>End of the data, may be less than buffer+buffer_size if the read function returned less data than requested, e.g. for streams where no more data has been received yet.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.opaque">
            <summary>A private pointer, passed to the read/write/seek/... functions.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.pos">
            <summary>position in the file of the current buffer</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.eof_reached">
            <summary>true if was unable to read due to error or eof</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.write_flag">
            <summary>true if open for writing</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.error">
            <summary>contains the error code or 0 if no error happened</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.read_pause">
            <summary>Pause or resume playback for network streaming protocols - e.g. MMS.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.read_seek">
            <summary>Seek to a given timestamp in stream with the specified stream_index. Needed for some network streaming protocols which don&apos;t support seeking to byte position.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.seekable">
            <summary>A combination of AVIO_SEEKABLE_ flags or 0 when the stream is not seekable.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.maxsize">
            <summary>max filesize, used to limit allocations This field is internal to libavformat and access from outside is not allowed.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.direct">
            <summary>avio_read and avio_write should if possible be satisfied directly instead of going through a buffer, and avio_seek will always call the underlying seek function directly.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.bytes_read">
            <summary>Bytes read statistic This field is internal to libavformat and access from outside is not allowed.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.seek_count">
            <summary>seek statistic This field is internal to libavformat and access from outside is not allowed.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.writeout_count">
            <summary>writeout statistic This field is internal to libavformat and access from outside is not allowed.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.orig_buffer_size">
            <summary>Original buffer size used internally after probing and ensure seekback to reset the buffer size This field is internal to libavformat and access from outside is not allowed.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.short_seek_threshold">
            <summary>Threshold to favor readahead over seek. This is current internal only, do not use from outside.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.protocol_whitelist">
            <summary>&apos;,&apos; separated list of allowed protocols.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.protocol_blacklist">
            <summary>&apos;,&apos; separated list of disallowed protocols.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.write_data_type">
            <summary>A callback that is used instead of write_packet.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.ignore_boundary_point">
            <summary>If set, don&apos;t call write_data_type separately for AVIO_DATA_MARKER_BOUNDARY_POINT, but ignore them and treat them as AVIO_DATA_MARKER_UNKNOWN (to avoid needlessly small chunks of data returned from the callback).</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.current_type">
            <summary>Internal, not meant to be used from outside of AVIOContext.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.short_seek_get">
            <summary>A callback that is used instead of short_seek_threshold. This is current internal only, do not use from outside.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.buf_ptr_max">
            <summary>Maximum reached position before a backward seek in the write buffer, used keeping track of already written data for a later flush.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIOContext.min_packet_size">
            <summary>Try to buffer at least this amount of data before flushing it</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVIOInterruptCB">
            <summary>Callback for checking whether to abort blocking functions. AVERROR_EXIT is returned in this case by the interrupted function. During blocking operations, callback is called with opaque as parameter. If the callback returns 1, the blocking operation will be aborted.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVIODirEntry">
            <summary>Describes single entry of the directory.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODirEntry.name">
            <summary>Filename</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODirEntry.type">
            <summary>Type of the entry</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODirEntry.utf8">
            <summary>Set to 1 when name is encoded with UTF-8, 0 otherwise. Name can be encoded with UTF-8 even though 0 is set.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODirEntry.size">
            <summary>File size in bytes, -1 if unknown.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODirEntry.modification_timestamp">
            <summary>Time of last modification in microseconds since unix epoch, -1 if unknown.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODirEntry.access_timestamp">
            <summary>Time of last access in microseconds since unix epoch, -1 if unknown.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODirEntry.status_change_timestamp">
            <summary>Time of last status change in microseconds since unix epoch, -1 if unknown.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODirEntry.user_id">
            <summary>User ID of owner, -1 if unknown.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODirEntry.group_id">
            <summary>Group ID of owner, -1 if unknown.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVIODirEntry.filemode">
            <summary>Unix file mode, -1 if unknown.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilterContext">
            <summary>An instance of a filter</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.av_class">
            <summary>needed for av_log() and filters common options</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.filter">
            <summary>the AVFilter of which this is an instance</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.name">
            <summary>name of this filter instance</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.input_pads">
            <summary>array of input pads</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.inputs">
            <summary>array of pointers to input links</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.nb_inputs">
            <summary>number of input pads</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.output_pads">
            <summary>array of output pads</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.outputs">
            <summary>array of pointers to output links</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.nb_outputs">
            <summary>number of output pads</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.priv">
            <summary>private data for use by the filter</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.graph">
            <summary>filtergraph this filter belongs to</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.thread_type">
            <summary>Type of multithreading being allowed/used. A combination of AVFILTER_THREAD_* flags.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.internal">
            <summary>An opaque struct for libavfilter internal use.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.enable_str">
            <summary>enable expression string</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.enable">
            <summary>parsed expression (AVExpr*)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.var_values">
            <summary>variable values for the enable expression</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.is_disabled">
            <summary>the enabled state from the last expression evaluation</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.hw_device_ctx">
            <summary>For filters which will create hardware frames, sets the device the filter should create them in. All other filters will ignore this field: in particular, a filter which consumes or processes hardware frames will instead use the hw_frames_ctx field in AVFilterLink to carry the hardware context information.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.nb_threads">
            <summary>Max number of threads allowed in this filter instance. If &lt;= 0, its value is ignored. Overrides global number of threads set per filter graph.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.ready">
            <summary>Ready status of the filter. A non-0 value means that the filter needs activating; a higher value suggests a more urgent activation.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterContext.extra_hw_frames">
            <summary>Sets the number of extra hardware frames which the filter will allocate on its output links for use in following filters or by the caller.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilter">
            <summary>Filter definition. This defines the pads a filter contains, and all the callback functions used to interact with the filter.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.name">
            <summary>Filter name. Must be non-NULL and unique among filters.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.description">
            <summary>A description of the filter. May be NULL.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.inputs">
            <summary>List of inputs, terminated by a zeroed element.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.outputs">
            <summary>List of outputs, terminated by a zeroed element.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.priv_class">
            <summary>A class for the private data, used to declare filter private AVOptions. This field is NULL for filters that do not declare any options.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.flags">
            <summary>A combination of AVFILTER_FLAG_*</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.preinit">
            <summary>Filter pre-initialization function</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.init">
            <summary>Filter initialization function.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.init_dict">
            <summary>Should be set instead of want to pass a dictionary of AVOptions to nested contexts that are allocated during init.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.uninit">
            <summary>Filter uninitialization function.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.query_formats">
            <summary>Query formats supported by the filter on its inputs and outputs.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.priv_size">
            <summary>size of private data to allocate for the filter</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.flags_internal">
            <summary>Additional flags for avfilter internal use only.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.next">
            <summary>Used by the filter registration system. Must not be touched by any other code.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.process_command">
            <summary>Make the filter instance process a command.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.init_opaque">
            <summary>Filter initialization function, alternative to the init() callback. Args contains the user-supplied parameters, opaque is used for providing binary data.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilter.activate">
            <summary>Filter activation function.</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilterLink">
            <summary>A link between two filters. This contains pointers to the source and destination filters between which this link exists, and the indexes of the pads involved. In addition, this link also contains the parameters which have been negotiated and agreed upon between the filter, such as image dimensions, format, etc.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.src">
            <summary>source filter</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.srcpad">
            <summary>output pad on the source filter</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.dst">
            <summary>dest filter</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.dstpad">
            <summary>input pad on the dest filter</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.type">
            <summary>filter media type</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.w">
            <summary>agreed upon image width</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.h">
            <summary>agreed upon image height</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.sample_aspect_ratio">
            <summary>agreed upon sample aspect ratio</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.channel_layout">
            <summary>channel layout of current buffer (see libavutil/channel_layout.h)</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.sample_rate">
            <summary>samples per second</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.format">
            <summary>agreed upon media format</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.time_base">
            <summary>Define the time base used by the PTS of the frames/samples which will pass through this link. During the configuration stage, each filter is supposed to change only the output timebase, while the timebase of the input link is assumed to be an unchangeable property.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.in_formats">
            <summary>*************************************************************** All fields below this line are not part of the public API. They may not be used outside of libavfilter and can be changed and removed at will. New public fields should be added right above. ****************************************************************</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.in_samplerates">
            <summary>Lists of channel layouts and sample rates used for automatic negotiation.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.request_samples">
            <summary>Audio only, the destination filter sets this to a non-zero value to request that buffers with the given number of samples should be sent to it. AVFilterPad.needs_fifo must also be set on the corresponding input pad. Last buffer before EOF will be padded with silence.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.graph">
            <summary>Graph the filter belongs to.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.current_pts">
            <summary>Current timestamp of the link, as defined by the most recent frame(s), in link time_base units.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.current_pts_us">
            <summary>Current timestamp of the link, as defined by the most recent frame(s), in AV_TIME_BASE units.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.age_index">
            <summary>Index in the age array.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.frame_rate">
            <summary>Frame rate of the stream on the link, or 1/0 if unknown or variable; if left to 0/0, will be automatically copied from the first input of the source filter if it exists.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.partial_buf">
            <summary>Buffer partially filled with samples to achieve a fixed/minimum size.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.partial_buf_size">
            <summary>Size of the partial buffer to allocate. Must be between min_samples and max_samples.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.min_samples">
            <summary>Minimum number of samples to filter at once. If filter_frame() is called with fewer samples, it will accumulate them in partial_buf. This field and the related ones must not be changed after filtering has started. If 0, all related fields are ignored.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.max_samples">
            <summary>Maximum number of samples to filter at once. If filter_frame() is called with more samples, it will split them.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.channels">
            <summary>Number of channels.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.flags">
            <summary>Link processing flags.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.frame_count_in">
            <summary>Number of past frames sent through the link.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.frame_count_out">
            <summary>Number of past frames sent through the link.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.frame_pool">
            <summary>A pointer to a FFFramePool struct.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.frame_wanted_out">
            <summary>True if a frame is currently wanted on the output of this filter. Set when ff_request_frame() is called by the output, cleared when a frame is filtered.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.hw_frames_ctx">
            <summary>For hwaccel pixel formats, this should be a reference to the AVHWFramesContext describing the frames.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterLink.reserved">
            <summary>Internal structure members. The fields below this limit are internal for libavfilter&apos;s use and must in no way be accessed by applications.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterGraph.scale_sws_opts">
            <summary>sws options to use for the auto-inserted scale filters</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterGraph.resample_lavr_opts">
            <summary>libavresample options to use for the auto-inserted resample filters</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterGraph.thread_type">
            <summary>Type of multithreading allowed for filters in this graph. A combination of AVFILTER_THREAD_* flags.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterGraph.nb_threads">
            <summary>Maximum number of threads used by filters in this graph. May be set by the caller before adding any filters to the filtergraph. Zero (the default) means that the number of threads is determined automatically.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterGraph.internal">
            <summary>Opaque object for libavfilter internal use.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterGraph.opaque">
            <summary>Opaque user data. May be set by the caller to an arbitrary value, e.g. to be used from callbacks like Libavfilter will not touch this field in any way.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterGraph.execute">
            <summary>This callback may be set by the caller immediately after allocating the graph and before adding any filters to it, to provide a custom multithreading implementation.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterGraph.aresample_swr_opts">
            <summary>swr options to use for the auto-inserted aresample filters, Access ONLY through AVOptions</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterGraph.sink_links">
            <summary>Private fields</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilterInOut">
            <summary>A linked-list of the inputs/outputs of the filter chain.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterInOut.name">
            <summary>unique name for this input/output in the list</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterInOut.filter_ctx">
            <summary>filter context associated to this input/output</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterInOut.pad_idx">
            <summary>index of the filt_ctx pad to use for linking</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVFilterInOut.next">
            <summary>next input/input in the list, NULL if this is the last</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVBufferSrcParameters">
            <summary>This structure contains the parameters describing the frames that will be passed to this filter.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferSrcParameters.format">
            <summary>video: the pixel format, value corresponds to enum AVPixelFormat audio: the sample format, value corresponds to enum AVSampleFormat</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferSrcParameters.time_base">
            <summary>The timebase to be used for the timestamps on the input frames.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferSrcParameters.width">
            <summary>Video only, the display dimensions of the input frames.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferSrcParameters.height">
            <summary>Video only, the display dimensions of the input frames.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferSrcParameters.sample_aspect_ratio">
            <summary>Video only, the sample (pixel) aspect ratio.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferSrcParameters.frame_rate">
            <summary>Video only, the frame rate of the input video. This field must only be set to a non-zero value if input stream has a known constant framerate and should be left at its initial value if the framerate is variable or unknown.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferSrcParameters.hw_frames_ctx">
            <summary>Video with a hwaccel pixel format only. This should be a reference to an AVHWFramesContext instance describing the input frames.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferSrcParameters.sample_rate">
            <summary>Audio only, the audio sampling rate in samples per second.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferSrcParameters.channel_layout">
            <summary>Audio only, the audio channel layout</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVBufferSinkParams">
            <summary>Struct to use for initializing a buffersink context.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVBufferSinkParams.pixel_fmts">
            <summary>list of allowed pixel formats, terminated by AV_PIX_FMT_NONE</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVABufferSinkParams">
            <summary>Struct to use for initializing an abuffersink context.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVABufferSinkParams.sample_fmts">
            <summary>list of allowed sample formats, terminated by AV_SAMPLE_FMT_NONE</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVABufferSinkParams.channel_layouts">
            <summary>list of allowed channel layouts, terminated by -1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVABufferSinkParams.channel_counts">
            <summary>list of allowed channel counts, terminated by -1</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVABufferSinkParams.all_channel_counts">
            <summary>if not 0, accept any channel count or layout</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVABufferSinkParams.sample_rates">
            <summary>list of allowed sample rates, terminated by -1</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVDeviceInfo">
            <summary>Structure describes basic parameters of the device.</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDeviceInfo.device_name">
            <summary>device name, format depends on device</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDeviceInfo.device_description">
            <summary>human friendly name</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDeviceRect.x">
            <summary>x coordinate of top left corner</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDeviceRect.y">
            <summary>y coordinate of top left corner</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDeviceRect.width">
            <summary>width</summary>
        </member>
        <member name="F:FFmpeg.AutoGen.AVDeviceRect.height">
            <summary>height</summary>
        </member>
        <member name="T:FFmpeg.AutoGen.AVAudioFifo">
            <summary>Context for an Audio FIFO Buffer.</summary>
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVBPrint">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVDictionary">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVBuffer">
            <summary>A reference counted buffer type. It is opaque and is meant to be used through references (AVBufferRef).</summary>
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVBufferPool">
            <summary>The buffer pool. This structure is opaque and not meant to be accessed directly. It is allocated with av_buffer_pool_init() and freed with av_buffer_pool_uninit().</summary>
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVTreeNode">
            <summary>Low-complexity tree container</summary>
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVHWDeviceInternal">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVHWFramesInternal">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.SwrContext">
            <summary>The libswresample context. Unlike libavcodec and libavformat, this structure is opaque. This means that if you would like to set options, you must use the structure.</summary>
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.SwsContext">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVCodecDefault">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVCodecHWConfigInternal">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVCodecInternal">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.MpegEncContext">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVBSFInternal">
            <summary>@{</summary>
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVBSFList">
            <summary>Structure for chain/list of bitstream filters. Empty list can be allocated by av_bsf_list_alloc().</summary>
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVStreamInternal">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFormatInternal">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVCodecTag">
            <summary>**********************************************</summary>
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.URLContext">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilterPad">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilterFormats">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilterChannelLayouts">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilterGraphInternal">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilterInternal">
            <remarks>This struct is incomplete.</remarks>
        </member>
        <member name="T:FFmpeg.AutoGen.AVFilterCommand">
            <remarks>This struct is incomplete.</remarks>
        </member>
    </members>
</doc>
